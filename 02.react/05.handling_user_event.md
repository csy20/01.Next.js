# React Event Handling: Mastering User Interactions

## 🎯 Introduction: The Bridge Between Users and State

Event handling is how your React components respond to user interactions like clicks, form submissions, keyboard input, and mouse movements. It's the **critical bridge between user actions and state changes** that makes your applications interactive and dynamic.

### 🔄 React's Synthetic Event System

React doesn't use native DOM events directly. Instead, it wraps them in **Synthetic Events** - a powerful abstraction that provides:

#### **🌐 Cross-Browser Compatibility**
```jsx
// ✅ React Synthetic Events work the same everywhere
const handleClick = (event) => {
  event.preventDefault(); // Works in all browsers
  event.stopPropagation(); // Consistent behavior
  console.log(event.type); // Always 'click'
};

// ❌ Native events have browser differences
// In some browsers: event.preventDefault()
// In others: event.returnValue = false
```

#### **🎭 Event Object Properties**
```jsx
const handleEvent = (syntheticEvent) => {
  // ✅ Synthetic Event properties (consistent across browsers)
  console.log(syntheticEvent.type);        // Event type: 'click', 'change', etc.
  console.log(syntheticEvent.target);      // Element that triggered the event
  console.log(syntheticEvent.currentTarget); // Element the event handler is attached to
  console.log(syntheticEvent.preventDefault); // Function to prevent default
  console.log(syntheticEvent.stopPropagation); // Function to stop bubbling
  
  // 🔧 Access native event if needed
  const nativeEvent = syntheticEvent.nativeEvent;
  console.log(nativeEvent); // Original DOM event
};
```

#### **⚡ Event Pooling & Performance**
```jsx
const handleClick = (event) => {
  // ✅ React pools events for performance
  console.log(event.type); // 'click' - available immediately
  
  // ❌ Don't store events for async operations
  setTimeout(() => {
    console.log(event.type); // null - event is pooled
  }, 1000);
  
  // ✅ If you need to store event data, extract it first
  const eventType = event.type;
  const targetValue = event.target.value;
  
  setTimeout(() => {
    console.log(eventType); // 'click' - works!
    console.log(targetValue); // value - works!
  }, 1000);
};
```

## 🎛️ Event Handler Patterns

### 📝 Basic Event Handler Syntax

```jsx
const BasicEventExample = () => {
  const [message, setMessage] = useState('');
  const [clickCount, setClickCount] = useState(0);
  
  // 1️⃣ Named function approach (recommended for complex logic)
  const handleButtonClick = () => {
    setMessage('Button was clicked!');
    setClickCount(prev => prev + 1);
  };
  
  // 2️⃣ Inline arrow function (good for simple operations)
  const handleReset = () => {
    setMessage('');
    setClickCount(0);
  };
  
  return (
    <div className="event-example">
      <p>{message}</p>
      <p>Clicked {clickCount} times</p>
      
      {/* ✅ Named function reference */}
      <button onClick={handleButtonClick}>
        Click Me
      </button>
      
      {/* ✅ Inline arrow function */}
      <button onClick={handleReset}>
        Reset
      </button>
      
      {/* ✅ Inline anonymous function (use sparingly) */}
      <button onClick={() => setMessage('Inline click!')}>
        Inline Handler
      </button>
    </div>
  );
};
```

### 🎨 Advanced Event Handler Patterns

#### **1. Event Handlers with Parameters**
```jsx
const ParameterizedHandlers = () => {
  const [selectedColor, setSelectedColor] = useState('');
  const [notifications, setNotifications] = useState([]);
  
  // ✅ Pattern 1: Arrow function wrapper
  const colors = ['red', 'blue', 'green', 'yellow', 'purple'];
  
  const addNotification = (message, type = 'info') => {
    const notification = {
      id: Date.now(),
      message,
      type,
      timestamp: new Date().toLocaleTimeString()
    };
    setNotifications(prev => [...prev, notification]);
  };
  
  const removeNotification = (id) => {
    setNotifications(prev => prev.filter(n => n.id !== id));
  };
  
  return (
    <div className="parameterized-handlers">
      <div className="color-picker">
        <h3>Selected Color: {selectedColor}</h3>
        {colors.map(color => (
          <button
            key={color}
            onClick={() => setSelectedColor(color)} // ✅ Wrapper function
            style={{ 
              backgroundColor: color, 
              color: 'white',
              margin: '5px',
              padding: '10px'
            }}
          >
            {color}
          </button>
        ))}
      </div>
      
      <div className="notification-demo">
        <button onClick={() => addNotification('Success message', 'success')}>
          Add Success
        </button>
        <button onClick={() => addNotification('Warning message', 'warning')}>
          Add Warning  
        </button>
        <button onClick={() => addNotification('Error message', 'error')}>
          Add Error
        </button>
        
        <div className="notifications">
          {notifications.map(notification => (
            <div 
              key={notification.id} 
              className={`notification ${notification.type}`}
            >
              <span>{notification.message}</span>
              <span className="timestamp">{notification.timestamp}</span>
              <button onClick={() => removeNotification(notification.id)}>
                ×
              </button>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

#### **2. Generic Event Handlers**
```jsx
const GenericHandlers = () => {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    age: '',
    country: '',
    newsletter: false,
    interests: []
  });
  
  // ✅ Generic handler for all input types
  const handleInputChange = (event) => {
    const { name, value, type, checked } = event.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  // ✅ Generic handler with transformation
  const handleNumberInput = (event) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value === '' ? '' : Number(value)
    }));
  };
  
  // ✅ Array handling for checkboxes
  const handleInterestChange = (interest) => (event) => {
    const { checked } = event.target;
    setFormData(prev => ({
      ...prev,
      interests: checked 
        ? [...prev.interests, interest]
        : prev.interests.filter(i => i !== interest)
    }));
  };
  
  return (
    <form className="generic-form">
      <input
        type="text"
        name="username"
        value={formData.username}
        onChange={handleInputChange}
        placeholder="Username"
      />
      
      <input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleInputChange}
        placeholder="Email"
      />
      
      <input
        type="number"
        name="age"
        value={formData.age}
        onChange={handleNumberInput}
        placeholder="Age"
      />
      
      <select
        name="country"
        value={formData.country}
        onChange={handleInputChange}
      >
        <option value="">Select Country</option>
        <option value="us">United States</option>
        <option value="uk">United Kingdom</option>
        <option value="ca">Canada</option>
      </select>
      
      <label>
        <input
          type="checkbox"
          name="newsletter"
          checked={formData.newsletter}
          onChange={handleInputChange}
        />
        Subscribe to newsletter
      </label>
      
      <fieldset>
        <legend>Interests:</legend>
        {['Technology', 'Sports', 'Music', 'Travel'].map(interest => (
          <label key={interest}>
            <input
              type="checkbox"
              checked={formData.interests.includes(interest)}
              onChange={handleInterestChange(interest)}
            />
            {interest}
          </label>
        ))}
      </fieldset>
      
      <div className="form-preview">
        <h4>Form Data Preview:</h4>
        <pre>{JSON.stringify(formData, null, 2)}</pre>
      </div>
    </form>
  );
};
```

## 🎯 Specific Event Types

### 🖱️ Mouse Events

```jsx
const MouseEventDemo = () => {
  const [mouseData, setMouseData] = useState({
    position: { x: 0, y: 0 },
    clicks: { left: 0, right: 0, double: 0 },
    hover: false,
    pressed: false
  });
  
  const handleMouseMove = (event) => {
    setMouseData(prev => ({
      ...prev,
      position: {
        x: event.clientX,
        y: event.clientY
      }
    }));
  };
  
  const handleLeftClick = () => {
    setMouseData(prev => ({
      ...prev,
      clicks: { ...prev.clicks, left: prev.clicks.left + 1 }
    }));
  };
  
  const handleRightClick = (event) => {
    event.preventDefault(); // Prevent context menu
    setMouseData(prev => ({
      ...prev,
      clicks: { ...prev.clicks, right: prev.clicks.right + 1 }
    }));
  };
  
  const handleDoubleClick = () => {
    setMouseData(prev => ({
      ...prev,
      clicks: { ...prev.clicks, double: prev.clicks.double + 1 }
    }));
  };
  
  const handleMouseEnter = () => {
    setMouseData(prev => ({ ...prev, hover: true }));
  };
  
  const handleMouseLeave = () => {
    setMouseData(prev => ({ ...prev, hover: false }));
  };
  
  const handleMouseDown = () => {
    setMouseData(prev => ({ ...prev, pressed: true }));
  };
  
  const handleMouseUp = () => {
    setMouseData(prev => ({ ...prev, pressed: false }));
  };
  
  return (
    <div 
      className="mouse-demo"
      onMouseMove={handleMouseMove}
      style={{ minHeight: '300px', border: '2px solid #ccc', padding: '20px' }}
    >
      <h3>Mouse Event Demo</h3>
      
      <div 
        className={`interactive-box ${mouseData.hover ? 'hovered' : ''} ${mouseData.pressed ? 'pressed' : ''}`}
        onClick={handleLeftClick}
        onContextMenu={handleRightClick}
        onDoubleClick={handleDoubleClick}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        style={{
          width: '200px',
          height: '100px',
          backgroundColor: mouseData.hover ? '#e0e0e0' : '#f0f0f0',
          border: mouseData.pressed ? '3px solid blue' : '1px solid gray',
          cursor: 'pointer',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          userSelect: 'none',
          transition: 'all 0.2s'
        }}
      >
        Click me with different mouse buttons!
      </div>
      
      <div className="mouse-stats">
        <p>Mouse Position: ({mouseData.position.x}, {mouseData.position.y})</p>
        <p>Left Clicks: {mouseData.clicks.left}</p>
        <p>Right Clicks: {mouseData.clicks.right}</p>
        <p>Double Clicks: {mouseData.clicks.double}</p>
        <p>Hovering: {mouseData.hover ? 'Yes' : 'No'}</p>
        <p>Mouse Pressed: {mouseData.pressed ? 'Yes' : 'No'}</p>
      </div>
    </div>
  );
};
```

### ⌨️ Keyboard Events

```jsx
const KeyboardEventDemo = () => {
  const [keyData, setKeyData] = useState({
    lastKey: '',
    keyHistory: [],
    modifiers: { ctrl: false, shift: false, alt: false },
    shortcuts: []
  });
  
  const [inputValue, setInputValue] = useState('');
  
  const handleKeyDown = (event) => {
    const { key, ctrlKey, shiftKey, altKey, code } = event;
    
    // Update modifiers
    setKeyData(prev => ({
      ...prev,
      lastKey: key,
      modifiers: {
        ctrl: ctrlKey,
        shift: shiftKey,
        alt: altKey
      }
    }));
    
    // Add to history
    setKeyData(prev => ({
      ...prev,
      keyHistory: [
        ...prev.keyHistory.slice(-9), // Keep last 10
        { key, code, timestamp: Date.now() }
      ]
    }));
    
    // Handle keyboard shortcuts
    if (ctrlKey && shiftKey && key === 'K') {
      event.preventDefault();
      setKeyData(prev => ({
        ...prev,
        shortcuts: [...prev.shortcuts, 'Ctrl+Shift+K triggered!']
      }));
    }
    
    if (ctrlKey && key === 'Enter') {
      event.preventDefault();
      setKeyData(prev => ({
        ...prev,
        shortcuts: [...prev.shortcuts, 'Ctrl+Enter triggered!']
      }));
    }
    
    // Handle special keys
    if (key === 'Escape') {
      setInputValue('');
      setKeyData(prev => ({
        ...prev,
        shortcuts: [...prev.shortcuts, 'Escaped! Input cleared.']
      }));
    }
  };
  
  const handleInputKeyPress = (event) => {
    if (event.key === 'Enter') {
      if (event.ctrlKey) {
        // Ctrl+Enter: Submit
        alert(`Submitting: ${inputValue}`);
      } else {
        // Just Enter: New line (in textarea) or submit (in input)
        event.preventDefault();
        alert(`Simple Enter: ${inputValue}`);
      }
    }
  };
  
  const clearHistory = () => {
    setKeyData(prev => ({
      ...prev,
      keyHistory: [],
      shortcuts: []
    }));
  };
  
  return (
    <div className="keyboard-demo" onKeyDown={handleKeyDown} tabIndex={0}>
      <h3>Keyboard Event Demo</h3>
      <p>Click here and start typing! Try Ctrl+Shift+K or Ctrl+Enter</p>
      
      <div className="keyboard-stats">
        <p>Last Key: <strong>{keyData.lastKey}</strong></p>
        <p>
          Modifiers: 
          <span className={keyData.modifiers.ctrl ? 'active' : ''}>Ctrl</span>
          <span className={keyData.modifiers.shift ? 'active' : ''}>Shift</span>
          <span className={keyData.modifiers.alt ? 'active' : ''}>Alt</span>
        </p>
      </div>
      
      <div className="interactive-input">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={handleInputKeyPress}
          placeholder="Type here... Try Enter or Ctrl+Enter"
        />
      </div>
      
      <div className="key-history">
        <h4>Key History:</h4>
        <div className="key-list">
          {keyData.keyHistory.map((keyInfo, index) => (
            <span key={index} className="key-badge">
              {keyInfo.key}
            </span>
          ))}
        </div>
      </div>
      
      <div className="shortcuts">
        <h4>Shortcuts Triggered:</h4>
        {keyData.shortcuts.map((shortcut, index) => (
          <div key={index} className="shortcut-message">
            {shortcut}
          </div>
        ))}
      </div>
      
      <button onClick={clearHistory}>Clear History</button>
    </div>
  );
};
```

### 📝 Form Events

```jsx
const FormEventDemo = () => {
  const [formState, setFormState] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    biography: '',
    country: '',
    agreeToTerms: false,
    interests: []
  });
  
  const [validation, setValidation] = useState({});
  const [touchedFields, setTouchedFields] = useState({});
  const [submitAttempted, setSubmitAttempted] = useState(false);
  
  // Real-time validation
  const validateField = (name, value) => {
    const validators = {
      username: (val) => {
        if (!val.trim()) return 'Username is required';
        if (val.length < 3) return 'Username must be at least 3 characters';
        return '';
      },
      email: (val) => {
        if (!val.trim()) return 'Email is required';
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(val)) return 'Please enter a valid email';
        return '';
      },
      password: (val) => {
        if (!val) return 'Password is required';
        if (val.length < 6) return 'Password must be at least 6 characters';
        if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(val)) {
          return 'Password must contain uppercase, lowercase, and number';
        }
        return '';
      },
      confirmPassword: (val) => {
        if (!val) return 'Please confirm your password';
        if (val !== formState.password) return 'Passwords do not match';
        return '';
      }
    };
    
    return validators[name] ? validators[name](value) : '';
  };
  
  const handleInputChange = (event) => {
    const { name, value, type, checked } = event.target;
    const newValue = type === 'checkbox' ? checked : value;
    
    setFormState(prev => ({
      ...prev,
      [name]: newValue
    }));
    
    // Validate on change if field has been touched or submit attempted
    if (touchedFields[name] || submitAttempted) {
      const error = validateField(name, newValue);
      setValidation(prev => ({
        ...prev,
        [name]: error
      }));
    }
  };
  
  const handleBlur = (event) => {
    const { name, value } = event.target;
    
    setTouchedFields(prev => ({
      ...prev,
      [name]: true
    }));
    
    const error = validateField(name, value);
    setValidation(prev => ({
      ...prev,
      [name]: error
    }));
  };
  
  const handleFocus = (event) => {
    const { name } = event.target;
    console.log(`Field ${name} focused`);
  };
  
  const handleSubmit = (event) => {
    event.preventDefault();
    setSubmitAttempted(true);
    
    // Validate all fields
    const newValidation = {};
    Object.keys(formState).forEach(field => {
      const error = validateField(field, formState[field]);
      if (error) newValidation[field] = error;
    });
    
    // Check required checkbox
    if (!formState.agreeToTerms) {
      newValidation.agreeToTerms = 'You must agree to the terms';
    }
    
    setValidation(newValidation);
    
    // If no errors, submit
    if (Object.keys(newValidation).length === 0) {
      alert('Form submitted successfully!');
      console.log('Form data:', formState);
    }
  };
  
  const handleReset = (event) => {
    setFormState({
      username: '',
      email: '',
      password: '',
      confirmPassword: '',
      biography: '',
      country: '',
      agreeToTerms: false,
      interests: []
    });
    setValidation({});
    setTouchedFields({});
    setSubmitAttempted(false);
  };
  
  return (
    <form 
      className="form-demo" 
      onSubmit={handleSubmit}
      onReset={handleReset}
      noValidate
    >
      <h3>Comprehensive Form Demo</h3>
      
      <div className="form-group">
        <label htmlFor="username">Username:</label>
        <input
          id="username"
          name="username"
          type="text"
          value={formState.username}
          onChange={handleInputChange}
          onBlur={handleBlur}
          onFocus={handleFocus}
          className={validation.username ? 'error' : ''}
          required
        />
        {validation.username && (
          <span className="error-message">{validation.username}</span>
        )}
      </div>
      
      <div className="form-group">
        <label htmlFor="email">Email:</label>
        <input
          id="email"
          name="email"
          type="email"
          value={formState.email}
          onChange={handleInputChange}
          onBlur={handleBlur}
          onFocus={handleFocus}
          className={validation.email ? 'error' : ''}
          required
        />
        {validation.email && (
          <span className="error-message">{validation.email}</span>
        )}
      </div>
      
      <div className="form-group">
        <label htmlFor="password">Password:</label>
        <input
          id="password"
          name="password"
          type="password"
          value={formState.password}
          onChange={handleInputChange}
          onBlur={handleBlur}
          onFocus={handleFocus}
          className={validation.password ? 'error' : ''}
          required
        />
        {validation.password && (
          <span className="error-message">{validation.password}</span>
        )}
      </div>
      
      <div className="form-group">
        <label htmlFor="confirmPassword">Confirm Password:</label>
        <input
          id="confirmPassword"
          name="confirmPassword"
          type="password"
          value={formState.confirmPassword}
          onChange={handleInputChange}
          onBlur={handleBlur}
          className={validation.confirmPassword ? 'error' : ''}
          required
        />
        {validation.confirmPassword && (
          <span className="error-message">{validation.confirmPassword}</span>
        )}
      </div>
      
      <div className="form-group">
        <label htmlFor="biography">Biography:</label>
        <textarea
          id="biography"
          name="biography"
          value={formState.biography}
          onChange={handleInputChange}
          rows={4}
          placeholder="Tell us about yourself..."
        />
      </div>
      
      <div className="form-group">
        <label htmlFor="country">Country:</label>
        <select
          id="country"
          name="country"
          value={formState.country}
          onChange={handleInputChange}
        >
          <option value="">Select a country</option>
          <option value="us">United States</option>
          <option value="uk">United Kingdom</option>
          <option value="ca">Canada</option>
          <option value="au">Australia</option>
        </select>
      </div>
      
      <div className="form-group">
        <label>
          <input
            name="agreeToTerms"
            type="checkbox"
            checked={formState.agreeToTerms}
            onChange={handleInputChange}
          />
          I agree to the terms and conditions
        </label>
        {validation.agreeToTerms && (
          <span className="error-message">{validation.agreeToTerms}</span>
        )}
      </div>
      
      <div className="form-actions">
        <button type="submit">Submit</button>
        <button type="reset">Reset</button>
      </div>
      
      <div className="form-debug">
        <h4>Form State:</h4>
        <pre>{JSON.stringify(formState, null, 2)}</pre>
        
        <h4>Validation Errors:</h4>
        <pre>{JSON.stringify(validation, null, 2)}</pre>
      </div>
    </form>
  );
};
```

## 🚀 Advanced Event Handling Techniques

### 🎯 Event Delegation and Bubbling

```jsx
const EventDelegationDemo = () => {
  const [clickedItem, setClickedItem] = useState('');
  const [eventFlow, setEventFlow] = useState([]);
  
  const handleContainerClick = (event) => {
    const flow = `Container clicked (target: ${event.target.tagName})`;
    setEventFlow(prev => [...prev, flow]);
    
    // Event delegation - handle clicks on child elements
    if (event.target.dataset.item) {
      setClickedItem(event.target.dataset.item);
    }
  };
  
  const handleItemClick = (event) => {
    const flow = `Item clicked: ${event.target.dataset.item}`;
    setEventFlow(prev => [...prev, flow]);
    
    // Stop propagation to prevent container handler
    // event.stopPropagation(); // Uncomment to see the difference
  };
  
  const handleStopPropagation = (event) => {
    event.stopPropagation();
    setEventFlow(prev => [...prev, 'Event stopped!']);
  };
  
  const clearFlow = () => {
    setEventFlow([]);
    setClickedItem('');
  };
  
  return (
    <div className="delegation-demo">
      <h3>Event Delegation & Bubbling Demo</h3>
      
      <div 
        className="item-container"
        onClick={handleContainerClick}
        style={{
          border: '2px solid blue',
          padding: '20px',
          margin: '10px'
        }}
      >
        <p>Container (Click anywhere)</p>
        
        <div 
          className="item"
          data-item="Item 1"
          onClick={handleItemClick}
          style={{
            backgroundColor: 'lightblue',
            padding: '10px',
            margin: '5px',
            cursor: 'pointer'
          }}
        >
          Item 1 (Bubbles)
        </div>
        
        <div 
          className="item"
          data-item="Item 2"
          onClick={handleItemClick}
          style={{
            backgroundColor: 'lightgreen',
            padding: '10px',
            margin: '5px',
            cursor: 'pointer'
          }}
        >
          Item 2 (Bubbles)
        </div>
        
        <div 
          className="item"
          data-item="Item 3"
          onClick={handleStopPropagation}
          style={{
            backgroundColor: 'lightcoral',
            padding: '10px',
            margin: '5px',
            cursor: 'pointer'
          }}
        >
          Item 3 (Stops Propagation)
        </div>
      </div>
      
      <div className="results">
        <p>Last Clicked Item: <strong>{clickedItem}</strong></p>
        
        <div className="event-flow">
          <h4>Event Flow:</h4>
          {eventFlow.map((event, index) => (
            <div key={index} className="flow-item">
              {index + 1}. {event}
            </div>
          ))}
        </div>
        
        <button onClick={clearFlow}>Clear Flow</button>
      </div>
    </div>
  );
};
```

### 🎪 Custom Event Handlers

```jsx
const CustomEventDemo = () => {
  const [touches, setTouches] = useState([]);
  const [dragData, setDragData] = useState({ isDragging: false, position: { x: 0, y: 0 } });
  
  // Custom touch handler
  const handleTouch = (event) => {
    const touch = event.touches[0];
    if (touch) {
      setTouches(prev => [
        ...prev.slice(-4), // Keep last 5 touches
        {
          x: touch.clientX,
          y: touch.clientY,
          timestamp: Date.now()
        }
      ]);
    }
  };
  
  // Custom drag handlers
  const handleDragStart = (event) => {
    setDragData({
      isDragging: true,
      position: { x: event.clientX, y: event.clientY }
    });
  };
  
  const handleDragEnd = () => {
    setDragData(prev => ({ ...prev, isDragging: false }));
  };
  
  // Debounced search handler
  const [searchTerm, setSearchTerm] = useState('');
  const [debouncedSearch, setDebouncedSearch] = useState('');
  
  React.useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearch(searchTerm);
    }, 500);
    
    return () => clearTimeout(timer);
  }, [searchTerm]);
  
  // Throttled scroll handler
  const [scrollPosition, setScrollPosition] = useState(0);
  const scrollRef = React.useRef(null);
  
  React.useEffect(() => {
    let ticking = false;
    
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          if (scrollRef.current) {
            setScrollPosition(scrollRef.current.scrollTop);
          }
          ticking = false;
        });
        ticking = true;
      }
    };
    
    const element = scrollRef.current;
    if (element) {
      element.addEventListener('scroll', handleScroll);
      return () => element.removeEventListener('scroll', handleScroll);
    }
  }, []);
  
  return (
    <div className="custom-events-demo">
      <h3>Custom Event Handlers Demo</h3>
      
      {/* Touch Demo */}
      <div 
        className="touch-area"
        onTouchStart={handleTouch}
        onTouchMove={handleTouch}
        style={{
          width: '100%',
          height: '150px',
          backgroundColor: '#f0f0f0',
          border: '2px dashed #ccc',
          position: 'relative',
          marginBottom: '20px'
        }}
      >
        <p>Touch Area (Mobile)</p>
        {touches.map((touch, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: touch.x - 10,
              top: touch.y - 10,
              width: '20px',
              height: '20px',
              backgroundColor: 'red',
              borderRadius: '50%',
              opacity: 1 - (index * 0.2)
            }}
          />
        ))}
      </div>
      
      {/* Drag Demo */}
      <div
        className="drag-area"
        onMouseDown={handleDragStart}
        onMouseUp={handleDragEnd}
        style={{
          width: '200px',
          height: '100px',
          backgroundColor: dragData.isDragging ? '#ffeb3b' : '#e3f2fd',
          border: '2px solid #2196f3',
          cursor: dragData.isDragging ? 'grabbing' : 'grab',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          marginBottom: '20px'
        }}
      >
        {dragData.isDragging ? 'Dragging!' : 'Drag me'}
      </div>
      
      {/* Debounced Search */}
      <div className="search-demo">
        <input
          type="text"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          placeholder="Debounced search..."
        />
        <p>Search term: {searchTerm}</p>
        <p>Debounced (500ms): {debouncedSearch}</p>
      </div>
      
      {/* Throttled Scroll */}
      <div 
        ref={scrollRef}
        className="scroll-demo"
        style={{
          height: '200px',
          overflow: 'auto',
          border: '1px solid #ccc',
          padding: '10px'
        }}
      >
        <div style={{ height: '800px', background: 'linear-gradient(to bottom, #ff9a9e, #fecfef)' }}>
          <p>Scroll Position: {scrollPosition}px</p>
          <p>This is a long scrollable content...</p>
          {Array.from({ length: 50 }, (_, i) => (
            <p key={i}>Line {i + 1}</p>
          ))}
        </div>
      </div>
    </div>
  );
};
```

Event handling is the cornerstone of interactive React applications. Master these patterns and techniques, and you'll be able to create rich, responsive user experiences that feel natural and intuitive!
  });
  
  // Generic handler for text inputs
  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  // Specific handlers for different input types
  const handleTextChange = (e) => {
    setFormData(prev => ({ ...prev, text: e.target.value }));
  };
  
  const handleEmailChange = (e) => {
    const email = e.target.value.toLowerCase(); // Auto-lowercase
    setFormData(prev => ({ ...prev, email }));
  };
  
  return (
    <form>
      <div>
        <label>Text Input:</label>
        <input
          type="text"
          name="text"
          value={formData.text}
          onChange={handleInputChange}
          placeholder="Type something..."
        />
      </div>
      
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleEmailChange}
          placeholder="your@email.com"
        />
      </div>
      
      <div>
        <label>Password:</label>
        <input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleInputChange}
          placeholder="Password"
        />
      </div>
      
      <div>
        <label>Textarea:</label>
        <textarea
          name="textarea"
          value={formData.textarea}
          onChange={handleInputChange}
          rows={4}
          placeholder="Multi-line text..."
        />
      </div>
      
      <div>
        <label>Select:</label>
        <select
          name="select"
          value={formData.select}
          onChange={handleInputChange}
        >
          <option value="">Choose an option</option>
          <option value="option1">Option 1</option>
          <option value="option2">Option 2</option>
          <option value="option3">Option 3</option>
        </select>
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            name="checkbox"
            checked={formData.checkbox}
            onChange={handleInputChange}
          />
          I agree to terms
        </label>
      </div>
      
      <div>
        <label>Radio Options:</label>
        {['option1', 'option2', 'option3'].map(option => (
          <label key={option}>
            <input
              type="radio"
              name="radio"
              value={option}
              checked={formData.radio === option}
              onChange={handleInputChange}
            />
            {option}
          </label>
        ))}
      </div>
      
      <div>
        <h3>Form Data:</h3>
        <pre>{JSON.stringify(formData, null, 2)}</pre>
      </div>
    </form>
  );
}
```

#### 3. Keyboard Events

```jsx
function KeyboardEventsExample() {
  const [keyInfo, setKeyInfo] = useState('');
  const [inputValue, setInputValue] = useState('');
  const [shortcuts, setShortcuts] = useState([]);
  
  const handleKeyDown = (e) => {
    const { key, code, ctrlKey, shiftKey, altKey } = e;
    
    // Handle keyboard shortcuts
    if (ctrlKey && key === 's') {
      e.preventDefault();
      addShortcut('Ctrl+S (Save)');
      return;
    }
    
    if (ctrlKey && key === 'z') {
      e.preventDefault();
      addShortcut('Ctrl+Z (Undo)');
      return;
    }
    
    if (key === 'Escape') {
      setInputValue('');
      addShortcut('Escape (Clear)');
      return;
    }
    
    // Update key info
    const modifiers = [];
    if (ctrlKey) modifiers.push('Ctrl');
    if (shiftKey) modifiers.push('Shift');
    if (altKey) modifiers.push('Alt');
    
    const modifierString = modifiers.length > 0 ? modifiers.join('+') + '+' : '';
    setKeyInfo(`${modifierString}${key} (code: ${code})`);
  };
  
  const handleKeyUp = () => {
    setKeyInfo('');
  };
  
  const addShortcut = (shortcut) => {
    setShortcuts(prev => [...prev.slice(-4), shortcut]); // Keep last 5
  };
  
  const handleInputKeyPress = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      addShortcut(`Entered: "${e.target.value}"`);
      setInputValue('');
    }
  };
  
  return (
    <div>
      <div>
        <h3>Keyboard Event Demo</h3>
        <p>Try pressing keys, shortcuts (Ctrl+S, Ctrl+Z, Escape), or typing in the input below:</p>
        
        <div
          tabIndex={0}
          onKeyDown={handleKeyDown}
          onKeyUp={handleKeyUp}
          style={{
            padding: '20px',
            border: '2px solid #ccc',
            marginBottom: '10px',
            outline: 'none'
          }}
        >
          Click here and press any key
          {keyInfo && <p><strong>Last key:</strong> {keyInfo}</p>}
        </div>
        
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={handleInputKeyPress}
          placeholder="Type and press Enter"
        />
        
        <div>
          <h4>Recent Actions:</h4>
          <ul>
            {shortcuts.map((shortcut, index) => (
              <li key={index}>{shortcut}</li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
}
```

#### 4. Mouse Events

```jsx
function MouseEventsExample() {
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [mouseEvents, setMouseEvents] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  
  const addEvent = (eventType) => {
    setMouseEvents(prev => 
      [...prev.slice(-4), `${eventType} at ${new Date().toLocaleTimeString()}`]
    );
  };
  
  const handleMouseMove = (e) => {
    setMousePosition({ x: e.clientX, y: e.clientY });
  };
  
  const handleMouseEnter = () => addEvent('Mouse Enter');
  const handleMouseLeave = () => addEvent('Mouse Leave');
  const handleMouseDown = () => {
    setIsDragging(true);
    addEvent('Mouse Down');
  };
  const handleMouseUp = () => {
    setIsDragging(false);
    addEvent('Mouse Up');
  };
  
  return (
    <div>
      <div>
        <p>Mouse Position: X: {mousePosition.x}, Y: {mousePosition.y}</p>
        <p>Dragging: {isDragging ? 'Yes' : 'No'}</p>
      </div>
      
      <div
        onMouseMove={handleMouseMove}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        style={{
          width: '300px',
          height: '200px',
          border: '2px solid #333',
          backgroundColor: isDragging ? '#f0f0f0' : '#fff',
          cursor: isDragging ? 'grabbing' : 'grab',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          userSelect: 'none'
        }}
      >
        Interact with this area
      </div>
      
      <div>
        <h4>Recent Mouse Events:</h4>
        <ul>
          {mouseEvents.map((event, index) => (
            <li key={index}>{event}</li>
          ))}
        </ul>
      </div>
    </div>
  );
}
```

#### 5. Form Submission Events

```jsx
function FormSubmissionExample() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    message: ''
  });
  const [submissions, setSubmissions] = useState([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault(); // Prevent default form submission
    
    setIsSubmitting(true);
    
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      setSubmissions(prev => [...prev, {
        ...formData,
        timestamp: new Date().toLocaleString()
      }]);
      
      // Reset form
      setFormData({ username: '', email: '', message: '' });
      
    } catch (error) {
      console.error('Submission failed:', error);
    } finally {
      setIsSubmitting(false);
    }
  };
  
  const isFormValid = formData.username && formData.email && formData.message;
  
  return (
    <div>
      <form onSubmit={handleSubmit}>
        <div>
          <label>Username:</label>
          <input
            type="text"
            name="username"
            value={formData.username}
            onChange={handleInputChange}
            required
          />
        </div>
        
        <div>
          <label>Email:</label>
          <input
            type="email"
            name="email"
            value={formData.email}
            onChange={handleInputChange}
            required
          />
        </div>
        
        <div>
          <label>Message:</label>
          <textarea
            name="message"
            value={formData.message}
            onChange={handleInputChange}
            rows={4}
            required
          />
        </div>
        
        <button 
          type="submit" 
          disabled={!isFormValid || isSubmitting}
        >
          {isSubmitting ? 'Submitting...' : 'Submit'}
        </button>
      </form>
      
      <div>
        <h3>Submissions:</h3>
        {submissions.map((submission, index) => (
          <div key={index} style={{ border: '1px solid #ccc', padding: '10px', margin: '5px 0' }}>
            <p><strong>Username:</strong> {submission.username}</p>
            <p><strong>Email:</strong> {submission.email}</p>
            <p><strong>Message:</strong> {submission.message}</p>
            <p><strong>Submitted:</strong> {submission.timestamp}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Event Handler Patterns

#### 1. Parameterized Event Handlers

```jsx
function ParameterizedHandlers() {
  const [selectedItems, setSelectedItems] = useState([]);
  const [counters, setCounters] = useState({ a: 0, b: 0, c: 0 });
  
  // Handler that receives additional parameters
  const handleItemSelect = (itemId, isSelected) => {
    setSelectedItems(prev => 
      isSelected 
        ? [...prev, itemId]
        : prev.filter(id => id !== itemId)
    );
  };
  
  // Handler with closure to capture parameter
  const createCounterHandler = (counterId) => {
    return () => {
      setCounters(prev => ({
        ...prev,
        [counterId]: prev[counterId] + 1
      }));
    };
  };
  
  // Handler using data attributes
  const handleButtonClick = (e) => {
    const action = e.target.dataset.action;
    const value = e.target.dataset.value;
    
    console.log(`Action: ${action}, Value: ${value}`);
  };
  
  return (
    <div>
      <h3>Item Selection</h3>
      {['item1', 'item2', 'item3'].map(item => (
        <label key={item}>
          <input
            type="checkbox"
            onChange={(e) => handleItemSelect(item, e.target.checked)}
          />
          {item}
        </label>
      ))}
      <p>Selected: {selectedItems.join(', ')}</p>
      
      <h3>Counters</h3>
      {Object.entries(counters).map(([id, count]) => (
        <div key={id}>
          <button onClick={createCounterHandler(id)}>
            Counter {id.toUpperCase()}: {count}
          </button>
        </div>
      ))}
      
      <h3>Data Attributes</h3>
      <button 
        data-action="save" 
        data-value="document1" 
        onClick={handleButtonClick}
      >
        Save Document
      </button>
      <button 
        data-action="delete" 
        data-value="document1" 
        onClick={handleButtonClick}
      >
        Delete Document
      </button>
    </div>
  );
}
```

#### 2. Debounced Event Handlers

```jsx
import { useState, useCallback } from 'react';

function DebouncedSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  
  // Debounce utility
  const useDebounce = (callback, delay) => {
    const [timeoutId, setTimeoutId] = useState(null);
    
    return useCallback((...args) => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      
      const newTimeoutId = setTimeout(() => {
        callback(...args);
      }, delay);
      
      setTimeoutId(newTimeoutId);
    }, [callback, delay, timeoutId]);
  };
  
  // Search function
  const performSearch = async (searchQuery) => {
    if (!searchQuery.trim()) {
      setResults([]);
      return;
    }
    
    setIsSearching(true);
    
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Mock search results
      const mockResults = [
        `Result 1 for "${searchQuery}"`,
        `Result 2 for "${searchQuery}"`,
        `Result 3 for "${searchQuery}"`
      ];
      
      setResults(mockResults);
    } catch (error) {
      console.error('Search failed:', error);
    } finally {
      setIsSearching(false);
    }
  };
  
  // Debounced search
  const debouncedSearch = useDebounce(performSearch, 300);
  
  const handleInputChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };
  
  return (
    <div>
      <h3>Debounced Search</h3>
      <input
        type="text"
        value={query}
        onChange={handleInputChange}
        placeholder="Type to search..."
      />
      
      {isSearching && <p>Searching...</p>}
      
      <ul>
        {results.map((result, index) => (
          <li key={index}>{result}</li>
        ))}
      </ul>
    </div>
  );
}
```

## 4.2 Typing Events in TypeScript

TypeScript provides excellent type safety for React events through synthetic event types. This gives you autocompletion, type checking, and better developer experience.

### Common Event Types

#### 1. React.MouseEvent

```tsx
import React from 'react';

interface ButtonProps {
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  children: React.ReactNode;
}

function TypedButton({ onClick, children }: ButtonProps) {
  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    // Full type safety and autocompletion
    console.log('Button clicked:', event.currentTarget.textContent);
    console.log('Mouse position:', event.clientX, event.clientY);
    console.log('Modifier keys:', {
      ctrl: event.ctrlKey,
      shift: event.shiftKey,
      alt: event.altKey
    });
    
    onClick?.(event);
  };
  
  return (
    <button onClick={handleClick}>
      {children}
    </button>
  );
}

// Usage with different elements
function MouseEventExamples() {
  const handleDivClick = (event: React.MouseEvent<HTMLDivElement>) => {
    console.log('Div clicked:', event.target);
  };
  
  const handleImageClick = (event: React.MouseEvent<HTMLImageElement>) => {
    console.log('Image clicked:', event.currentTarget.src);
  };
  
  return (
    <div>
      <TypedButton onClick={(e) => console.log('Typed button clicked')}>
        Click me
      </TypedButton>
      
      <div onClick={handleDivClick} style={{ padding: '20px', border: '1px solid #ccc' }}>
        Clickable div
      </div>
      
      <img 
        src="/example.jpg" 
        alt="Example" 
        onClick={handleImageClick}
        style={{ cursor: 'pointer' }}
      />
    </div>
  );
}
```

#### 2. React.ChangeEvent

```tsx
interface FormData {
  username: string;
  email: string;
  age: number;
  bio: string;
  country: string;
  newsletter: boolean;
}

function TypedForm() {
  const [formData, setFormData] = React.useState<FormData>({
    username: '',
    email: '',
    age: 0,
    bio: '',
    country: '',
    newsletter: false
  });
  
  // Text input handler
  const handleTextInput = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Number input handler
  const handleNumberInput = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: parseInt(value) || 0
    }));
  };
  
  // Checkbox handler
  const handleCheckbox = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: checked
    }));
  };
  
  // Textarea handler
  const handleTextarea = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Select handler
  const handleSelect = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Generic handler (loses some type safety)
  const handleChange = (
    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = event.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' 
        ? (event.target as HTMLInputElement).checked
        : type === 'number' 
          ? parseInt(value) || 0
          : value
    }));
  };
  
  return (
    <form>
      <div>
        <label>Username:</label>
        <input
          type="text"
          name="username"
          value={formData.username}
          onChange={handleTextInput}
        />
      </div>
      
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleTextInput}
        />
      </div>
      
      <div>
        <label>Age:</label>
        <input
          type="number"
          name="age"
          value={formData.age}
          onChange={handleNumberInput}
        />
      </div>
      
      <div>
        <label>Bio:</label>
        <textarea
          name="bio"
          value={formData.bio}
          onChange={handleTextarea}
          rows={4}
        />
      </div>
      
      <div>
        <label>Country:</label>
        <select
          name="country"
          value={formData.country}
          onChange={handleSelect}
        >
          <option value="">Select a country</option>
          <option value="us">United States</option>
          <option value="uk">United Kingdom</option>
          <option value="ca">Canada</option>
        </select>
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            name="newsletter"
            checked={formData.newsletter}
            onChange={handleCheckbox}
          />
          Subscribe to newsletter
        </label>
      </div>
    </form>
  );
}
```

#### 3. React.FormEvent

```tsx
interface LoginFormData {
  username: string;
  password: string;
}

interface FormErrors {
  username?: string;
  password?: string;
  general?: string;
}

function LoginForm() {
  const [formData, setFormData] = React.useState<LoginFormData>({
    username: '',
    password: ''
  });
  
  const [errors, setErrors] = React.useState<FormErrors>({});
  const [isSubmitting, setIsSubmitting] = React.useState(false);
  
  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Clear error when user starts typing
    if (errors[name as keyof FormErrors]) {
      setErrors(prev => ({
        ...prev,
        [name]: undefined
      }));
    }
  };
  
  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};
    
    if (!formData.username.trim()) {
      newErrors.username = 'Username is required';
    } else if (formData.username.length < 3) {
      newErrors.username = 'Username must be at least 3 characters';
    }
    
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault(); // Prevent default form submission
    
    if (!validateForm()) {
      return;
    }
    
    setIsSubmitting(true);
    setErrors({});
    
    try {
      // Simulate API call
      await new Promise((resolve, reject) => {
        setTimeout(() => {
          if (formData.username === 'admin' && formData.password === 'password123') {
            resolve('Success');
          } else {
            reject(new Error('Invalid credentials'));
          }
        }, 1000);
      });
      
      console.log('Login successful!');
      // Handle successful login
      
    } catch (error) {
      setErrors({
        general: error instanceof Error ? error.message : 'Login failed'
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  const handleReset = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setFormData({ username: '', password: '' });
    setErrors({});
  };
  
  return (
    <div>
      <form onSubmit={handleSubmit} onReset={handleReset}>
        <h2>Login</h2>
        
        {errors.general && (
          <div style={{ color: 'red', marginBottom: '10px' }}>
            {errors.general}
          </div>
        )}
        
        <div>
          <label>Username:</label>
          <input
            type="text"
            name="username"
            value={formData.username}
            onChange={handleInputChange}
            disabled={isSubmitting}
          />
          {errors.username && (
            <span style={{ color: 'red' }}>{errors.username}</span>
          )}
        </div>
        
        <div>
          <label>Password:</label>
          <input
            type="password"
            name="password"
            value={formData.password}
            onChange={handleInputChange}
            disabled={isSubmitting}
          />
          {errors.password && (
            <span style={{ color: 'red' }}>{errors.password}</span>
          )}
        </div>
        
        <div>
          <button type="submit" disabled={isSubmitting}>
            {isSubmitting ? 'Logging in...' : 'Login'}
          </button>
          <button type="reset" disabled={isSubmitting}>
            Reset
          </button>
        </div>
      </form>
      
      <div style={{ marginTop: '20px', fontSize: '12px', color: '#666' }}>
        <p>Try: username "admin", password "password123"</p>
      </div>
    </div>
  );
}
```

### Advanced Event Typing

#### 1. Keyboard Events

```tsx
function KeyboardEventExample() {
  const [pressedKeys, setPressedKeys] = React.useState<string[]>([]);
  
  const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {
    const { key, code, ctrlKey, shiftKey, altKey, metaKey } = event;
    
    // Handle specific key combinations
    if (ctrlKey && key === 's') {
      event.preventDefault();
      console.log('Save shortcut detected');
      return;
    }
    
    if (key === 'Escape') {
      setPressedKeys([]);
      return;
    }
    
    // Add key to pressed keys
    setPressedKeys(prev => [...prev.slice(-4), key]);
    
    console.log({
      key,           // 'a', 'Enter', 'ArrowUp', etc.
      code,          // 'KeyA', 'Enter', 'ArrowUp', etc.
      ctrlKey,       // boolean
      shiftKey,      // boolean
      altKey,        // boolean
      metaKey        // boolean (Cmd on Mac, Win on Windows)
    });
  };
  
  const handleKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {
    // KeyPress is deprecated, but still useful for character input
    console.log('Character pressed:', event.key);
  };
  
  return (
    <div>
      <div
        tabIndex={0}
        onKeyDown={handleKeyDown}
        style={{ 
          padding: '20px', 
          border: '2px solid #ccc',
          outline: 'none'
        }}
      >
        Click here and press keys (try Ctrl+S, Escape)
      </div>
      
      <input
        type="text"
        onKeyPress={handleKeyPress}
        placeholder="Type here for keypress events"
      />
      
      <p>Recent keys: {pressedKeys.join(', ')}</p>
    </div>
  );
}
```

#### 2. Focus Events

```tsx
function FocusEventExample() {
  const [focusState, setFocusState] = React.useState<{
    activeElement: string;
    focusHistory: string[];
  }>({
    activeElement: '',
    focusHistory: []
  });
  
  const handleFocus = (event: React.FocusEvent<HTMLInputElement>) => {
    const elementName = event.target.name || event.target.placeholder;
    setFocusState(prev => ({
      activeElement: elementName,
      focusHistory: [...prev.focusHistory.slice(-4), `Focused: ${elementName}`]
    }));
  };
  
  const handleBlur = (event: React.FocusEvent<HTMLInputElement>) => {
    const elementName = event.target.name || event.target.placeholder;
    setFocusState(prev => ({
      activeElement: '',
      focusHistory: [...prev.focusHistory.slice(-4), `Blurred: ${elementName}`]
    }));
  };
  
  return (
    <div>
      <h3>Focus Events</h3>
      <p>Active element: {focusState.activeElement || 'None'}</p>
      
      <input
        name="firstName"
        placeholder="First Name"
        onFocus={handleFocus}
        onBlur={handleBlur}
      />
      
      <input
        name="lastName"
        placeholder="Last Name"
        onFocus={handleFocus}
        onBlur={handleBlur}
      />
      
      <input
        name="email"
        placeholder="Email"
        onFocus={handleFocus}
        onBlur={handleBlur}
      />
      
      <div>
        <h4>Focus History:</h4>
        <ul>
          {focusState.focusHistory.map((event, index) => (
            <li key={index}>{event}</li>
          ))}
        </ul>
      </div>
    </div>
  );
}
```

#### 3. Custom Event Handlers with Generic Types

```tsx
// Generic event handler type
type EventHandler<T extends HTMLElement, E extends React.SyntheticEvent<T>> = (event: E) => void;

// Specific handler types
type ButtonClickHandler = EventHandler<HTMLButtonElement, React.MouseEvent<HTMLButtonElement>>;
type InputChangeHandler = EventHandler<HTMLInputElement, React.ChangeEvent<HTMLInputElement>>;
type FormSubmitHandler = EventHandler<HTMLFormElement, React.FormEvent<HTMLFormElement>>;

interface CustomButtonProps {
  onClick?: ButtonClickHandler;
  disabled?: boolean;
  children: React.ReactNode;
}

function CustomButton({ onClick, disabled, children }: CustomButtonProps) {
  const handleClick: ButtonClickHandler = (event) => {
    if (disabled) return;
    
    // Add custom behavior
    console.log('Button clicked:', event.currentTarget.textContent);
    onClick?.(event);
  };
  
  return (
    <button onClick={handleClick} disabled={disabled}>
      {children}
    </button>
  );
}

// Higher-order event handler
function withLogging<T extends HTMLElement, E extends React.SyntheticEvent<T>>(
  handler: EventHandler<T, E>,
  eventName: string
): EventHandler<T, E> {
  return (event) => {
    console.log(`${eventName} event:`, event);
    handler(event);
  };
}

// Usage
function EventHandlerExample() {
  const handleButtonClick: ButtonClickHandler = (event) => {
    alert(`Button "${event.currentTarget.textContent}" was clicked!`);
  };
  
  const handleInputChange: InputChangeHandler = (event) => {
    console.log('Input changed:', event.target.value);
  };
  
  // Wrapped with logging
  const loggedButtonClick = withLogging(handleButtonClick, 'Button Click');
  const loggedInputChange = withLogging(handleInputChange, 'Input Change');
  
  return (
    <div>
      <CustomButton onClick={loggedButtonClick}>
        Click me
      </CustomButton>
      
      <input onChange={loggedInputChange} placeholder="Type something" />
    </div>
  );
}
```

### Event Delegation and Performance

```tsx
// Efficient event handling for lists
function OptimizedList() {
  const [items, setItems] = React.useState([
    { id: 1, name: 'Item 1', completed: false },
    { id: 2, name: 'Item 2', completed: false },
    { id: 3, name: 'Item 3', completed: false }
  ]);
  
  // Single event handler for all list actions
  const handleListClick = (event: React.MouseEvent<HTMLUListElement>) => {
    const target = event.target as HTMLElement;
    const listItem = target.closest('li');
    
    if (!listItem) return;
    
    const itemId = parseInt(listItem.dataset.itemId || '0');
    const action = target.dataset.action;
    
    switch (action) {
      case 'toggle':
        setItems(prev => prev.map(item =>
          item.id === itemId ? { ...item, completed: !item.completed } : item
        ));
        break;
        
      case 'delete':
        setItems(prev => prev.filter(item => item.id !== itemId));
        break;
        
      case 'edit':
        const newName = prompt('Enter new name:', listItem.textContent?.trim());
        if (newName) {
          setItems(prev => prev.map(item =>
            item.id === itemId ? { ...item, name: newName } : item
          ));
        }
        break;
    }
  };
  
  return (
    <div>
      <h3>Optimized List (Event Delegation)</h3>
      <ul onClick={handleListClick}>
        {items.map(item => (
          <li key={item.id} data-item-id={item.id}>
            <span style={{ textDecoration: item.completed ? 'line-through' : 'none' }}>
              {item.name}
            </span>
            <button data-action="toggle">
              {item.completed ? 'Undo' : 'Complete'}
            </button>
            <button data-action="edit">Edit</button>
            <button data-action="delete">Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## Common Event Handling Patterns

### 1. Controlled vs Uncontrolled Components

```tsx
// Controlled component (React manages the state)
function ControlledInput() {
  const [value, setValue] = React.useState('');
  
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setValue(event.target.value);
  };
  
  return (
    <div>
      <input value={value} onChange={handleChange} />
      <p>Value: {value}</p>
    </div>
  );
}

// Uncontrolled component (DOM manages the state)
function UncontrolledInput() {
  const inputRef = React.useRef<HTMLInputElement>(null);
  
  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    if (inputRef.current) {
      alert(`Value: ${inputRef.current.value}`);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} defaultValue="Initial value" />
      <button type="submit">Get Value</button>
    </form>
  );
}
```

### 2. Event Prevention and Propagation

```tsx
function EventPropagationExample() {
  const handleOuterClick = () => console.log('Outer clicked');
  const handleMiddleClick = () => console.log('Middle clicked');
  const handleInnerClick = (event: React.MouseEvent) => {
    console.log('Inner clicked');
    event.stopPropagation(); // Prevents bubbling to parent elements
  };
  
  const handleLinkClick = (event: React.MouseEvent<HTMLAnchorElement>) => {
    event.preventDefault(); // Prevents default link behavior
    console.log('Link clicked but navigation prevented');
  };
  
  const handleFormSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault(); // Prevents form submission
    console.log('Form submission prevented');
  };
  
  return (
    <div onClick={handleOuterClick} style={{ padding: '20px', border: '1px solid red' }}>
      Outer
      <div onClick={handleMiddleClick} style={{ padding: '20px', border: '1px solid blue' }}>
        Middle
        <div onClick={handleInnerClick} style={{ padding: '20px', border: '1px solid green' }}>
          Inner (click won't bubble)
        </div>
      </div>
      
      <a href="https://example.com" onClick={handleLinkClick}>
        Prevented Link
      </a>
      
      <form onSubmit={handleFormSubmit}>
        <button type="submit">Prevented Submit</button>
      </form>
    </div>
  );
}
```

## Summary

Event handling is crucial for creating interactive React applications:

### Key Takeaways:

1. **Event Handlers**: Functions that respond to user interactions
2. **Synthetic Events**: React's cross-browser event wrapper
3. **TypeScript Integration**: Use specific event types for type safety
4. **Performance**: Consider event delegation for large lists
5. **Controlled Components**: React manages form state for better control

### Common Event Types:
- **React.MouseEvent**: Click, mouse move, enter, leave
- **React.ChangeEvent**: Form input changes  
- **React.FormEvent**: Form submission
- **React.KeyboardEvent**: Key presses and releases
- **React.FocusEvent**: Focus and blur events

### Best Practices:
- ✅ Use TypeScript for type safety
- ✅ Prevent default behavior when needed
- ✅ Use functional updates for state changes
- ✅ Consider performance for frequent events
- ✅ Handle errors gracefully
- ✅ Use event delegation for lists

### TypeScript Benefits:
- **Autocomplete**: IntelliSense for event properties
- **Type Safety**: Catch errors at compile time
- **Documentation**: Self-documenting event handlers
- **Refactoring**: Safe code changes

**Next Steps**: Learn about `useEffect` for side effects, custom hooks for reusable logic, and advanced state management patterns!