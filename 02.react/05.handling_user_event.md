# React Event Handling: Responding to User Interactions

## 4.1 Event Handlers

Event handlers are functions that respond to user interactions like clicks, form submissions, keyboard input, and mouse movements. They're the bridge between user actions and your component's state changes.

### Understanding React Events

React uses **Synthetic Events** - a wrapper around native DOM events that provides:
- **Cross-browser compatibility**: Same API across all browsers
- **Consistent behavior**: Normalized event properties
- **Performance optimizations**: Event pooling and delegation
- **React-specific features**: Integration with React's update cycle

### Basic Event Handler Syntax

```jsx
function BasicEventExample() {
  const [message, setMessage] = useState('');
  
  // Event handler function
  const handleClick = () => {
    setMessage('Button was clicked!');
  };
  
  // Inline event handler
  const handleReset = () => setMessage('');
  
  return (
    <div>
      <p>{message}</p>
      <button onClick={handleClick}>Click Me</button>
      <button onClick={handleReset}>Reset</button>
      
      {/* Inline anonymous function (not recommended for complex logic) */}
      <button onClick={() => setMessage('Inline click!')}>
        Inline Handler
      </button>
    </div>
  );
}
```

### Common Event Types

#### 1. Click Events

```jsx
function ClickEventsExample() {
  const [clickCount, setClickCount] = useState(0);
  const [lastClickType, setLastClickType] = useState('');
  
  const handleLeftClick = () => {
    setClickCount(prev => prev + 1);
    setLastClickType('Left click');
  };
  
  const handleRightClick = (e) => {
    e.preventDefault(); // Prevent context menu
    setLastClickType('Right click');
  };
  
  const handleDoubleClick = () => {
    setLastClickType('Double click');
  };
  
  return (
    <div>
      <div 
        onClick={handleLeftClick}
        onContextMenu={handleRightClick}
        onDoubleClick={handleDoubleClick}
        style={{
          padding: '20px',
          border: '2px solid #ccc',
          cursor: 'pointer',
          userSelect: 'none'
        }}
      >
        Click me with different mouse buttons or double-click!
      </div>
      <p>Click count: {clickCount}</p>
      <p>Last action: {lastClickType}</p>
    </div>
  );
}
```

#### 2. Form Input Events

```jsx
function InputEventsExample() {
  const [formData, setFormData] = useState({
    text: '',
    email: '',
    password: '',
    textarea: '',
    select: '',
    checkbox: false,
    radio: ''
  });
  
  // Generic handler for text inputs
  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  // Specific handlers for different input types
  const handleTextChange = (e) => {
    setFormData(prev => ({ ...prev, text: e.target.value }));
  };
  
  const handleEmailChange = (e) => {
    const email = e.target.value.toLowerCase(); // Auto-lowercase
    setFormData(prev => ({ ...prev, email }));
  };
  
  return (
    <form>
      <div>
        <label>Text Input:</label>
        <input
          type="text"
          name="text"
          value={formData.text}
          onChange={handleInputChange}
          placeholder="Type something..."
        />
      </div>
      
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleEmailChange}
          placeholder="your@email.com"
        />
      </div>
      
      <div>
        <label>Password:</label>
        <input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleInputChange}
          placeholder="Password"
        />
      </div>
      
      <div>
        <label>Textarea:</label>
        <textarea
          name="textarea"
          value={formData.textarea}
          onChange={handleInputChange}
          rows={4}
          placeholder="Multi-line text..."
        />
      </div>
      
      <div>
        <label>Select:</label>
        <select
          name="select"
          value={formData.select}
          onChange={handleInputChange}
        >
          <option value="">Choose an option</option>
          <option value="option1">Option 1</option>
          <option value="option2">Option 2</option>
          <option value="option3">Option 3</option>
        </select>
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            name="checkbox"
            checked={formData.checkbox}
            onChange={handleInputChange}
          />
          I agree to terms
        </label>
      </div>
      
      <div>
        <label>Radio Options:</label>
        {['option1', 'option2', 'option3'].map(option => (
          <label key={option}>
            <input
              type="radio"
              name="radio"
              value={option}
              checked={formData.radio === option}
              onChange={handleInputChange}
            />
            {option}
          </label>
        ))}
      </div>
      
      <div>
        <h3>Form Data:</h3>
        <pre>{JSON.stringify(formData, null, 2)}</pre>
      </div>
    </form>
  );
}
```

#### 3. Keyboard Events

```jsx
function KeyboardEventsExample() {
  const [keyInfo, setKeyInfo] = useState('');
  const [inputValue, setInputValue] = useState('');
  const [shortcuts, setShortcuts] = useState([]);
  
  const handleKeyDown = (e) => {
    const { key, code, ctrlKey, shiftKey, altKey } = e;
    
    // Handle keyboard shortcuts
    if (ctrlKey && key === 's') {
      e.preventDefault();
      addShortcut('Ctrl+S (Save)');
      return;
    }
    
    if (ctrlKey && key === 'z') {
      e.preventDefault();
      addShortcut('Ctrl+Z (Undo)');
      return;
    }
    
    if (key === 'Escape') {
      setInputValue('');
      addShortcut('Escape (Clear)');
      return;
    }
    
    // Update key info
    const modifiers = [];
    if (ctrlKey) modifiers.push('Ctrl');
    if (shiftKey) modifiers.push('Shift');
    if (altKey) modifiers.push('Alt');
    
    const modifierString = modifiers.length > 0 ? modifiers.join('+') + '+' : '';
    setKeyInfo(`${modifierString}${key} (code: ${code})`);
  };
  
  const handleKeyUp = () => {
    setKeyInfo('');
  };
  
  const addShortcut = (shortcut) => {
    setShortcuts(prev => [...prev.slice(-4), shortcut]); // Keep last 5
  };
  
  const handleInputKeyPress = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      addShortcut(`Entered: "${e.target.value}"`);
      setInputValue('');
    }
  };
  
  return (
    <div>
      <div>
        <h3>Keyboard Event Demo</h3>
        <p>Try pressing keys, shortcuts (Ctrl+S, Ctrl+Z, Escape), or typing in the input below:</p>
        
        <div
          tabIndex={0}
          onKeyDown={handleKeyDown}
          onKeyUp={handleKeyUp}
          style={{
            padding: '20px',
            border: '2px solid #ccc',
            marginBottom: '10px',
            outline: 'none'
          }}
        >
          Click here and press any key
          {keyInfo && <p><strong>Last key:</strong> {keyInfo}</p>}
        </div>
        
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={handleInputKeyPress}
          placeholder="Type and press Enter"
        />
        
        <div>
          <h4>Recent Actions:</h4>
          <ul>
            {shortcuts.map((shortcut, index) => (
              <li key={index}>{shortcut}</li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
}
```

#### 4. Mouse Events

```jsx
function MouseEventsExample() {
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [mouseEvents, setMouseEvents] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  
  const addEvent = (eventType) => {
    setMouseEvents(prev => 
      [...prev.slice(-4), `${eventType} at ${new Date().toLocaleTimeString()}`]
    );
  };
  
  const handleMouseMove = (e) => {
    setMousePosition({ x: e.clientX, y: e.clientY });
  };
  
  const handleMouseEnter = () => addEvent('Mouse Enter');
  const handleMouseLeave = () => addEvent('Mouse Leave');
  const handleMouseDown = () => {
    setIsDragging(true);
    addEvent('Mouse Down');
  };
  const handleMouseUp = () => {
    setIsDragging(false);
    addEvent('Mouse Up');
  };
  
  return (
    <div>
      <div>
        <p>Mouse Position: X: {mousePosition.x}, Y: {mousePosition.y}</p>
        <p>Dragging: {isDragging ? 'Yes' : 'No'}</p>
      </div>
      
      <div
        onMouseMove={handleMouseMove}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        style={{
          width: '300px',
          height: '200px',
          border: '2px solid #333',
          backgroundColor: isDragging ? '#f0f0f0' : '#fff',
          cursor: isDragging ? 'grabbing' : 'grab',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          userSelect: 'none'
        }}
      >
        Interact with this area
      </div>
      
      <div>
        <h4>Recent Mouse Events:</h4>
        <ul>
          {mouseEvents.map((event, index) => (
            <li key={index}>{event}</li>
          ))}
        </ul>
      </div>
    </div>
  );
}
```

#### 5. Form Submission Events

```jsx
function FormSubmissionExample() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    message: ''
  });
  const [submissions, setSubmissions] = useState([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault(); // Prevent default form submission
    
    setIsSubmitting(true);
    
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      setSubmissions(prev => [...prev, {
        ...formData,
        timestamp: new Date().toLocaleString()
      }]);
      
      // Reset form
      setFormData({ username: '', email: '', message: '' });
      
    } catch (error) {
      console.error('Submission failed:', error);
    } finally {
      setIsSubmitting(false);
    }
  };
  
  const isFormValid = formData.username && formData.email && formData.message;
  
  return (
    <div>
      <form onSubmit={handleSubmit}>
        <div>
          <label>Username:</label>
          <input
            type="text"
            name="username"
            value={formData.username}
            onChange={handleInputChange}
            required
          />
        </div>
        
        <div>
          <label>Email:</label>
          <input
            type="email"
            name="email"
            value={formData.email}
            onChange={handleInputChange}
            required
          />
        </div>
        
        <div>
          <label>Message:</label>
          <textarea
            name="message"
            value={formData.message}
            onChange={handleInputChange}
            rows={4}
            required
          />
        </div>
        
        <button 
          type="submit" 
          disabled={!isFormValid || isSubmitting}
        >
          {isSubmitting ? 'Submitting...' : 'Submit'}
        </button>
      </form>
      
      <div>
        <h3>Submissions:</h3>
        {submissions.map((submission, index) => (
          <div key={index} style={{ border: '1px solid #ccc', padding: '10px', margin: '5px 0' }}>
            <p><strong>Username:</strong> {submission.username}</p>
            <p><strong>Email:</strong> {submission.email}</p>
            <p><strong>Message:</strong> {submission.message}</p>
            <p><strong>Submitted:</strong> {submission.timestamp}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Event Handler Patterns

#### 1. Parameterized Event Handlers

```jsx
function ParameterizedHandlers() {
  const [selectedItems, setSelectedItems] = useState([]);
  const [counters, setCounters] = useState({ a: 0, b: 0, c: 0 });
  
  // Handler that receives additional parameters
  const handleItemSelect = (itemId, isSelected) => {
    setSelectedItems(prev => 
      isSelected 
        ? [...prev, itemId]
        : prev.filter(id => id !== itemId)
    );
  };
  
  // Handler with closure to capture parameter
  const createCounterHandler = (counterId) => {
    return () => {
      setCounters(prev => ({
        ...prev,
        [counterId]: prev[counterId] + 1
      }));
    };
  };
  
  // Handler using data attributes
  const handleButtonClick = (e) => {
    const action = e.target.dataset.action;
    const value = e.target.dataset.value;
    
    console.log(`Action: ${action}, Value: ${value}`);
  };
  
  return (
    <div>
      <h3>Item Selection</h3>
      {['item1', 'item2', 'item3'].map(item => (
        <label key={item}>
          <input
            type="checkbox"
            onChange={(e) => handleItemSelect(item, e.target.checked)}
          />
          {item}
        </label>
      ))}
      <p>Selected: {selectedItems.join(', ')}</p>
      
      <h3>Counters</h3>
      {Object.entries(counters).map(([id, count]) => (
        <div key={id}>
          <button onClick={createCounterHandler(id)}>
            Counter {id.toUpperCase()}: {count}
          </button>
        </div>
      ))}
      
      <h3>Data Attributes</h3>
      <button 
        data-action="save" 
        data-value="document1" 
        onClick={handleButtonClick}
      >
        Save Document
      </button>
      <button 
        data-action="delete" 
        data-value="document1" 
        onClick={handleButtonClick}
      >
        Delete Document
      </button>
    </div>
  );
}
```

#### 2. Debounced Event Handlers

```jsx
import { useState, useCallback } from 'react';

function DebouncedSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  
  // Debounce utility
  const useDebounce = (callback, delay) => {
    const [timeoutId, setTimeoutId] = useState(null);
    
    return useCallback((...args) => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      
      const newTimeoutId = setTimeout(() => {
        callback(...args);
      }, delay);
      
      setTimeoutId(newTimeoutId);
    }, [callback, delay, timeoutId]);
  };
  
  // Search function
  const performSearch = async (searchQuery) => {
    if (!searchQuery.trim()) {
      setResults([]);
      return;
    }
    
    setIsSearching(true);
    
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Mock search results
      const mockResults = [
        `Result 1 for "${searchQuery}"`,
        `Result 2 for "${searchQuery}"`,
        `Result 3 for "${searchQuery}"`
      ];
      
      setResults(mockResults);
    } catch (error) {
      console.error('Search failed:', error);
    } finally {
      setIsSearching(false);
    }
  };
  
  // Debounced search
  const debouncedSearch = useDebounce(performSearch, 300);
  
  const handleInputChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };
  
  return (
    <div>
      <h3>Debounced Search</h3>
      <input
        type="text"
        value={query}
        onChange={handleInputChange}
        placeholder="Type to search..."
      />
      
      {isSearching && <p>Searching...</p>}
      
      <ul>
        {results.map((result, index) => (
          <li key={index}>{result}</li>
        ))}
      </ul>
    </div>
  );
}
```

## 4.2 Typing Events in TypeScript

TypeScript provides excellent type safety for React events through synthetic event types. This gives you autocompletion, type checking, and better developer experience.

### Common Event Types

#### 1. React.MouseEvent

```tsx
import React from 'react';

interface ButtonProps {
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  children: React.ReactNode;
}

function TypedButton({ onClick, children }: ButtonProps) {
  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    // Full type safety and autocompletion
    console.log('Button clicked:', event.currentTarget.textContent);
    console.log('Mouse position:', event.clientX, event.clientY);
    console.log('Modifier keys:', {
      ctrl: event.ctrlKey,
      shift: event.shiftKey,
      alt: event.altKey
    });
    
    onClick?.(event);
  };
  
  return (
    <button onClick={handleClick}>
      {children}
    </button>
  );
}

// Usage with different elements
function MouseEventExamples() {
  const handleDivClick = (event: React.MouseEvent<HTMLDivElement>) => {
    console.log('Div clicked:', event.target);
  };
  
  const handleImageClick = (event: React.MouseEvent<HTMLImageElement>) => {
    console.log('Image clicked:', event.currentTarget.src);
  };
  
  return (
    <div>
      <TypedButton onClick={(e) => console.log('Typed button clicked')}>
        Click me
      </TypedButton>
      
      <div onClick={handleDivClick} style={{ padding: '20px', border: '1px solid #ccc' }}>
        Clickable div
      </div>
      
      <img 
        src="/example.jpg" 
        alt="Example" 
        onClick={handleImageClick}
        style={{ cursor: 'pointer' }}
      />
    </div>
  );
}
```

#### 2. React.ChangeEvent

```tsx
interface FormData {
  username: string;
  email: string;
  age: number;
  bio: string;
  country: string;
  newsletter: boolean;
}

function TypedForm() {
  const [formData, setFormData] = React.useState<FormData>({
    username: '',
    email: '',
    age: 0,
    bio: '',
    country: '',
    newsletter: false
  });
  
  // Text input handler
  const handleTextInput = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Number input handler
  const handleNumberInput = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: parseInt(value) || 0
    }));
  };
  
  // Checkbox handler
  const handleCheckbox = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: checked
    }));
  };
  
  // Textarea handler
  const handleTextarea = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Select handler
  const handleSelect = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  // Generic handler (loses some type safety)
  const handleChange = (
    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = event.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' 
        ? (event.target as HTMLInputElement).checked
        : type === 'number' 
          ? parseInt(value) || 0
          : value
    }));
  };
  
  return (
    <form>
      <div>
        <label>Username:</label>
        <input
          type="text"
          name="username"
          value={formData.username}
          onChange={handleTextInput}
        />
      </div>
      
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleTextInput}
        />
      </div>
      
      <div>
        <label>Age:</label>
        <input
          type="number"
          name="age"
          value={formData.age}
          onChange={handleNumberInput}
        />
      </div>
      
      <div>
        <label>Bio:</label>
        <textarea
          name="bio"
          value={formData.bio}
          onChange={handleTextarea}
          rows={4}
        />
      </div>
      
      <div>
        <label>Country:</label>
        <select
          name="country"
          value={formData.country}
          onChange={handleSelect}
        >
          <option value="">Select a country</option>
          <option value="us">United States</option>
          <option value="uk">United Kingdom</option>
          <option value="ca">Canada</option>
        </select>
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            name="newsletter"
            checked={formData.newsletter}
            onChange={handleCheckbox}
          />
          Subscribe to newsletter
        </label>
      </div>
    </form>
  );
}
```

#### 3. React.FormEvent

```tsx
interface LoginFormData {
  username: string;
  password: string;
}

interface FormErrors {
  username?: string;
  password?: string;
  general?: string;
}

function LoginForm() {
  const [formData, setFormData] = React.useState<LoginFormData>({
    username: '',
    password: ''
  });
  
  const [errors, setErrors] = React.useState<FormErrors>({});
  const [isSubmitting, setIsSubmitting] = React.useState(false);
  
  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = event.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Clear error when user starts typing
    if (errors[name as keyof FormErrors]) {
      setErrors(prev => ({
        ...prev,
        [name]: undefined
      }));
    }
  };
  
  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};
    
    if (!formData.username.trim()) {
      newErrors.username = 'Username is required';
    } else if (formData.username.length < 3) {
      newErrors.username = 'Username must be at least 3 characters';
    }
    
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault(); // Prevent default form submission
    
    if (!validateForm()) {
      return;
    }
    
    setIsSubmitting(true);
    setErrors({});
    
    try {
      // Simulate API call
      await new Promise((resolve, reject) => {
        setTimeout(() => {
          if (formData.username === 'admin' && formData.password === 'password123') {
            resolve('Success');
          } else {
            reject(new Error('Invalid credentials'));
          }
        }, 1000);
      });
      
      console.log('Login successful!');
      // Handle successful login
      
    } catch (error) {
      setErrors({
        general: error instanceof Error ? error.message : 'Login failed'
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  const handleReset = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setFormData({ username: '', password: '' });
    setErrors({});
  };
  
  return (
    <div>
      <form onSubmit={handleSubmit} onReset={handleReset}>
        <h2>Login</h2>
        
        {errors.general && (
          <div style={{ color: 'red', marginBottom: '10px' }}>
            {errors.general}
          </div>
        )}
        
        <div>
          <label>Username:</label>
          <input
            type="text"
            name="username"
            value={formData.username}
            onChange={handleInputChange}
            disabled={isSubmitting}
          />
          {errors.username && (
            <span style={{ color: 'red' }}>{errors.username}</span>
          )}
        </div>
        
        <div>
          <label>Password:</label>
          <input
            type="password"
            name="password"
            value={formData.password}
            onChange={handleInputChange}
            disabled={isSubmitting}
          />
          {errors.password && (
            <span style={{ color: 'red' }}>{errors.password}</span>
          )}
        </div>
        
        <div>
          <button type="submit" disabled={isSubmitting}>
            {isSubmitting ? 'Logging in...' : 'Login'}
          </button>
          <button type="reset" disabled={isSubmitting}>
            Reset
          </button>
        </div>
      </form>
      
      <div style={{ marginTop: '20px', fontSize: '12px', color: '#666' }}>
        <p>Try: username "admin", password "password123"</p>
      </div>
    </div>
  );
}
```

### Advanced Event Typing

#### 1. Keyboard Events

```tsx
function KeyboardEventExample() {
  const [pressedKeys, setPressedKeys] = React.useState<string[]>([]);
  
  const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {
    const { key, code, ctrlKey, shiftKey, altKey, metaKey } = event;
    
    // Handle specific key combinations
    if (ctrlKey && key === 's') {
      event.preventDefault();
      console.log('Save shortcut detected');
      return;
    }
    
    if (key === 'Escape') {
      setPressedKeys([]);
      return;
    }
    
    // Add key to pressed keys
    setPressedKeys(prev => [...prev.slice(-4), key]);
    
    console.log({
      key,           // 'a', 'Enter', 'ArrowUp', etc.
      code,          // 'KeyA', 'Enter', 'ArrowUp', etc.
      ctrlKey,       // boolean
      shiftKey,      // boolean
      altKey,        // boolean
      metaKey        // boolean (Cmd on Mac, Win on Windows)
    });
  };
  
  const handleKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {
    // KeyPress is deprecated, but still useful for character input
    console.log('Character pressed:', event.key);
  };
  
  return (
    <div>
      <div
        tabIndex={0}
        onKeyDown={handleKeyDown}
        style={{ 
          padding: '20px', 
          border: '2px solid #ccc',
          outline: 'none'
        }}
      >
        Click here and press keys (try Ctrl+S, Escape)
      </div>
      
      <input
        type="text"
        onKeyPress={handleKeyPress}
        placeholder="Type here for keypress events"
      />
      
      <p>Recent keys: {pressedKeys.join(', ')}</p>
    </div>
  );
}
```

#### 2. Focus Events

```tsx
function FocusEventExample() {
  const [focusState, setFocusState] = React.useState<{
    activeElement: string;
    focusHistory: string[];
  }>({
    activeElement: '',
    focusHistory: []
  });
  
  const handleFocus = (event: React.FocusEvent<HTMLInputElement>) => {
    const elementName = event.target.name || event.target.placeholder;
    setFocusState(prev => ({
      activeElement: elementName,
      focusHistory: [...prev.focusHistory.slice(-4), `Focused: ${elementName}`]
    }));
  };
  
  const handleBlur = (event: React.FocusEvent<HTMLInputElement>) => {
    const elementName = event.target.name || event.target.placeholder;
    setFocusState(prev => ({
      activeElement: '',
      focusHistory: [...prev.focusHistory.slice(-4), `Blurred: ${elementName}`]
    }));
  };
  
  return (
    <div>
      <h3>Focus Events</h3>
      <p>Active element: {focusState.activeElement || 'None'}</p>
      
      <input
        name="firstName"
        placeholder="First Name"
        onFocus={handleFocus}
        onBlur={handleBlur}
      />
      
      <input
        name="lastName"
        placeholder="Last Name"
        onFocus={handleFocus}
        onBlur={handleBlur}
      />
      
      <input
        name="email"
        placeholder="Email"
        onFocus={handleFocus}
        onBlur={handleBlur}
      />
      
      <div>
        <h4>Focus History:</h4>
        <ul>
          {focusState.focusHistory.map((event, index) => (
            <li key={index}>{event}</li>
          ))}
        </ul>
      </div>
    </div>
  );
}
```

#### 3. Custom Event Handlers with Generic Types

```tsx
// Generic event handler type
type EventHandler<T extends HTMLElement, E extends React.SyntheticEvent<T>> = (event: E) => void;

// Specific handler types
type ButtonClickHandler = EventHandler<HTMLButtonElement, React.MouseEvent<HTMLButtonElement>>;
type InputChangeHandler = EventHandler<HTMLInputElement, React.ChangeEvent<HTMLInputElement>>;
type FormSubmitHandler = EventHandler<HTMLFormElement, React.FormEvent<HTMLFormElement>>;

interface CustomButtonProps {
  onClick?: ButtonClickHandler;
  disabled?: boolean;
  children: React.ReactNode;
}

function CustomButton({ onClick, disabled, children }: CustomButtonProps) {
  const handleClick: ButtonClickHandler = (event) => {
    if (disabled) return;
    
    // Add custom behavior
    console.log('Button clicked:', event.currentTarget.textContent);
    onClick?.(event);
  };
  
  return (
    <button onClick={handleClick} disabled={disabled}>
      {children}
    </button>
  );
}

// Higher-order event handler
function withLogging<T extends HTMLElement, E extends React.SyntheticEvent<T>>(
  handler: EventHandler<T, E>,
  eventName: string
): EventHandler<T, E> {
  return (event) => {
    console.log(`${eventName} event:`, event);
    handler(event);
  };
}

// Usage
function EventHandlerExample() {
  const handleButtonClick: ButtonClickHandler = (event) => {
    alert(`Button "${event.currentTarget.textContent}" was clicked!`);
  };
  
  const handleInputChange: InputChangeHandler = (event) => {
    console.log('Input changed:', event.target.value);
  };
  
  // Wrapped with logging
  const loggedButtonClick = withLogging(handleButtonClick, 'Button Click');
  const loggedInputChange = withLogging(handleInputChange, 'Input Change');
  
  return (
    <div>
      <CustomButton onClick={loggedButtonClick}>
        Click me
      </CustomButton>
      
      <input onChange={loggedInputChange} placeholder="Type something" />
    </div>
  );
}
```

### Event Delegation and Performance

```tsx
// Efficient event handling for lists
function OptimizedList() {
  const [items, setItems] = React.useState([
    { id: 1, name: 'Item 1', completed: false },
    { id: 2, name: 'Item 2', completed: false },
    { id: 3, name: 'Item 3', completed: false }
  ]);
  
  // Single event handler for all list actions
  const handleListClick = (event: React.MouseEvent<HTMLUListElement>) => {
    const target = event.target as HTMLElement;
    const listItem = target.closest('li');
    
    if (!listItem) return;
    
    const itemId = parseInt(listItem.dataset.itemId || '0');
    const action = target.dataset.action;
    
    switch (action) {
      case 'toggle':
        setItems(prev => prev.map(item =>
          item.id === itemId ? { ...item, completed: !item.completed } : item
        ));
        break;
        
      case 'delete':
        setItems(prev => prev.filter(item => item.id !== itemId));
        break;
        
      case 'edit':
        const newName = prompt('Enter new name:', listItem.textContent?.trim());
        if (newName) {
          setItems(prev => prev.map(item =>
            item.id === itemId ? { ...item, name: newName } : item
          ));
        }
        break;
    }
  };
  
  return (
    <div>
      <h3>Optimized List (Event Delegation)</h3>
      <ul onClick={handleListClick}>
        {items.map(item => (
          <li key={item.id} data-item-id={item.id}>
            <span style={{ textDecoration: item.completed ? 'line-through' : 'none' }}>
              {item.name}
            </span>
            <button data-action="toggle">
              {item.completed ? 'Undo' : 'Complete'}
            </button>
            <button data-action="edit">Edit</button>
            <button data-action="delete">Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## Common Event Handling Patterns

### 1. Controlled vs Uncontrolled Components

```tsx
// Controlled component (React manages the state)
function ControlledInput() {
  const [value, setValue] = React.useState('');
  
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setValue(event.target.value);
  };
  
  return (
    <div>
      <input value={value} onChange={handleChange} />
      <p>Value: {value}</p>
    </div>
  );
}

// Uncontrolled component (DOM manages the state)
function UncontrolledInput() {
  const inputRef = React.useRef<HTMLInputElement>(null);
  
  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    if (inputRef.current) {
      alert(`Value: ${inputRef.current.value}`);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} defaultValue="Initial value" />
      <button type="submit">Get Value</button>
    </form>
  );
}
```

### 2. Event Prevention and Propagation

```tsx
function EventPropagationExample() {
  const handleOuterClick = () => console.log('Outer clicked');
  const handleMiddleClick = () => console.log('Middle clicked');
  const handleInnerClick = (event: React.MouseEvent) => {
    console.log('Inner clicked');
    event.stopPropagation(); // Prevents bubbling to parent elements
  };
  
  const handleLinkClick = (event: React.MouseEvent<HTMLAnchorElement>) => {
    event.preventDefault(); // Prevents default link behavior
    console.log('Link clicked but navigation prevented');
  };
  
  const handleFormSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault(); // Prevents form submission
    console.log('Form submission prevented');
  };
  
  return (
    <div onClick={handleOuterClick} style={{ padding: '20px', border: '1px solid red' }}>
      Outer
      <div onClick={handleMiddleClick} style={{ padding: '20px', border: '1px solid blue' }}>
        Middle
        <div onClick={handleInnerClick} style={{ padding: '20px', border: '1px solid green' }}>
          Inner (click won't bubble)
        </div>
      </div>
      
      <a href="https://example.com" onClick={handleLinkClick}>
        Prevented Link
      </a>
      
      <form onSubmit={handleFormSubmit}>
        <button type="submit">Prevented Submit</button>
      </form>
    </div>
  );
}
```

## Summary

Event handling is crucial for creating interactive React applications:

### Key Takeaways:

1. **Event Handlers**: Functions that respond to user interactions
2. **Synthetic Events**: React's cross-browser event wrapper
3. **TypeScript Integration**: Use specific event types for type safety
4. **Performance**: Consider event delegation for large lists
5. **Controlled Components**: React manages form state for better control

### Common Event Types:
- **React.MouseEvent**: Click, mouse move, enter, leave
- **React.ChangeEvent**: Form input changes  
- **React.FormEvent**: Form submission
- **React.KeyboardEvent**: Key presses and releases
- **React.FocusEvent**: Focus and blur events

### Best Practices:
- ✅ Use TypeScript for type safety
- ✅ Prevent default behavior when needed
- ✅ Use functional updates for state changes
- ✅ Consider performance for frequent events
- ✅ Handle errors gracefully
- ✅ Use event delegation for lists

### TypeScript Benefits:
- **Autocomplete**: IntelliSense for event properties
- **Type Safety**: Catch errors at compile time
- **Documentation**: Self-documenting event handlers
- **Refactoring**: Safe code changes

**Next Steps**: Learn about `useEffect` for side effects, custom hooks for reusable logic, and advanced state management patterns!