# React Fundamentals: Functional Components

## What Are Functional Components?

Functional components are **JavaScript functions that return JSX**. They're the modern, preferred way to write React components and have completely replaced class components in new React applications.

### The Evolution: From Classes to Functions

#### Old Way (Class Components - Pre-2019)
```jsx
import React, { Component } from 'react';

class Welcome extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  render() {
    return (
      <div>
        <h1>Hello, {this.props.name}!</h1>
        <p>Count: {this.state.count}</p>
      </div>
    );
  }
}
```

#### Modern Way (Functional Components)
```jsx
import React, { useState } from 'react';

function Welcome({ name }) {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Count: {count}</p>
    </div>
  );
}
```

**Why the change?**
- **Simpler syntax**: Less boilerplate code
- **Better performance**: Functions are lighter than classes
- **Hooks**: Enable state and lifecycle features in functions
- **Easier testing**: Functions are easier to test than classes
- **Better TypeScript support**: More intuitive type definitions

## Anatomy of a Functional Component

### Basic Structure

```jsx
// 1. Import React (and any hooks you need)
import React from 'react';

// 2. Define the function
function ComponentName(props) {
  // 3. Component logic goes here
  
  // 4. Return JSX
  return (
    <div>
      {/* Your JSX here */}
    </div>
  );
}

// 5. Export the component
export default ComponentName;
```

### Multiple Ways to Write Functional Components

#### 1. Function Declaration
```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

#### 2. Arrow Function (Preferred)
```jsx
const Greeting = (props) => {
  return <h1>Hello, {props.name}!</h1>;
};
```

#### 3. Arrow Function (Implicit Return)
```jsx
const Greeting = (props) => <h1>Hello, {props.name}!</h1>;
```

#### 4. With Destructured Props
```jsx
const Greeting = ({ name, age, isOnline }) => {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Age: {age}</p>
      <span>{isOnline ? 'Online' : 'Offline'}</span>
    </div>
  );
};
```

## Working with Props

Props (short for "properties") are how you pass data from parent to child components.

### Basic Props Usage

```jsx
// Parent Component
const App = () => {
  return (
    <div>
      <UserCard 
        name="John Doe" 
        email="john@example.com" 
        age={30}
        isActive={true}
      />
    </div>
  );
};

// Child Component
const UserCard = (props) => {
  return (
    <div className="user-card">
      <h2>{props.name}</h2>
      <p>Email: {props.email}</p>
      <p>Age: {props.age}</p>
      <p>Status: {props.isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
};
```

### Props Destructuring (Cleaner Approach)

```jsx
// Destructure in function parameters
const UserCard = ({ name, email, age, isActive }) => {
  return (
    <div className="user-card">
      <h2>{name}</h2>
      <p>Email: {email}</p>
      <p>Age: {age}</p>
      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
};

// Or destructure inside the function
const UserCard = (props) => {
  const { name, email, age, isActive } = props;
  
  return (
    <div className="user-card">
      <h2>{name}</h2>
      <p>Email: {email}</p>
      <p>Age: {age}</p>
      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
};
```

### Default Props

```jsx
// Method 1: Default parameters
const Button = ({ text = "Click me", variant = "primary", onClick }) => {
  return (
    <button 
      className={`btn btn-${variant}`}
      onClick={onClick}
    >
      {text}
    </button>
  );
};

// Method 2: Using defaultProps (older pattern)
const Button = ({ text, variant, onClick }) => {
  return (
    <button 
      className={`btn btn-${variant}`}
      onClick={onClick}
    >
      {text}
    </button>
  );
};

Button.defaultProps = {
  text: "Click me",
  variant: "primary"
};
```

### Props with Complex Data Types

```jsx
// Passing objects and arrays
const BlogPost = ({ post, author, tags, onLike }) => {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>By: {author.name}</p>
      <p>{post.content}</p>
      
      <div className="tags">
        {tags.map(tag => (
          <span key={tag} className="tag">{tag}</span>
        ))}
      </div>
      
      <button onClick={() => onLike(post.id)}>
        Like ({post.likes})
      </button>
    </article>
  );
};

// Usage
const App = () => {
  const post = {
    id: 1,
    title: "Learning React",
    content: "React is amazing!",
    likes: 42
  };
  
  const author = {
    name: "Jane Doe",
    avatar: "/jane.jpg"
  };
  
  const tags = ["react", "javascript", "frontend"];
  
  const handleLike = (postId) => {
    console.log(`Liked post ${postId}`);
  };
  
  return (
    <BlogPost 
      post={post}
      author={author}
      tags={tags}
      onLike={handleLike}
    />
  );
};
```

## Functional Components with State (useState Hook)

Before hooks, functional components couldn't have state. Now they can!

### Basic State Usage

```jsx
import React, { useState } from 'react';

const Counter = () => {
  // Declare state variable with initial value
  const [count, setCount] = useState(0);
  
  const increment = () => {
    setCount(count + 1);
  };
  
  const decrement = () => {
    setCount(count - 1);
  };
  
  const reset = () => {
    setCount(0);
  };
  
  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
};
```

### Multiple State Variables

```jsx
const UserProfile = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [isEditing, setIsEditing] = useState(false);
  
  const handleSave = () => {
    // Save logic here
    setIsEditing(false);
  };
  
  if (isEditing) {
    return (
      <form>
        <input 
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Name"
        />
        <input 
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
        />
        <input 
          type="number"
          value={age}
          onChange={(e) => setAge(parseInt(e.target.value))}
          placeholder="Age"
        />
        <button type="button" onClick={handleSave}>Save</button>
        <button type="button" onClick={() => setIsEditing(false)}>Cancel</button>
      </form>
    );
  }
  
  return (
    <div>
      <h2>{name}</h2>
      <p>Email: {email}</p>
      <p>Age: {age}</p>
      <button onClick={() => setIsEditing(true)}>Edit</button>
    </div>
  );
};
```

### State with Objects

```jsx
const UserForm = () => {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: 0,
    preferences: {
      theme: 'light',
      notifications: true
    }
  });
  
  const updateUser = (field, value) => {
    setUser(prevUser => ({
      ...prevUser,
      [field]: value
    }));
  };
  
  const updatePreferences = (field, value) => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        [field]: value
      }
    }));
  };
  
  return (
    <form>
      <input 
        value={user.name}
        onChange={(e) => updateUser('name', e.target.value)}
        placeholder="Name"
      />
      <input 
        value={user.email}
        onChange={(e) => updateUser('email', e.target.value)}
        placeholder="Email"
      />
      <select 
        value={user.preferences.theme}
        onChange={(e) => updatePreferences('theme', e.target.value)}
      >
        <option value="light">Light</option>
        <option value="dark">Dark</option>
      </select>
      
      <div>
        <h3>Current User:</h3>
        <pre>{JSON.stringify(user, null, 2)}</pre>
      </div>
    </form>
  );
};
```

## Component Composition and Reusability

### Creating Reusable Components

```jsx
// Generic Button Component
const Button = ({ 
  children, 
  variant = 'primary', 
  size = 'medium',
  disabled = false,
  onClick,
  ...otherProps 
}) => {
  const baseClasses = 'btn';
  const variantClass = `btn-${variant}`;
  const sizeClass = `btn-${size}`;
  
  const className = [baseClasses, variantClass, sizeClass]
    .filter(Boolean)
    .join(' ');
    
  return (
    <button 
      className={className}
      disabled={disabled}
      onClick={onClick}
      {...otherProps}
    >
      {children}
    </button>
  );
};

// Usage
const App = () => {
  return (
    <div>
      <Button onClick={() => alert('Primary!')}>
        Primary Button
      </Button>
      
      <Button variant="secondary" size="large">
        Large Secondary
      </Button>
      
      <Button variant="danger" disabled>
        Disabled Danger
      </Button>
    </div>
  );
};
```

### Component Composition with Children

```jsx
// Card Container Component
const Card = ({ children, title, footer }) => {
  return (
    <div className="card">
      {title && (
        <div className="card-header">
          <h3>{title}</h3>
        </div>
      )}
      
      <div className="card-body">
        {children}
      </div>
      
      {footer && (
        <div className="card-footer">
          {footer}
        </div>
      )}
    </div>
  );
};

// Usage
const ProductCard = ({ product }) => {
  return (
    <Card 
      title={product.name}
      footer={
        <Button variant="primary">
          Add to Cart - ${product.price}
        </Button>
      }
    >
      <img src={product.image} alt={product.name} />
      <p>{product.description}</p>
      <div className="rating">
        Rating: {product.rating}/5
      </div>
    </Card>
  );
};
```

## Event Handling in Functional Components

### Basic Event Handlers

```jsx
const EventExample = () => {
  const [inputValue, setInputValue] = useState('');
  const [items, setItems] = useState([]);
  
  // Handle form submission
  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      setItems([...items, inputValue.trim()]);
      setInputValue('');
    }
  };
  
  // Handle input change
  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };
  
  // Handle item removal
  const removeItem = (indexToRemove) => {
    setItems(items.filter((_, index) => index !== indexToRemove));
  };
  
  // Handle key press
  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      handleSubmit(e);
    }
  };
  
  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input 
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          onKeyPress={handleKeyPress}
          placeholder="Add an item"
        />
        <button type="submit">Add</button>
      </form>
      
      <ul>
        {items.map((item, index) => (
          <li key={index}>
            {item}
            <button onClick={() => removeItem(index)}>
              Remove
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};
```

## Conditional Rendering

### Different Patterns for Conditional Rendering

```jsx
const ConditionalExample = () => {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Pattern 1: Ternary operator
  const renderUserStatus = () => {
    return isLoading ? (
      <div>Loading...</div>
    ) : user ? (
      <div>Welcome, {user.name}!</div>
    ) : (
      <div>Please log in</div>
    );
  };
  
  // Pattern 2: Logical AND (&&)
  const renderError = () => {
    return error && (
      <div className="error">
        Error: {error.message}
      </div>
    );
  };
  
  // Pattern 3: Early return
  if (isLoading) {
    return <div>Loading...</div>;
  }
  
  if (error) {
    return (
      <div className="error-page">
        <h2>Something went wrong</h2>
        <p>{error.message}</p>
      </div>
    );
  }
  
  return (
    <div>
      {renderUserStatus()}
      {renderError()}
      
      {/* Inline conditional rendering */}
      {user && user.isAdmin && (
        <div className="admin-panel">
          <h3>Admin Panel</h3>
          <button>Manage Users</button>
        </div>
      )}
    </div>
  );
};
```

## TypeScript with Functional Components

### Typing Props

```tsx
import React from 'react';

// Define prop types
interface UserCardProps {
  name: string;
  email: string;
  age: number;
  isActive?: boolean; // Optional prop
  onEdit?: () => void; // Optional function prop
}

const UserCard: React.FC<UserCardProps> = ({ 
  name, 
  email, 
  age, 
  isActive = false,
  onEdit 
}) => {
  return (
    <div className="user-card">
      <h2>{name}</h2>
      <p>Email: {email}</p>
      <p>Age: {age}</p>
      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>
      {onEdit && (
        <button onClick={onEdit}>Edit</button>
      )}
    </div>
  );
};

// Usage with type safety
const App: React.FC = () => {
  const handleEdit = () => {
    console.log('Edit clicked');
  };
  
  return (
    <UserCard 
      name="John Doe"
      email="john@example.com"
      age={30}
      isActive={true}
      onEdit={handleEdit}
    />
  );
};
```

### Typing State and Events

```tsx
import React, { useState } from 'react';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

const TodoApp: React.FC = () => {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [inputValue, setInputValue] = useState<string>('');
  
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (inputValue.trim()) {
      const newTodo: Todo = {
        id: Date.now(),
        text: inputValue.trim(),
        completed: false
      };
      setTodos([...todos, newTodo]);
      setInputValue('');
    }
  };
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(e.target.value);
  };
  
  const toggleTodo = (id: number) => {
    setTodos(todos.map(todo => 
      todo.id === id 
        ? { ...todo, completed: !todo.completed }
        : todo
    ));
  };
  
  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input 
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          placeholder="Add a todo"
        />
        <button type="submit">Add</button>
      </form>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <label>
              <input 
                type="checkbox"
                checked={todo.completed}
                onChange={() => toggleTodo(todo.id)}
              />
              <span 
                style={{ 
                  textDecoration: todo.completed ? 'line-through' : 'none' 
                }}
              >
                {todo.text}
              </span>
            </label>
          </li>
        ))}
      </ul>
    </div>
  );
};
```

## Best Practices for Functional Components

### 1. Component Organization

```jsx
// ✅ Good: Clear structure and organization
import React, { useState, useEffect } from 'react';
import './UserProfile.css';

interface UserProfileProps {
  userId: string;
}

const UserProfile: React.FC<UserProfileProps> = ({ userId }) => {
  // State declarations
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // Effects
  useEffect(() => {
    fetchUser(userId);
  }, [userId]);
  
  // Event handlers
  const handleEdit = () => {
    // Edit logic
  };
  
  // Helper functions
  const fetchUser = async (id: string) => {
    // Fetch logic
  };
  
  // Early returns for loading/error states
  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;
  
  // Main render
  return (
    <div className="user-profile">
      {/* Component JSX */}
    </div>
  );
};

export default UserProfile;
```

### 2. Naming Conventions

```jsx
// ✅ Good naming conventions
const UserCard = ({ user, onEdit, isSelected }) => { /* ... */ };
const handleUserEdit = () => { /* ... */ };
const [isLoading, setIsLoading] = useState(false);
const [userData, setUserData] = useState(null);

// ❌ Poor naming
const comp = ({ u, fn, sel }) => { /* ... */ };
const click = () => { /* ... */ };
const [flag, setFlag] = useState(false);
const [data, setData] = useState(null);
```

### 3. Performance Considerations

```jsx
import React, { memo, useMemo, useCallback } from 'react';

// Memoize components that receive complex props
const ExpensiveComponent = memo(({ data, onUpdate }) => {
  // Expensive calculations
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: expensiveCalculation(item)
    }));
  }, [data]);
  
  // Memoize callback functions
  const handleUpdate = useCallback((id, newValue) => {
    onUpdate(id, newValue);
  }, [onUpdate]);
  
  return (
    <div>
      {processedData.map(item => (
        <ItemComponent 
          key={item.id}
          item={item}
          onUpdate={handleUpdate}
        />
      ))}
    </div>
  );
});
```

## Common Patterns and Examples

### 1. List Rendering with Keys

```jsx
const TodoList = ({ todos, onToggle, onDelete }) => {
  return (
    <ul className="todo-list">
      {todos.map(todo => (
        <li key={todo.id} className={todo.completed ? 'completed' : ''}>
          <span onClick={() => onToggle(todo.id)}>
            {todo.text}
          </span>
          <button onClick={() => onDelete(todo.id)}>
            Delete
          </button>
        </li>
      ))}
    </ul>
  );
};
```

### 2. Form Handling

```jsx
const ContactForm = ({ onSubmit }) => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  const [errors, setErrors] = useState({});
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
  };
  
  const validate = () => {
    const newErrors = {};
    
    if (!formData.name.trim()) {
      newErrors.name = 'Name is required';
    }
    
    if (!formData.email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    if (!formData.message.trim()) {
      newErrors.message = 'Message is required';
    }
    
    return newErrors;
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    const newErrors = validate();
    
    if (Object.keys(newErrors).length === 0) {
      onSubmit(formData);
      setFormData({ name: '', email: '', message: '' });
    } else {
      setErrors(newErrors);
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="contact-form">
      <div className="form-group">
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
          placeholder="Your Name"
          className={errors.name ? 'error' : ''}
        />
        {errors.name && <span className="error-text">{errors.name}</span>}
      </div>
      
      <div className="form-group">
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          placeholder="Your Email"
          className={errors.email ? 'error' : ''}
        />
        {errors.email && <span className="error-text">{errors.email}</span>}
      </div>
      
      <div className="form-group">
        <textarea
          name="message"
          value={formData.message}
          onChange={handleChange}
          placeholder="Your Message"
          rows={4}
          className={errors.message ? 'error' : ''}
        />
        {errors.message && <span className="error-text">{errors.message}</span>}
      </div>
      
      <button type="submit">Send Message</button>
    </form>
  );
};
```

## Summary

Functional components are the modern standard for React development because they:

1. **Are simpler**: Less boilerplate than class components
2. **Support hooks**: Enable state and effects in functions
3. **Perform better**: Functions are lighter than classes
4. **Are easier to test**: Pure functions are easier to unit test
5. **Have better TypeScript support**: More intuitive type definitions

### Key Takeaways:
- Always use functional components for new React code
- Leverage destructuring for cleaner prop handling
- Use hooks like `useState` for component state
- Follow naming conventions and organize code clearly
- Consider performance with `memo`, `useMemo`, and `useCallback`
- Use TypeScript for better type safety and developer experience

**Next Steps**: Learn about React Hooks in detail, starting with `useState`, `useEffect`, and custom hooks!