# React Context & useContext: Scalable State Sharing Patterns

> Move from naive prop drilling to intentional, observable, well‑scoped shared state. Avoid the common performance traps.

---
## 1. When (and When NOT) to Use Context
| Use Context When | Prefer Alternatives |
|------------------|--------------------|
| Same data needed by many distant descendants | Parent can lift and pass directly |
| The value is relatively stable (theme, locale, auth user) | Rapidly changing per-frame data (e.g., mouse position) |
| You want pluggable/providers architecture | Global singleton module state (just import) |
| Cross-cutting concerns (feature flags, permissions) | Local, isolated component state |

> Context is NOT a state management silver bullet; it’s a dependency injection channel.

---
## 2. Core API Recap
```jsx
const MyContext = React.createContext(defaultValue);
<MyContext.Provider value={actualValue}>{children}</MyContext.Provider>
const value = useContext(MyContext);
```

---
## 3. Anti-Pattern: “God Context”
One mega-context containing auth, theme, notifications, cart, language, feature flags, etc. leads to **EXCESSIVE RE-RENDERS** because any change triggers all consumers.

✅ Split by change frequency & concern boundaries.

---
## 4. Layered Context Architecture (Example)
```txt
AppProviders
 ├─ ThemeProvider          (rare changes)
 ├─ AuthProvider           (session-level changes)
 ├─ FeatureFlagsProvider   (initial load + infrequent refresh)
 ├─ QueryClientProvider    (react-query cache)
 └─ UIStateProvider        (panel open/closed, ephemeral)
```

---
## 5. Building a Robust Context + Hook Pair
### 5.1 Auth Example
```jsx
// auth-context.js
const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [status, setStatus] = useState('idle'); // idle | loading | authenticated | error

  useEffect(() => {
    let mounted = true;
    (async () => {
      setStatus('loading');
      try {
        const res = await fetch('/api/session');
        if (!res.ok) throw new Error('Session load failed');
        const json = await res.json();
        if (mounted) { setUser(json.user); setStatus('authenticated'); }
      } catch (e) {
        if (mounted) { setUser(null); setStatus('error'); }
      }
    })();
    return () => { mounted = false; };
  }, []);

  const login = useCallback(async (credentials) => { /* ... */ }, []);
  const logout = useCallback(async () => { /* ... */ }, []);

  const value = useMemo(() => ({ user, status, login, logout }), [user, status, login, logout]);
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be inside <AuthProvider>');
  return ctx;
}
```

### 5.2 Usage
```jsx
function UserMenu() {
  const { user, status, logout } = useAuth();
  if (status === 'loading') return <SkeletonAvatar/>;
  if (!user) return <LoginButton/>;
  return <Dropdown label={user.name}><button onClick={logout}>Logout</button></Dropdown>;
}
```

---
## 6. Performance: Avoid Re-render Storms
| Issue | Cause | Solution |
|-------|------|----------|
| All consumers rerender | Provider value object recreated each render | Wrap value in `useMemo` |
| Frequent transient updates | Storing high-churn state in context | Keep high-churn state local; store stable snapshot in context |
| Large tree updates | Over-broad provider wrap | Narrow provider scope around only needed sub-tree |
| Selective consumption needed | Consumers read entire object | Split context OR use selector pattern |

### 6.1 Memoizing Provider Value
```jsx
const value = useMemo(() => ({ theme, setTheme }), [theme]);
```

### 6.2 Derived + Source Separation
Keep raw mutable store external; expose stable interface via context.
```jsx
// store.js
const listeners = new Set();
let state = { count: 0 };
export const increment = () => { state = { ...state, count: state.count + 1 }; listeners.forEach(l=>l()); };
export const subscribe = (fn) => { listeners.add(fn); return () => listeners.delete(fn); };
export const getState = () => state;

// counter-context.js
const CounterContext = createContext(null);
export function CounterProvider({ children }) {
  const [count, setCount] = useState(() => getState().count);
  useEffect(() => subscribe(() => setCount(getState().count)), []);
  const value = useMemo(() => ({ count, increment }), [count]);
  return <CounterContext.Provider value={value}>{children}</CounterContext.Provider>;
}
export const useCounter = () => useContext(CounterContext);
```

### 6.3 Selector Pattern (Custom Hook Wrapper)
If you need partial reads to avoid rerender from unrelated fields, use libraries (Zustand, Jotai) or implement a subscription-based selector. Native context lacks built-in selectors; every consumer rerenders when value identity changes.

---
## 7. Composition & Namespacing
```jsx
function AppProviders({ children }) {
  return (
    <ThemeProvider>
      <AuthProvider>
        <FeatureFlagsProvider>
          <UIStateProvider>{children}</UIStateProvider>
        </FeatureFlagsProvider>
      </AuthProvider>
    </ThemeProvider>
  );
}
```

Avoid deeply nested arrow >> prefer extraction for clarity.

---
## 8. Cross-Cutting Concerns Examples

### 8.1 Theme
```jsx
const ThemeContext = createContext();
export const ThemeProvider = ({ children }) => {
  const [mode, setMode] = useState('light');
  useEffect(() => { document.documentElement.dataset.theme = mode; }, [mode]);
  const toggle = useCallback(() => setMode(m => m === 'light' ? 'dark' : 'light'), []);
  const value = useMemo(() => ({ mode, toggle }), [mode, toggle]);
  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
};
export const useTheme = () => useContext(ThemeContext);
```

### 8.2 Feature Flags
```jsx
const FlagsContext = createContext(null);
export function FeatureFlagsProvider({ children }) {
  const [flags, setFlags] = useState({ ready: false, map: {} });
  useEffect(() => { (async () => {
    const res = await fetch('/api/flags');
    const data = await res.json();
    setFlags({ ready: true, map: data });
  })(); }, []);
  const enabled = useCallback(name => !!flags.map[name], [flags.map]);
  const value = useMemo(() => ({ ...flags, enabled }), [flags, enabled]);
  return <FlagsContext.Provider value={value}>{children}</FlagsContext.Provider>;
}
export const useFlags = () => useContext(FlagsContext);
```

### 8.3 Toast / Notification Bus
```jsx
const ToastContext = createContext(null);
export function ToastProvider({ children }) {
  const [toasts, setToasts] = useState([]);
  const push = useCallback(msg => setToasts(ts => [...ts, { id: crypto.randomUUID(), ...msg }]), []);
  const dismiss = useCallback(id => setToasts(ts => ts.filter(t => t.id !== id)), []);
  const value = useMemo(() => ({ push, dismiss }), [push, dismiss]);
  return (
    <ToastContext.Provider value={value}>
      {children}
      <ToastViewport toasts={toasts} dismiss={dismiss} />
    </ToastContext.Provider>
  );
}
export const useToast = () => useContext(ToastContext);
```

---
## 9. Handling Async Initialization
Make provider block/placeholder until data ready OR expose a `ready` flag.
```jsx
function SomeFeatureConsumer() {
  const { ready, map } = useFlags();
  if (!ready) return <Spinner size="sm" />;
  return map.newLayout ? <NewLayout /> : <OldLayout />;
}
```

---
## 10. Testing Context Consumers
```jsx
function renderWithProviders(ui, { authUser } = {}) {
  return render(
    <AuthProvider initialUser={authUser}>
      {ui}
    </AuthProvider>
  );
}

test('shows login when no user', () => {
  renderWithProviders(<UserMenu />);
  expect(screen.getByText(/login/i)).toBeInTheDocument();
});
```

---
## 11. Migration Strategy (Prop Drilling → Context)
1. Identify repeated prop chains (≥3 levels)
2. Extract minimal value shape (avoid dumping entire objects)
3. Create context + hook
4. Replace deepest consumers first (still pass props until all consumers migrated)
5. Remove drilling once last consumer migrated

---
## 12. Common Mistakes & Fixes
| Mistake | Symptom | Fix |
|---------|---------|-----|
| Putting rapidly changing value (e.g., input text) in context | Cascading renders | Keep locally; lift only stable snapshot |
| Recreating provider value each render | All consumers rerender | Wrap in `useMemo` |
| Catch-all context with unrelated domains | Hard to scale | Split by domain & update frequency |
| Missing error when used outside provider | Runtime undefined access | Throw inside custom hook |
| Passing huge objects | Unnecessary rerenders | Pick specific fields or derive local selectors |

---
## 13. Advanced Patterns
### 13.1 Context Module Pattern (No Provider Needed)
```jsx
// theme-module.js (simple app-wide state w/out provider)
let theme = 'light';
const listeners = new Set();
export const getTheme = () => theme;
export const setTheme = (t) => { theme = t; listeners.forEach(l => l(theme)); };
export function useThemeModule() {
  const [cur, setCur] = useState(() => getTheme());
  useEffect(() => { listeners.add(setCur); return () => listeners.delete(setCur); }, []);
  return [cur, setTheme];
}
```

### 13.2 Partial Context Split
```jsx
const UserDataContext = createContext(null);
const UserActionsContext = createContext(null);

export const useUserData = () => useContext(UserDataContext);
export const useUserActions = () => useContext(UserActionsContext);

function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  const load = useCallback(async () => {/*...*/}, []);
  const valueData = useMemo(() => ({ user }), [user]);
  const valueActions = useMemo(() => ({ load }), [load]);
  return (
    <UserActionsContext.Provider value={valueActions}>
      <UserDataContext.Provider value={valueData}>
        {children}
      </UserDataContext.Provider>
    </UserActionsContext.Provider>
  );
}
```

### 13.3 Combining Context + Reducer
```jsx
const CartContext = createContext(null);
function cartReducer(state, action) {
  switch (action.type) {
    case 'add': return state.find(i => i.id === action.item.id)
      ? state.map(i => i.id === action.item.id ? { ...i, qty: i.qty + 1 } : i)
      : [...state, { ...action.item, qty: 1 }];
    case 'remove': return state.filter(i => i.id !== action.id);
    case 'clear': return [];
    default: return state;
  }
}
export function CartProvider({ children }) {
  const [items, dispatch] = useReducer(cartReducer, []);
  const total = useMemo(() => items.reduce((s,i)=>s+i.price*i.qty,0), [items]);
  const value = useMemo(() => ({ items, total, dispatch }), [items, total]);
  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
}
export const useCart = () => useContext(CartContext);
```

---
## 14. Security / Boundary Considerations
| Concern | Mitigation |
|---------|-----------|
| Exposing sensitive user data globally | Provide only needed fields; derive at consumer |
| Mutating shared objects | Freeze or copy before providing | 
| Accidental provider nesting duplication | Compose providers centrally |

---
## 15. Checklist Before Shipping a New Context
1. Is context truly required? (≥3 consumer branches?)
2. Value shape minimal & stable?
3. Wrapped in custom hook with usage guard?
4. Memoized provider value?
5. Tests cover provider + one consumer?
6. Update frequency acceptable?
7. Documented purpose & non-goals?

---
## 16. Quick Reference
| Intent | Pattern |
|--------|---------|
| Provide static config | `<ConfigContext.Provider value={config}>` |
| Global but stable user | Auth context + lazy init |
| High churn domain | External store + subscription + thin context |
| Complex mutations | `useReducer` inside provider |
| Select actions separate | Split data/actions contexts |
| Optional consumer safety | Custom hook throws if !provider |

---
## 17. Key Takeaways
1. Context = dependency injection channel, not a state store by itself.
2. Split by concern and update frequency to prevent rerender avalanches.
3. Memoize provider values.
4. Wrap raw context in custom hooks for DX + safety.
5. Combine with reducers or external stores for scalable complexity.

> Next: Styling strategies and design system cohesion (Tailwind + CSS-in-JS + composition).
# React Context API & useContext Hook

## 7.1 The Problem: Prop Drilling

Prop drilling occurs when you need to pass data through multiple component layers, even when intermediate components don't need or use that data. This creates maintenance headaches and tightly couples components.

### Understanding Prop Drilling

```jsx
// ❌ Prop drilling example - passing user data through multiple levels

// Top-level App component
function App() {
  const [user, setUser] = useState({
    id: 1,
    name: 'John Doe',
    email: 'john@example.com',
    role: 'admin',
    preferences: {
      theme: 'dark',
      language: 'en',
      notifications: true
    }
  });

  return (
    <div className="app">
      <Header user={user} />
      <MainContent user={user} />
      <Footer user={user} />
    </div>
  );
}

// Header component - doesn't use user directly, just passes it down
function Header({ user }) {
  return (
    <header>
      <Navigation user={user} />
      <SearchBar />
    </header>
  );
}

// Navigation component - also just passes it down
function Navigation({ user }) {
  return (
    <nav>
      <Logo />
      <MenuItems />
      <UserProfile user={user} />
    </nav>
  );
}

// Finally, the component that actually needs the user data
function UserProfile({ user }) {
  return (
    <div className="user-profile">
      <img src={user.avatar} alt="Profile" />
      <span>{user.name}</span>
      <UserMenu user={user} />
    </div>
  );
}

// And it continues...
function UserMenu({ user }) {
  return (
    <div className="user-menu">
      <div>Welcome, {user.name}!</div>
      <div>Role: {user.role}</div>
      <Settings preferences={user.preferences} />
    </div>
  );
}

function Settings({ preferences }) {
  return (
    <div className="settings">
      <div>Theme: {preferences.theme}</div>
      <div>Language: {preferences.language}</div>
      <div>Notifications: {preferences.notifications ? 'On' : 'Off'}</div>
    </div>
  );
}
```

### Problems with Prop Drilling

#### 1. Maintenance Nightmare

```jsx
// ❌ Adding a new prop requires changing every intermediate component
function App() {
  const [user, setUser] = useState(userData);
  const [permissions, setPermissions] = useState(userPermissions); // New data!
  
  return (
    <div className="app">
      {/* Now need to pass permissions everywhere */}
      <Header user={user} permissions={permissions} />
      <MainContent user={user} permissions={permissions} />
      <Footer user={user} permissions={permissions} />
    </div>
  );
}

// Every intermediate component needs updating
function Header({ user, permissions }) { // Added permissions
  return (
    <header>
      <Navigation user={user} permissions={permissions} /> {/* Pass it down */}
      <SearchBar />
    </header>
  );
}

function Navigation({ user, permissions }) { // Added permissions
  return (
    <nav>
      <Logo />
      <MenuItems />
      <UserProfile user={user} permissions={permissions} /> {/* Pass it down */}
    </nav>
  );
}

// This gets tedious and error-prone very quickly!
```

#### 2. Tight Coupling

```jsx
// ❌ Components become tightly coupled to data they don't use
function ProductGrid({ user, cart, filters, sortOptions, preferences }) {
  // This component only needs filters and sortOptions
  // But it's forced to accept and pass through user, cart, and preferences
  
  return (
    <div className="product-grid">
      {products.map(product => (
        <ProductCard 
          key={product.id}
          product={product}
          user={user}           // Doesn't need this
          cart={cart}           // Or this
          preferences={preferences} // Or this
          onAddToCart={handleAddToCart}
        />
      ))}
    </div>
  );
}
```

#### 3. Component Reusability Issues

```jsx
// ❌ Hard to reuse components because they expect specific props
function ReusableButton({ user, onClick, children }) {
  // This button component is tied to user data
  // Can't reuse it in contexts where user isn't available
  
  const canClick = user.role === 'admin' || user.permissions.includes('write');
  
  return (
    <button 
      onClick={onClick} 
      disabled={!canClick}
      className={`btn ${user.preferences.theme}`}
    >
      {children}
    </button>
  );
}

// Usage becomes complex
function SomeFeature() {
  // Need to have user data just to render a button!
  return (
    <div>
      <ReusableButton user={user} onClick={handleAction}>
        Click Me
      </ReusableButton>
    </div>
  );
}
```

#### 4. Performance Impact

```jsx
// ❌ Unnecessary re-renders when props change
function ExpensiveMiddleComponent({ user, data }) {
  // This component does expensive calculations
  // But re-renders every time user changes, even though it only needs data
  
  const expensiveCalculation = useMemo(() => {
    return performHeavyCalculation(data);
  }, [data]);
  
  return (
    <div>
      {expensiveCalculation.map(item => (
        <ExpensiveChildComponent 
          key={item.id} 
          item={item} 
          user={user} // Forces re-render when user changes
        />
      ))}
    </div>
  );
}
```

### Real-World Prop Drilling Example

```jsx
// ❌ Complex e-commerce app with severe prop drilling
function ECommerceApp() {
  const [user, setUser] = useState(null);
  const [cart, setCart] = useState([]);
  const [wishlist, setWishlist] = useState([]);
  const [currency, setCurrency] = useState('USD');
  const [language, setLanguage] = useState('en');
  const [theme, setTheme] = useState('light');

  return (
    <div className="app">
      <AppHeader 
        user={user}
        cart={cart}
        currency={currency}
        language={language}
        theme={theme}
      />
      <AppMain 
        user={user}
        cart={cart}
        wishlist={wishlist}
        currency={currency}
        language={language}
        theme={theme}
        onAddToCart={setCart}
        onAddToWishlist={setWishlist}
      />
      <AppFooter 
        currency={currency}
        language={language}
        theme={theme}
      />
    </div>
  );
}

function AppHeader({ user, cart, currency, language, theme }) {
  return (
    <header className={`header theme-${theme}`}>
      <Logo theme={theme} />
      <SearchBar language={language} />
      <Navigation 
        user={user}
        cart={cart}
        currency={currency}
        language={language}
        theme={theme}
      />
    </header>
  );
}

function Navigation({ user, cart, currency, language, theme }) {
  return (
    <nav className={`nav theme-${theme}`}>
      <MainMenu language={language} />
      <CartIcon 
        cart={cart} 
        currency={currency} 
        theme={theme} 
      />
      <UserMenu 
        user={user} 
        language={language} 
        theme={theme} 
      />
    </nav>
  );
}

// This pattern continues deep into the component tree...
// Every component needs to know about and pass down data it doesn't use!
```

## 7.2 createContext

The `createContext` function creates a Context object that can hold and share data across your component tree without prop drilling.

### Basic Context Creation

```jsx
import React, { createContext } from 'react';

// Create a context for user data
const UserContext = createContext();

// Create a context with default value
const ThemeContext = createContext('light');

// Create a context with complex default value
const AppContext = createContext({
  user: null,
  theme: 'light',
  language: 'en',
  updateUser: () => {},
  updateTheme: () => {},
  updateLanguage: () => {}
});
```

### Context with TypeScript

```tsx
interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'moderator';
  preferences: {
    theme: 'light' | 'dark';
    language: string;
    notifications: boolean;
  };
}

interface UserContextType {
  user: User | null;
  isLoading: boolean;
  error: string | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  updateProfile: (updates: Partial<User>) => Promise<void>;
}

// Create typed context
const UserContext = createContext<UserContextType | undefined>(undefined);
```

### Context Best Practices: Default Values

```jsx
// ❌ Don't use null/undefined without good reason
const BadContext = createContext(null);

// ❌ Empty object can cause runtime errors
const AnotherBadContext = createContext({});

// ✅ Provide meaningful defaults
const GoodContext = createContext({
  user: null,
  isLoggedIn: false,
  login: () => Promise.resolve(),
  logout: () => {},
  loading: false,
  error: null
});

// ✅ Or use undefined with proper TypeScript typing
const TypedContext = createContext<UserContextType | undefined>(undefined);

// ✅ Create multiple focused contexts instead of one large one
const UserContext = createContext<UserContextType | undefined>(undefined);
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);
const LanguageContext = createContext<LanguageContextType | undefined>(undefined);
```

### Context Organization Patterns

```jsx
// Pattern 1: Single file per context
// contexts/UserContext.js
export const UserContext = createContext();

// Pattern 2: Context with related types
// contexts/UserContext.ts
export interface User {
  id: number;
  name: string;
  email: string;
}

export interface UserContextType {
  user: User | null;
  setUser: (user: User | null) => void;
}

export const UserContext = createContext<UserContextType | undefined>(undefined);

// Pattern 3: Context barrel exports
// contexts/index.js
export { UserContext } from './UserContext';
export { ThemeContext } from './ThemeContext';
export { CartContext } from './CartContext';

// Pattern 4: Context with custom hook
// contexts/UserContext.tsx
const UserContext = createContext<UserContextType | undefined>(undefined);

export const useUser = () => {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
};

export default UserContext;
```

## 7.3 The Provider

The Provider component makes context values available to all child components. It accepts a `value` prop and passes that value to all consuming components.

### Basic Provider Usage

```jsx
import React, { createContext, useState } from 'react';

const UserContext = createContext();

function App() {
  const [user, setUser] = useState({
    id: 1,
    name: 'John Doe',
    email: 'john@example.com'
  });

  return (
    // Provide user data to all child components
    <UserContext.Provider value={{ user, setUser }}>
      <div className="app">
        <Header />
        <MainContent />
        <Footer />
      </div>
    </UserContext.Provider>
  );
}

// Now any child component can access user data without prop drilling!
function Header() {
  return (
    <header>
      <Navigation />
      <SearchBar />
    </header>
  );
}

function Navigation() {
  return (
    <nav>
      <Logo />
      <MenuItems />
      <UserProfile /> {/* No need to pass user prop! */}
    </nav>
  );
}
```

### Provider with State Management

```jsx
function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const login = async (email, password) => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        throw new Error('Login failed');
      }
      
      const userData = await response.json();
      setUser(userData);
      localStorage.setItem('token', userData.token);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('token');
  };

  const updateProfile = async (updates) => {
    setLoading(true);
    
    try {
      const response = await fetch('/api/user/profile', {
        method: 'PATCH',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) {
        throw new Error('Update failed');
      }
      
      const updatedUser = await response.json();
      setUser(updatedUser);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const value = {
    user,
    loading,
    error,
    login,
    logout,
    updateProfile,
    isLoggedIn: !!user
  };

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}

// Usage
function App() {
  return (
    <UserProvider>
      <Router>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/profile" element={<Profile />} />
          <Route path="/login" element={<Login />} />
        </Routes>
      </Router>
    </UserProvider>
  );
}
```

### Multiple Providers

```jsx
// Multiple contexts for different concerns
function AppProviders({ children }) {
  return (
    <UserProvider>
      <ThemeProvider>
        <LanguageProvider>
          <CartProvider>
            {children}
          </CartProvider>
        </LanguageProvider>
      </ThemeProvider>
    </UserProvider>
  );
}

// Or compose them in a single component
function AppProvider({ children }) {
  return (
    <AppProviders>
      {children}
    </AppProviders>
  );
}

function App() {
  return (
    <AppProvider>
      <Router>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/shop" element={<Shop />} />
        </Routes>
      </Router>
    </AppProvider>
  );
}
```

### Provider Optimization Patterns

```jsx
// ❌ Provider value recreated on every render
function BadUserProvider({ children }) {
  const [user, setUser] = useState(null);
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
}

// ✅ Memoize provider value
function GoodUserProvider({ children }) {
  const [user, setUser] = useState(null);
  
  const value = useMemo(() => ({
    user,
    setUser
  }), [user]);
  
  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}

// ✅ Split stable and unstable values
function OptimizedProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  // Stable functions
  const userActions = useMemo(() => ({
    login: async (email, password) => { /* ... */ },
    logout: () => setUser(null),
    updateProfile: async (updates) => { /* ... */ }
  }), []);
  
  // User state context
  const userValue = useMemo(() => ({
    user,
    setUser,
    ...userActions
  }), [user, userActions]);
  
  // Theme context (separate from user)
  const themeValue = useMemo(() => ({
    theme,
    setTheme,
    toggleTheme: () => setTheme(prev => prev === 'light' ? 'dark' : 'light')
  }), [theme]);
  
  return (
    <UserContext.Provider value={userValue}>
      <ThemeContext.Provider value={themeValue}>
        {children}
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}
```

### Provider with Reducer

```jsx
// Complex state management with useReducer
const initialState = {
  user: null,
  loading: false,
  error: null,
  preferences: {
    theme: 'light',
    language: 'en',
    notifications: true
  }
};

function userReducer(state, action) {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, loading: true, error: null };
    
    case 'LOGIN_SUCCESS':
      return { 
        ...state, 
        loading: false, 
        user: action.payload,
        error: null 
      };
    
    case 'LOGIN_ERROR':
      return { 
        ...state, 
        loading: false, 
        error: action.payload 
      };
    
    case 'LOGOUT':
      return { 
        ...state, 
        user: null, 
        error: null 
      };
    
    case 'UPDATE_PREFERENCES':
      return {
        ...state,
        preferences: { ...state.preferences, ...action.payload }
      };
    
    case 'CLEAR_ERROR':
      return { ...state, error: null };
    
    default:
      return state;
  }
}

function UserProvider({ children }) {
  const [state, dispatch] = useReducer(userReducer, initialState);
  
  const login = async (email, password) => {
    dispatch({ type: 'LOGIN_START' });
    
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        throw new Error('Invalid credentials');
      }
      
      const user = await response.json();
      dispatch({ type: 'LOGIN_SUCCESS', payload: user });
    } catch (error) {
      dispatch({ type: 'LOGIN_ERROR', payload: error.message });
    }
  };
  
  const logout = () => {
    dispatch({ type: 'LOGOUT' });
    localStorage.removeItem('token');
  };
  
  const updatePreferences = (preferences) => {
    dispatch({ type: 'UPDATE_PREFERENCES', payload: preferences });
  };
  
  const clearError = () => {
    dispatch({ type: 'CLEAR_ERROR' });
  };
  
  const value = useMemo(() => ({
    ...state,
    login,
    logout,
    updatePreferences,
    clearError
  }), [state]);
  
  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}
```

### Dynamic Provider Values

```jsx
// Provider that adapts to props
function ConfigurableThemeProvider({ children, defaultTheme = 'light' }) {
  const [theme, setTheme] = useState(defaultTheme);
  const [colors, setColors] = useState({
    primary: '#007bff',
    secondary: '#6c757d',
    success: '#28a745',
    danger: '#dc3545'
  });
  
  useEffect(() => {
    // Apply theme to document
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);
  
  const updateTheme = (newTheme) => {
    setTheme(newTheme);
    localStorage.setItem('theme', newTheme);
  };
  
  const updateColors = (newColors) => {
    setColors(prev => ({ ...prev, ...newColors }));
  };
  
  const value = useMemo(() => ({
    theme,
    colors,
    updateTheme,
    updateColors,
    isDark: theme === 'dark',
    isLight: theme === 'light'
  }), [theme, colors]);
  
  return (
    <ThemeContext.Provider value={value}>
      <div className={`app-theme-${theme}`} style={colors}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
}

// Usage with different configurations
function App() {
  return (
    <div>
      <ConfigurableThemeProvider defaultTheme="dark">
        <AdminPanel />
      </ConfigurableThemeProvider>
      
      <ConfigurableThemeProvider defaultTheme="light">
        <UserDashboard />
      </ConfigurableThemeProvider>
    </div>
  );
}
```

## 7.4 The useContext Hook

The `useContext` hook allows components to consume context values directly, eliminating the need for prop drilling.

### Basic useContext Usage

```jsx
import React, { useContext } from 'react';

// Consumer component using useContext
function UserProfile() {
  const { user, updateProfile } = useContext(UserContext);
  
  if (!user) {
    return <div>Please log in to view your profile</div>;
  }
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={() => updateProfile({ name: 'New Name' })}>
        Update Profile
      </button>
    </div>
  );
}

// Theme consumer
function ThemeToggle() {
  const { theme, toggleTheme } = useContext(ThemeContext);
  
  return (
    <button onClick={toggleTheme}>
      Switch to {theme === 'light' ? 'dark' : 'light'} mode
    </button>
  );
}
```

### Custom Hook Pattern

```jsx
// Custom hook to encapsulate context logic
function useUser() {
  const context = useContext(UserContext);
  
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  
  return context;
}

// Usage becomes cleaner
function UserProfile() {
  const { user, updateProfile, loading, error } = useUser();
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>Please log in</div>;
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={() => updateProfile({ name: 'New Name' })}>
        Update Profile
      </button>
    </div>
  );
}
```

### Advanced Custom Hooks

```jsx
// Hook with additional logic
function useAuth() {
  const context = useContext(UserContext);
  
  if (context === undefined) {
    throw new Error('useAuth must be used within a UserProvider');
  }
  
  const { user, login, logout, loading, error } = context;
  
  // Additional computed values
  const isLoggedIn = !!user;
  const isAdmin = user?.role === 'admin';
  const hasPermission = (permission) => {
    return user?.permissions?.includes(permission) || false;
  };
  
  // Additional methods
  const loginWithRedirect = async (email, password, redirectTo = '/dashboard') => {
    await login(email, password);
    if (!error) {
      window.location.href = redirectTo;
    }
  };
  
  return {
    user,
    login: loginWithRedirect,
    logout,
    loading,
    error,
    isLoggedIn,
    isAdmin,
    hasPermission
  };
}

// Specialized hooks for different use cases
function useUserProfile() {
  const { user, updateProfile, loading } = useUser();
  
  const updateName = (name) => updateProfile({ name });
  const updateEmail = (email) => updateProfile({ email });
  const updateAvatar = (avatar) => updateProfile({ avatar });
  
  return {
    user,
    loading,
    updateName,
    updateEmail,
    updateAvatar
  };
}

function useUserPreferences() {
  const { user, updateProfile } = useUser();
  
  const preferences = user?.preferences || {};
  
  const updatePreference = (key, value) => {
    updateProfile({
      preferences: { ...preferences, [key]: value }
    });
  };
  
  const toggleNotifications = () => {
    updatePreference('notifications', !preferences.notifications);
  };
  
  const changeTheme = (theme) => {
    updatePreference('theme', theme);
  };
  
  return {
    preferences,
    updatePreference,
    toggleNotifications,
    changeTheme
  };
}
```

### Context Composition Patterns

```jsx
// Multiple contexts in one component
function Dashboard() {
  const { user, isLoggedIn } = useUser();
  const { theme, colors } = useTheme();
  const { language, translate } = useLanguage();
  const { cart, addToCart } = useCart();
  
  if (!isLoggedIn) {
    return <LoginPrompt />;
  }
  
  return (
    <div 
      className={`dashboard theme-${theme}`}
      style={{ backgroundColor: colors.background }}
    >
      <h1>{translate('welcome', { name: user.name })}</h1>
      <CartSummary items={cart.length} />
      <ProductGrid onAddToCart={addToCart} />
    </div>
  );
}

// Conditional context usage
function ConditionalContextUsage() {
  // Only use context if available
  const themeContext = useContext(ThemeContext);
  const theme = themeContext?.theme || 'light';
  
  return (
    <div className={`component theme-${theme}`}>
      {themeContext ? (
        <ThemeToggle />
      ) : (
        <span>Theme not available</span>
      )}
    </div>
  );
}
```

### Performance Optimizations

```jsx
// Memoize expensive context consumers
const ExpensiveComponent = memo(function ExpensiveComponent() {
  const { user } = useUser();
  
  const expensiveCalculation = useMemo(() => {
    return performHeavyCalculation(user.data);
  }, [user.data]);
  
  return <div>{expensiveCalculation}</div>;
});

// Split contexts to minimize re-renders
function useUserBasicInfo() {
  const { user } = useUser();
  
  return useMemo(() => ({
    id: user?.id,
    name: user?.name,
    email: user?.email
  }), [user?.id, user?.name, user?.email]);
}

function useUserPreferences() {
  const { user } = useUser();
  
  return useMemo(() => user?.preferences, [user?.preferences]);
}

// Context selector pattern
function createContextSelector(context) {
  return function useContextSelector(selector) {
    const value = useContext(context);
    return useMemo(() => selector(value), [value, selector]);
  };
}

const useUserSelector = createContextSelector(UserContext);

// Usage
function UserName() {
  const name = useUserSelector(state => state.user?.name);
  return <span>{name}</span>;
}
```

### Error Boundaries with Context

```jsx
class ContextErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Context error:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong with the context</h2>
          <details>
            {this.state.error && this.state.error.toString()}
          </details>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ContextErrorBoundary>
      <UserProvider>
        <ThemeProvider>
          <Dashboard />
        </ThemeProvider>
      </UserProvider>
    </ContextErrorBoundary>
  );
}
```

## 7.5 Typing Context

TypeScript provides excellent support for strongly typing contexts, ensuring type safety and better developer experience.

### Basic Context Typing

```tsx
// Define the shape of your context value
interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'moderator';
  avatar?: string;
  createdAt: Date;
}

interface UserContextType {
  user: User | null;
  loading: boolean;
  error: string | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  updateProfile: (updates: Partial<User>) => Promise<void>;
  refreshUser: () => Promise<void>;
}

// Create typed context
const UserContext = createContext<UserContextType | undefined>(undefined);
```

### Typed Custom Hooks

```tsx
// Type-safe custom hook
function useUser(): UserContextType {
  const context = useContext(UserContext);
  
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  
  return context;
}

// Optional context hook
function useOptionalUser(): UserContextType | undefined {
  return useContext(UserContext);
}

// Hook with default values
function useUserWithDefaults(): UserContextType {
  const context = useContext(UserContext);
  
  if (context === undefined) {
    // Return default values instead of throwing
    return {
      user: null,
      loading: false,
      error: null,
      login: async () => {},
      logout: () => {},
      updateProfile: async () => {},
      refreshUser: async () => {}
    };
  }
  
  return context;
}
```

### Advanced Type Patterns

```tsx
// Generic context creator
function createTypedContext<T>() {
  const context = createContext<T | undefined>(undefined);
  
  function useTypedContext(): T {
    const contextValue = useContext(context);
    if (contextValue === undefined) {
      throw new Error('useTypedContext must be used within a Provider');
    }
    return contextValue;
  }
  
  return [useTypedContext, context.Provider] as const;
}

// Usage
interface ThemeContextType {
  theme: 'light' | 'dark';
  colors: {
    primary: string;
    secondary: string;
    background: string;
  };
  toggleTheme: () => void;
}

const [useTheme, ThemeProvider] = createTypedContext<ThemeContextType>();

// Now useTheme is automatically typed!
```

### Complex State Typing

```tsx
// Complex application state
interface AppState {
  auth: {
    user: User | null;
    token: string | null;
    isAuthenticated: boolean;
    permissions: string[];
  };
  ui: {
    theme: 'light' | 'dark' | 'auto';
    sidebar: {
      isOpen: boolean;
      width: number;
    };
    notifications: {
      enabled: boolean;
      position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    };
  };
  data: {
    products: Product[];
    cart: CartItem[];
    wishlist: Product[];
    orders: Order[];
  };
}

// Action types for reducer
type AppAction =
  | { type: 'AUTH_LOGIN'; payload: { user: User; token: string } }
  | { type: 'AUTH_LOGOUT' }
  | { type: 'UI_TOGGLE_THEME' }
  | { type: 'UI_TOGGLE_SIDEBAR' }
  | { type: 'UI_SET_SIDEBAR_WIDTH'; payload: number }
  | { type: 'DATA_ADD_TO_CART'; payload: CartItem }
  | { type: 'DATA_REMOVE_FROM_CART'; payload: string }
  | { type: 'DATA_CLEAR_CART' };

// Context type with actions
interface AppContextType {
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
  // Computed values
  isLoggedIn: boolean;
  cartTotal: number;
  cartItemCount: number;
  // Action creators
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  addToCart: (product: Product, quantity: number) => void;
  removeFromCart: (productId: string) => void;
  toggleTheme: () => void;
}

const AppContext = createContext<AppContextType | undefined>(undefined);
```

### Provider Component Typing

```tsx
// Typed provider component
interface UserProviderProps {
  children: React.ReactNode;
  initialUser?: User | null;
  apiEndpoint?: string;
}

function UserProvider({ 
  children, 
  initialUser = null, 
  apiEndpoint = '/api' 
}: UserProviderProps) {
  const [user, setUser] = useState<User | null>(initialUser);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const login = useCallback(async (email: string, password: string): Promise<void> => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetch(`${apiEndpoint}/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        throw new Error(`Login failed: ${response.status}`);
      }
      
      const userData: User = await response.json();
      setUser(userData);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Login failed';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [apiEndpoint]);
  
  const logout = useCallback((): void => {
    setUser(null);
    setError(null);
  }, []);
  
  const updateProfile = useCallback(async (updates: Partial<User>): Promise<void> => {
    if (!user) throw new Error('No user logged in');
    
    setLoading(true);
    
    try {
      const response = await fetch(`${apiEndpoint}/user/${user.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) {
        throw new Error(`Update failed: ${response.status}`);
      }
      
      const updatedUser: User = await response.json();
      setUser(updatedUser);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Update failed';
      setError(errorMessage);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [user, apiEndpoint]);
  
  const refreshUser = useCallback(async (): Promise<void> => {
    if (!user) return;
    
    setLoading(true);
    
    try {
      const response = await fetch(`${apiEndpoint}/user/${user.id}`);
      
      if (!response.ok) {
        throw new Error(`Refresh failed: ${response.status}`);
      }
      
      const refreshedUser: User = await response.json();
      setUser(refreshedUser);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Refresh failed';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  }, [user, apiEndpoint]);
  
  const value: UserContextType = useMemo(() => ({
    user,
    loading,
    error,
    login,
    logout,
    updateProfile,
    refreshUser
  }), [user, loading, error, login, logout, updateProfile, refreshUser]);
  
  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}
```

### Type Guards and Utilities

```tsx
// Type guard for user
function isUser(user: any): user is User {
  return (
    user &&
    typeof user.id === 'number' &&
    typeof user.name === 'string' &&
    typeof user.email === 'string' &&
    ['admin', 'user', 'moderator'].includes(user.role)
  );
}

// Context value validator
function validateUserContext(context: any): context is UserContextType {
  return (
    context &&
    (context.user === null || isUser(context.user)) &&
    typeof context.loading === 'boolean' &&
    (context.error === null || typeof context.error === 'string') &&
    typeof context.login === 'function' &&
    typeof context.logout === 'function' &&
    typeof context.updateProfile === 'function' &&
    typeof context.refreshUser === 'function'
  );
}

// Safe context hook with validation
function useSafeUser(): UserContextType {
  const context = useContext(UserContext);
  
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  
  if (!validateUserContext(context)) {
    throw new Error('Invalid UserContext value');
  }
  
  return context;
}
```

### Discriminated Union Types for Actions

```tsx
// Base action interface
interface BaseAction {
  type: string;
  timestamp?: Date;
  meta?: Record<string, unknown>;
}

// Specific action types
interface LoginAction extends BaseAction {
  type: 'LOGIN_SUCCESS';
  payload: {
    user: User;
    token: string;
    expiresAt: Date;
  };
}

interface LoginErrorAction extends BaseAction {
  type: 'LOGIN_ERROR';
  payload: {
    error: string;
    code?: string;
  };
}

interface LogoutAction extends BaseAction {
  type: 'LOGOUT';
  payload?: {
    reason: 'user_initiated' | 'token_expired' | 'security';
  };
}

interface UpdateProfileAction extends BaseAction {
  type: 'UPDATE_PROFILE';
  payload: {
    userId: number;
    updates: Partial<User>;
  };
}

// Union type for all actions
type UserAction = 
  | LoginAction 
  | LoginErrorAction 
  | LogoutAction 
  | UpdateProfileAction;

// Typed reducer
function userReducer(state: UserState, action: UserAction): UserState {
  switch (action.type) {
    case 'LOGIN_SUCCESS':
      // TypeScript knows this is LoginAction
      return {
        ...state,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: true,
        error: null
      };
    
    case 'LOGIN_ERROR':
      // TypeScript knows this is LoginErrorAction
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
        error: action.payload.error
      };
    
    case 'LOGOUT':
      // TypeScript knows this is LogoutAction
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
        error: null
      };
    
    case 'UPDATE_PROFILE':
      // TypeScript knows this is UpdateProfileAction
      if (!state.user || state.user.id !== action.payload.userId) {
        return state;
      }
      
      return {
        ...state,
        user: { ...state.user, ...action.payload.updates }
      };
    
    default:
      // TypeScript ensures we handle all cases
      const exhaustiveCheck: never = action;
      return state;
  }
}
```

## Real-World Example: E-commerce Context

```tsx
// Complete typed e-commerce context example
interface Product {
  id: string;
  name: string;
  price: number;
  image: string;
  category: string;
  inStock: boolean;
}

interface CartItem {
  product: Product;
  quantity: number;
}

interface Order {
  id: string;
  items: CartItem[];
  total: number;
  status: 'pending' | 'processing' | 'shipped' | 'delivered';
  createdAt: Date;
}

interface ECommerceState {
  products: Product[];
  cart: CartItem[];
  orders: Order[];
  loading: {
    products: boolean;
    cart: boolean;
    orders: boolean;
  };
  error: {
    products: string | null;
    cart: string | null;
    orders: string | null;
  };
}

interface ECommerceContextType {
  state: ECommerceState;
  // Product actions
  loadProducts: () => Promise<void>;
  searchProducts: (query: string) => Product[];
  // Cart actions
  addToCart: (product: Product, quantity: number) => void;
  removeFromCart: (productId: string) => void;
  updateCartQuantity: (productId: string, quantity: number) => void;
  clearCart: () => void;
  // Order actions
  createOrder: () => Promise<Order>;
  loadOrders: () => Promise<void>;
  // Computed values
  cartTotal: number;
  cartItemCount: number;
  isProductInCart: (productId: string) => boolean;
}

const ECommerceContext = createContext<ECommerceContextType | undefined>(undefined);

export function useECommerce(): ECommerceContextType {
  const context = useContext(ECommerceContext);
  if (context === undefined) {
    throw new Error('useECommerce must be used within an ECommerceProvider');
  }
  return context;
}

export function ECommerceProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState<ECommerceState>({
    products: [],
    cart: [],
    orders: [],
    loading: { products: false, cart: false, orders: false },
    error: { products: null, cart: null, orders: null }
  });
  
  // Implementation details...
  const value: ECommerceContextType = useMemo(() => ({
    state,
    loadProducts,
    searchProducts,
    addToCart,
    removeFromCart,
    updateCartQuantity,
    clearCart,
    createOrder,
    loadOrders,
    cartTotal,
    cartItemCount,
    isProductInCart
  }), [state]);
  
  return (
    <ECommerceContext.Provider value={value}>
      {children}
    </ECommerceContext.Provider>
  );
}
```

## Summary

Context API and useContext provide powerful solutions for prop drilling problems:

### Key Benefits:
- ✅ **Eliminates prop drilling** - Direct access to shared data
- ✅ **Clean component interfaces** - Components only receive props they need
- ✅ **Improved maintainability** - Easier to add/remove shared data
- ✅ **Better performance** - Avoid unnecessary re-renders in intermediate components
- ✅ **Type safety** - Strong TypeScript integration

### Best Practices:
- Create focused contexts for specific concerns
- Use custom hooks to encapsulate context logic
- Memoize provider values to prevent unnecessary re-renders
- Implement proper error boundaries
- Use TypeScript for better developer experience
- Split large contexts into smaller, more focused ones

### When to Use Context:
- ✅ Theme and styling data
- ✅ User authentication state
- ✅ Application settings and preferences
- ✅ Shopping cart data
- ✅ Language/localization
- ❌ Frequently changing data (consider state management libraries)
- ❌ Server state (consider React Query/SWR)

**Next Steps**: Learn about advanced state management patterns, custom hooks for complex logic, and performance optimization techniques!