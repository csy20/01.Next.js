# React useState: Managing Component State

## 3.1 What is State?

State is **data that belongs to a component and can change over time**. When state changes, React automatically re-renders the component to reflect those changes in the UI. Think of state as the component's "memory" - it remembers information between renders.

### State vs Props: The Key Difference

```jsx
// Props: Data passed FROM parent TO child (read-only)
function UserCard({ name, email }) {  // Props from parent
  return (
    <div>
      <h3>{name}</h3>
      <p>{email}</p>
    </div>
  );
}

// State: Data that belongs TO the component (can change)
function Counter() {
  const [count, setCount] = useState(0);  // State owned by this component
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

### Why State Matters

Without state, your components would be static - they couldn't respond to user interactions, API responses, or any changes over time.

```jsx
// ‚ùå Without state - static, unchanging
function StaticComponent() {
  let count = 0;  // This won't trigger re-renders!
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => count++}>  {/* This won't work! */}
        Increment
      </button>
    </div>
  );
}

// ‚úÖ With state - dynamic, reactive
function DynamicComponent() {
  const [count, setCount] = useState(0);  // React manages this!
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>  {/* This works! */}
        Increment
      </button>
    </div>
  );
}
```

### The State Update Cycle

```
User Interaction ‚Üí State Update ‚Üí Re-render ‚Üí UI Update
       ‚Üë                                           ‚Üì
       ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ User sees updated UI ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

## 3.2 The useState Hook

The `useState` hook is the most fundamental React Hook. It allows functional components to have state.

### Basic Syntax

```jsx
import React, { useState } from 'react';

function MyComponent() {
  // useState returns an array with two elements:
  // 1. Current state value
  // 2. Function to update the state
  const [stateName, setStateName] = useState(initialValue);
  
  return (
    // Your JSX here
  );
}
```

### Array Destructuring Explanation

```jsx
// What useState actually returns:
const stateArray = useState(0);
const currentValue = stateArray[0];  // 0
const updateFunction = stateArray[1];  // function

// But we use array destructuring for cleaner code:
const [count, setCount] = useState(0);
// This is equivalent to the above, but much cleaner!
```

### Simple Examples

#### 1. Counter Component

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(0);
  
  return (
    <div className="counter">
      <h2>Count: {count}</h2>
      <div className="buttons">
        <button onClick={decrement}>-</button>
        <button onClick={reset}>Reset</button>
        <button onClick={increment}>+</button>
      </div>
    </div>
  );
}
```

#### 2. Toggle Component

```jsx
function ToggleSwitch() {
  const [isOn, setIsOn] = useState(false);
  
  const toggle = () => setIsOn(!isOn);
  
  return (
    <div className={`toggle-switch ${isOn ? 'on' : 'off'}`}>
      <button onClick={toggle}>
        {isOn ? 'üü¢ ON' : 'üî¥ OFF'}
      </button>
      <p>The switch is {isOn ? 'ON' : 'OFF'}</p>
    </div>
  );
}
```

#### 3. Text Input Component

```jsx
function TextInput() {
  const [text, setText] = useState('');
  
  const handleChange = (event) => {
    setText(event.target.value);
  };
  
  const clearText = () => setText('');
  
  return (
    <div>
      <input 
        type="text" 
        value={text} 
        onChange={handleChange}
        placeholder="Type something..."
      />
      <button onClick={clearText}>Clear</button>
      <p>You typed: {text}</p>
      <p>Character count: {text.length}</p>
    </div>
  );
}
```

### Multiple State Variables

```jsx
function UserProfile() {
  // Each piece of state is independent
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [isEditing, setIsEditing] = useState(false);
  
  const handleSave = () => {
    console.log('Saving:', { name, email, age });
    setIsEditing(false);
  };
  
  if (isEditing) {
    return (
      <form>
        <div>
          <label>Name:</label>
          <input 
            value={name} 
            onChange={(e) => setName(e.target.value)} 
          />
        </div>
        <div>
          <label>Email:</label>
          <input 
            value={email} 
            onChange={(e) => setEmail(e.target.value)} 
          />
        </div>
        <div>
          <label>Age:</label>
          <input 
            type="number"
            value={age} 
            onChange={(e) => setAge(parseInt(e.target.value) || 0)} 
          />
        </div>
        <button type="button" onClick={handleSave}>Save</button>
        <button type="button" onClick={() => setIsEditing(false)}>Cancel</button>
      </form>
    );
  }
  
  return (
    <div>
      <h2>{name || 'No name set'}</h2>
      <p>Email: {email || 'No email set'}</p>
      <p>Age: {age}</p>
      <button onClick={() => setIsEditing(true)}>Edit</button>
    </div>
  );
}
```

### State with Objects

```jsx
function UserForm() {
  // Single state object instead of multiple state variables
  const [user, setUser] = useState({
    name: '',
    email: '',
    preferences: {
      theme: 'light',
      notifications: true
    }
  });
  
  // Helper function to update nested properties
  const updateUser = (field, value) => {
    setUser(prevUser => ({
      ...prevUser,  // Spread existing properties
      [field]: value  // Update specific field
    }));
  };
  
  const updatePreference = (prefKey, value) => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        [prefKey]: value
      }
    }));
  };
  
  return (
    <div>
      <h2>User Settings</h2>
      
      <div>
        <label>Name:</label>
        <input 
          value={user.name}
          onChange={(e) => updateUser('name', e.target.value)}
        />
      </div>
      
      <div>
        <label>Email:</label>
        <input 
          value={user.email}
          onChange={(e) => updateUser('email', e.target.value)}
        />
      </div>
      
      <div>
        <label>Theme:</label>
        <select 
          value={user.preferences.theme}
          onChange={(e) => updatePreference('theme', e.target.value)}
        >
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
      
      <div>
        <label>
          <input 
            type="checkbox"
            checked={user.preferences.notifications}
            onChange={(e) => updatePreference('notifications', e.target.checked)}
          />
          Enable notifications
        </label>
      </div>
      
      <div className="preview">
        <h3>Current Settings:</h3>
        <pre>{JSON.stringify(user, null, 2)}</pre>
      </div>
    </div>
  );
}
```

### State with Arrays

```jsx
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [inputValue, setInputValue] = useState('');
  
  const addTodo = () => {
    if (inputValue.trim()) {
      const newTodo = {
        id: Date.now(),  // Simple ID generation
        text: inputValue.trim(),
        completed: false
      };
      
      setTodos(prevTodos => [...prevTodos, newTodo]);  // Add to end
      setInputValue('');  // Clear input
    }
  };
  
  const toggleTodo = (id) => {
    setTodos(prevTodos => 
      prevTodos.map(todo => 
        todo.id === id 
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };
  
  const deleteTodo = (id) => {
    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));
  };
  
  const clearCompleted = () => {
    setTodos(prevTodos => prevTodos.filter(todo => !todo.completed));
  };
  
  return (
    <div className="todo-list">
      <div className="add-todo">
        <input 
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && addTodo()}
          placeholder="Add a new todo..."
        />
        <button onClick={addTodo}>Add</button>
      </div>
      
      <div className="stats">
        <p>Total: {todos.length}</p>
        <p>Completed: {todos.filter(t => t.completed).length}</p>
        <p>Remaining: {todos.filter(t => !t.completed).length}</p>
        <button onClick={clearCompleted}>Clear Completed</button>
      </div>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id} className={todo.completed ? 'completed' : ''}>
            <span 
              onClick={() => toggleTodo(todo.id)}
              style={{ 
                textDecoration: todo.completed ? 'line-through' : 'none',
                cursor: 'pointer'
              }}
            >
              {todo.text}
            </span>
            <button onClick={() => deleteTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## 3.3 Typing useState with TypeScript

TypeScript can often infer the type of your state automatically, but sometimes you need to be explicit.

### Automatic Type Inference

```tsx
// TypeScript automatically infers these types:
const [count, setCount] = useState(0);           // number
const [name, setName] = useState('');            // string
const [isVisible, setIsVisible] = useState(true); // boolean
const [items, setItems] = useState([]);          // never[] (empty array)
```

### Explicit Type Annotations

```tsx
// When TypeScript can't infer or you want to be specific:

// 1. Primitive types (usually not needed)
const [count, setCount] = useState<number>(0);
const [name, setName] = useState<string>('');

// 2. Array types
const [numbers, setNumbers] = useState<number[]>([]);
const [names, setNames] = useState<string[]>([]);

// 3. Union types
const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');

// 4. Object types
interface User {
  id: number;
  name: string;
  email: string;
}

const [user, setUser] = useState<User | null>(null);  // Important: null initially

// 5. Complex nested types
interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  settings: {
    notifications: boolean;
    language: string;
  };
}

const [appState, setAppState] = useState<AppState>({
  user: null,
  theme: 'light',
  settings: {
    notifications: true,
    language: 'en'
  }
});
```

### Real-World TypeScript Examples

#### 1. User Authentication State

```tsx
interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'moderator';
  avatar?: string;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}

function AuthComponent() {
  const [authState, setAuthState] = useState<AuthState>({
    user: null,
    isLoading: false,
    error: null
  });
  
  const login = async (email: string, password: string) => {
    setAuthState(prev => ({ ...prev, isLoading: true, error: null }));
    
    try {
      const user = await authenticateUser(email, password);
      setAuthState({
        user,
        isLoading: false,
        error: null
      });
    } catch (error) {
      setAuthState({
        user: null,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Login failed'
      });
    }
  };
  
  const logout = () => {
    setAuthState({
      user: null,
      isLoading: false,
      error: null
    });
  };
  
  if (authState.isLoading) {
    return <div>Logging in...</div>;
  }
  
  if (authState.error) {
    return <div className="error">Error: {authState.error}</div>;
  }
  
  if (!authState.user) {
    return (
      <LoginForm onLogin={login} />
    );
  }
  
  return (
    <div>
      <h2>Welcome, {authState.user.name}!</h2>
      <p>Role: {authState.user.role}</p>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

#### 2. Form State with Validation

```tsx
interface FormData {
  email: string;
  password: string;
  confirmPassword: string;
}

interface FormErrors {
  email?: string;
  password?: string;
  confirmPassword?: string;
}

function RegistrationForm() {
  const [formData, setFormData] = useState<FormData>({
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  const [errors, setErrors] = useState<FormErrors>({});
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  
  const updateField = (field: keyof FormData, value: string) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
    
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: undefined
      }));
    }
  };
  
  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};
    
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }
    
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    setIsSubmitting(true);
    try {
      await registerUser(formData);
      // Handle success
    } catch (error) {
      setErrors({ 
        email: error instanceof Error ? error.message : 'Registration failed' 
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="email"
          value={formData.email}
          onChange={(e) => updateField('email', e.target.value)}
          placeholder="Email"
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>
      
      <div>
        <input
          type="password"
          value={formData.password}
          onChange={(e) => updateField('password', e.target.value)}
          placeholder="Password"
        />
        {errors.password && <span className="error">{errors.password}</span>}
      </div>
      
      <div>
        <input
          type="password"
          value={formData.confirmPassword}
          onChange={(e) => updateField('confirmPassword', e.target.value)}
          placeholder="Confirm Password"
        />
        {errors.confirmPassword && <span className="error">{errors.confirmPassword}</span>}
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Registering...' : 'Register'}
      </button>
    </form>
  );
}
```

#### 3. API Data Fetching State

```tsx
interface ApiResponse<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

interface Product {
  id: string;
  name: string;
  price: number;
  description: string;
  inStock: boolean;
}

function ProductList() {
  const [productsState, setProductsState] = useState<ApiResponse<Product[]>>({
    data: null,
    loading: true,
    error: null
  });
  
  const [filters, setFilters] = useState<{
    category: string;
    priceRange: [number, number];
    inStockOnly: boolean;
  }>({
    category: 'all',
    priceRange: [0, 1000],
    inStockOnly: false
  });
  
  useEffect(() => {
    fetchProducts();
  }, [filters]);
  
  const fetchProducts = async () => {
    setProductsState(prev => ({ ...prev, loading: true }));
    
    try {
      const products = await api.getProducts(filters);
      setProductsState({
        data: products,
        loading: false,
        error: null
      });
    } catch (error) {
      setProductsState({
        data: null,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to fetch products'
      });
    }
  };
  
  const updateFilter = <K extends keyof typeof filters>(
    key: K, 
    value: typeof filters[K]
  ) => {
    setFilters(prev => ({
      ...prev,
      [key]: value
    }));
  };
  
  if (productsState.loading) {
    return <div>Loading products...</div>;
  }
  
  if (productsState.error) {
    return <div className="error">Error: {productsState.error}</div>;
  }
  
  return (
    <div>
      <div className="filters">
        <select 
          value={filters.category}
          onChange={(e) => updateFilter('category', e.target.value)}
        >
          <option value="all">All Categories</option>
          <option value="electronics">Electronics</option>
          <option value="clothing">Clothing</option>
        </select>
        
        <label>
          <input
            type="checkbox"
            checked={filters.inStockOnly}
            onChange={(e) => updateFilter('inStockOnly', e.target.checked)}
          />
          In stock only
        </label>
      </div>
      
      <div className="products">
        {productsState.data?.map(product => (
          <div key={product.id} className="product-card">
            <h3>{product.name}</h3>
            <p>${product.price}</p>
            <p>{product.description}</p>
            <p>Status: {product.inStock ? 'In Stock' : 'Out of Stock'}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

## 3.4 Functional Updates

Functional updates are crucial when your new state depends on the previous state. They ensure you always work with the most current state value.

### The Problem with Direct Updates

```jsx
function BadCounter() {
  const [count, setCount] = useState(0);
  
  // ‚ùå Problem: Multiple rapid clicks might not work as expected
  const handleMultipleIncrements = () => {
    setCount(count + 1);  // count is 0, sets to 1
    setCount(count + 1);  // count is still 0 here, sets to 1
    setCount(count + 1);  // count is still 0 here, sets to 1
    // Result: count becomes 1, not 3!
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleMultipleIncrements}>+3 (Broken)</button>
    </div>
  );
}
```

### The Solution: Functional Updates

```jsx
function GoodCounter() {
  const [count, setCount] = useState(0);
  
  // ‚úÖ Solution: Use functional updates
  const handleMultipleIncrements = () => {
    setCount(prevCount => prevCount + 1);  // prevCount is 0, returns 1
    setCount(prevCount => prevCount + 1);  // prevCount is 1, returns 2
    setCount(prevCount => prevCount + 1);  // prevCount is 2, returns 3
    // Result: count becomes 3!
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleMultipleIncrements}>+3 (Working)</button>
    </div>
  );
}
```

### When to Use Functional Updates

#### 1. When State Depends on Previous Value

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  // ‚úÖ Use functional update for increment/decrement
  const increment = () => setCount(prev => prev + 1);
  const decrement = () => setCount(prev => prev - 1);
  const double = () => setCount(prev => prev * 2);
  const reset = () => setCount(0);  // Direct update is fine here
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={double}>√ó2</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

#### 2. Working with Objects

```jsx
function UserProfile() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: 0
  });
  
  // ‚úÖ Functional update to merge with existing state
  const updateUserField = (field, value) => {
    setUser(prevUser => ({
      ...prevUser,
      [field]: value
    }));
  };
  
  // ‚úÖ More complex updates
  const incrementAge = () => {
    setUser(prevUser => ({
      ...prevUser,
      age: prevUser.age + 1
    }));
  };
  
  return (
    <div>
      <input 
        value={user.name}
        onChange={(e) => updateUserField('name', e.target.value)}
        placeholder="Name"
      />
      <input 
        value={user.email}
        onChange={(e) => updateUserField('email', e.target.value)}
        placeholder="Email"
      />
      <p>Age: {user.age}</p>
      <button onClick={incrementAge}>Age +1</button>
    </div>
  );
}
```

#### 3. Working with Arrays

```jsx
function ShoppingCart() {
  const [items, setItems] = useState([]);
  
  const addItem = (newItem) => {
    setItems(prevItems => [...prevItems, newItem]);
  };
  
  const removeItem = (itemId) => {
    setItems(prevItems => prevItems.filter(item => item.id !== itemId));
  };
  
  const updateQuantity = (itemId, newQuantity) => {
    setItems(prevItems =>
      prevItems.map(item =>
        item.id === itemId
          ? { ...item, quantity: newQuantity }
          : item
      )
    );
  };
  
  const clearCart = () => {
    setItems([]);  // Direct update is fine here
  };
  
  return (
    <div>
      <button onClick={() => addItem({ 
        id: Date.now(), 
        name: 'New Item', 
        quantity: 1 
      })}>
        Add Item
      </button>
      
      <ul>
        {items.map(item => (
          <li key={item.id}>
            {item.name} - Quantity: {item.quantity}
            <button onClick={() => updateQuantity(item.id, item.quantity + 1)}>
              +
            </button>
            <button onClick={() => updateQuantity(item.id, item.quantity - 1)}>
              -
            </button>
            <button onClick={() => removeItem(item.id)}>
              Remove
            </button>
          </li>
        ))}
      </ul>
      
      <button onClick={clearCart}>Clear Cart</button>
    </div>
  );
}
```

### Async Operations and State Updates

```jsx
function AsyncCounter() {
  const [count, setCount] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  
  // ‚ùå Potential issue with stale closure
  const incrementAfterDelay = async () => {
    setIsLoading(true);
    await new Promise(resolve => setTimeout(resolve, 1000));
    setCount(count + 1);  // 'count' might be stale here!
    setIsLoading(false);
  };
  
  // ‚úÖ Better approach with functional update
  const incrementAfterDelayCorrect = async () => {
    setIsLoading(true);
    await new Promise(resolve => setTimeout(resolve, 1000));
    setCount(prevCount => prevCount + 1);  // Always uses current value
    setIsLoading(false);
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button 
        onClick={incrementAfterDelayCorrect} 
        disabled={isLoading}
      >
        {isLoading ? 'Loading...' : 'Increment after 1s'}
      </button>
    </div>
  );
}
```

### Complex State Updates with TypeScript

```tsx
interface TodoState {
  todos: Array<{
    id: string;
    text: string;
    completed: boolean;
    priority: 'low' | 'medium' | 'high';
  }>;
  filter: 'all' | 'active' | 'completed';
  sortBy: 'date' | 'priority' | 'alphabetical';
}

function TodoApp() {
  const [state, setState] = useState<TodoState>({
    todos: [],
    filter: 'all',
    sortBy: 'date'
  });
  
  // Add todo with functional update
  const addTodo = (text: string, priority: TodoState['todos'][0]['priority']) => {
    setState(prevState => ({
      ...prevState,
      todos: [
        ...prevState.todos,
        {
          id: crypto.randomUUID(),
          text,
          completed: false,
          priority
        }
      ]
    }));
  };
  
  // Toggle todo completion
  const toggleTodo = (id: string) => {
    setState(prevState => ({
      ...prevState,
      todos: prevState.todos.map(todo =>
        todo.id === id
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    }));
  };
  
  // Update filter
  const setFilter = (filter: TodoState['filter']) => {
    setState(prevState => ({
      ...prevState,
      filter
    }));
  };
  
  // Bulk operations
  const markAllCompleted = () => {
    setState(prevState => ({
      ...prevState,
      todos: prevState.todos.map(todo => ({
        ...todo,
        completed: true
      }))
    }));
  };
  
  const clearCompleted = () => {
    setState(prevState => ({
      ...prevState,
      todos: prevState.todos.filter(todo => !todo.completed)
    }));
  };
  
  return (
    <div>
      {/* Component implementation */}
    </div>
  );
}
```

## Common useState Patterns and Best Practices

### 1. State Normalization

```tsx
// ‚ùå Denormalized state - hard to update
interface BadState {
  users: Array<{
    id: string;
    name: string;
    posts: Array<{
      id: string;
      title: string;
      authorId: string;
    }>;
  }>;
}

// ‚úÖ Normalized state - easier to update
interface GoodState {
  users: Record<string, { id: string; name: string }>;
  posts: Record<string, { id: string; title: string; authorId: string }>;
  userPosts: Record<string, string[]>; // userId -> postIds
}

function useNormalizedState() {
  const [state, setState] = useState<GoodState>({
    users: {},
    posts: {},
    userPosts: {}
  });
  
  const addPost = (post: GoodState['posts'][string]) => {
    setState(prevState => ({
      ...prevState,
      posts: {
        ...prevState.posts,
        [post.id]: post
      },
      userPosts: {
        ...prevState.userPosts,
        [post.authorId]: [
          ...(prevState.userPosts[post.authorId] || []),
          post.id
        ]
      }
    }));
  };
  
  return { state, addPost };
}
```

### 2. State Machines Pattern

```tsx
type LoadingState = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: any }
  | { status: 'error'; error: string };

function DataFetcher() {
  const [state, setState] = useState<LoadingState>({ status: 'idle' });
  
  const fetchData = async () => {
    setState({ status: 'loading' });
    
    try {
      const data = await api.getData();
      setState({ status: 'success', data });
    } catch (error) {
      setState({ 
        status: 'error', 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
    }
  };
  
  const reset = () => {
    setState({ status: 'idle' });
  };
  
  return (
    <div>
      {state.status === 'idle' && (
        <button onClick={fetchData}>Fetch Data</button>
      )}
      
      {state.status === 'loading' && <div>Loading...</div>}
      
      {state.status === 'success' && (
        <div>
          <pre>{JSON.stringify(state.data, null, 2)}</pre>
          <button onClick={reset}>Reset</button>
        </div>
      )}
      
      {state.status === 'error' && (
        <div>
          <p>Error: {state.error}</p>
          <button onClick={fetchData}>Retry</button>
          <button onClick={reset}>Reset</button>
        </div>
      )}
    </div>
  );
}
```

### 3. Reducer Pattern with useState

```tsx
// When state logic gets complex, consider this pattern
type Action = 
  | { type: 'INCREMENT' }
  | { type: 'DECREMENT' }
  | { type: 'RESET' }
  | { type: 'SET_VALUE'; payload: number };

function counterReducer(state: number, action: Action): number {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    case 'RESET':
      return 0;
    case 'SET_VALUE':
      return action.payload;
    default:
      return state;
  }
}

function AdvancedCounter() {
  const [count, setCount] = useState(0);
  
  // Dispatch function using functional updates
  const dispatch = (action: Action) => {
    setCount(prevCount => counterReducer(prevCount, action));
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
      <button onClick={() => dispatch({ type: 'SET_VALUE', payload: 100 })}>
        Set to 100
      </button>
    </div>
  );
}
```

## Performance Considerations

### 1. Avoid Unnecessary Re-renders

```tsx
// ‚ùå Creates new object on every render
function BadComponent() {
  const [user, setUser] = useState({ name: '', email: '' });
  
  return (
    <UserDisplay 
      user={user} 
      defaultSettings={{ theme: 'light' }}  // New object every render!
    />
  );
}

// ‚úÖ Memoize stable values
function GoodComponent() {
  const [user, setUser] = useState({ name: '', email: '' });
  
  const defaultSettings = useMemo(() => ({ theme: 'light' }), []);
  
  return (
    <UserDisplay 
      user={user} 
      defaultSettings={defaultSettings}
    />
  );
}
```

### 2. Lazy Initial State

```tsx
// ‚ùå Expensive computation runs on every render
function BadComponent() {
  const [data, setData] = useState(expensiveComputation());
  // expensiveComputation() runs every render!
  
  return <div>{data}</div>;
}

// ‚úÖ Lazy initialization runs only once
function GoodComponent() {
  const [data, setData] = useState(() => expensiveComputation());
  // expensiveComputation() runs only on first render
  
  return <div>{data}</div>;
}

// Real example: localStorage initialization
function UserPreferences() {
  const [preferences, setPreferences] = useState(() => {
    // This only runs once
    const saved = localStorage.getItem('userPreferences');
    return saved ? JSON.parse(saved) : { theme: 'light', language: 'en' };
  });
  
  useEffect(() => {
    localStorage.setItem('userPreferences', JSON.stringify(preferences));
  }, [preferences]);
  
  return (
    <div>
      {/* Component implementation */}
    </div>
  );
}
```

## Summary

Understanding `useState` is fundamental to React development:

### Key Takeaways:

1. **State vs Props**: State is internal, props are external
2. **Always use useState**: Never use regular variables for changing data
3. **TypeScript helps**: Explicit typing prevents bugs and improves DX
4. **Functional updates**: Use when new state depends on previous state
5. **Immutability**: Always create new objects/arrays, never mutate
6. **Performance matters**: Use lazy initialization and avoid unnecessary objects

### When to Use Functional Updates:
- ‚úÖ Incrementing/decrementing numbers
- ‚úÖ Toggling booleans based on current value
- ‚úÖ Adding/removing items from arrays
- ‚úÖ Updating object properties
- ‚úÖ Any time new state depends on current state

### TypeScript Best Practices:
- Let TypeScript infer when possible
- Be explicit with complex types
- Use union types for state machines
- Define interfaces for object state
- Use generics for reusable patterns

**Next Steps**: Learn about `useEffect` for side effects, and how state and effects work together to create powerful, reactive components!