# React useState: Mastering Component State Management

## 🎯 Understanding State: The Heart of Dynamic UIs

State is **data that belongs to a component and can change over time**. It's what makes your React components interactive and dynamic. When state changes, React automatically re-renders the component to reflect those changes in the user interface.

### 🧠 State vs Props: The Fundamental Difference

Think of state and props like this:
- **Props**: Data that comes FROM outside (like function parameters)
- **State**: Data that lives INSIDE the component (like local variables that persist)

```jsx
// 📥 Props: External data (read-only)
const UserCard = ({ userName, userEmail, userAvatar }) => {
  // These come from parent and cannot be changed
  return (
    <div className="user-card">
      <img src={userAvatar} alt={userName} />
      <h3>{userName}</h3>
      <p>{userEmail}</p>
    </div>
  );
};

// 🎛️ State: Internal data (changeable)
const InteractiveUserCard = ({ userName, userEmail, userAvatar }) => {
  // This belongs to the component and can change
  const [isExpanded, setIsExpanded] = useState(false);
  const [editMode, setEditMode] = useState(false);
  const [displayName, setDisplayName] = useState(userName);
  
  return (
    <div className={`user-card ${isExpanded ? 'expanded' : 'collapsed'}`}>
      <img src={userAvatar} alt={userName} />
      
      {editMode ? (
        <input 
          value={displayName}
          onChange={(e) => setDisplayName(e.target.value)}
        />
      ) : (
        <h3>{displayName}</h3>
      )}
      
      <p>{userEmail}</p>
      
      <button onClick={() => setIsExpanded(!isExpanded)}>
        {isExpanded ? 'Collapse' : 'Expand'}
      </button>
      
      <button onClick={() => setEditMode(!editMode)}>
        {editMode ? 'Save' : 'Edit'}
      </button>
    </div>
  );
};
```

### 🔄 The State Update Cycle

When state changes, React follows this process:

```
🎯 User Interaction → 🔧 State Update → 🎨 Re-render → 🖥️ UI Update
       ↑                                                    ↓
       ←────────── 👁️ User sees updated UI ←──────────────
```

#### Example of the State Cycle

```jsx
const ClickCounter = () => {
  const [count, setCount] = useState(0); // 1. Initial state: 0
  
  const handleClick = () => {
    setCount(count + 1); // 2. Update state: 0 → 1
    // 3. React schedules re-render
    // 4. Component re-runs with new state
    // 5. UI updates to show new count
  };
  
  console.log('Component rendered with count:', count);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={handleClick}>Click me</button>
    </div>
  );
};
```

## 🎛️ useState Hook Deep Dive

### 🔧 Basic useState Syntax

```jsx
import React, { useState } from 'react';

const MyComponent = () => {
  // useState returns an array with two elements:
  // [currentValue, setterFunction]
  const [stateName, setStateName] = useState(initialValue);
  
  return (
    // Your JSX here
  );
};
```

### 🎨 Understanding Array Destructuring

```jsx
// This is what useState actually returns:
const stateArray = useState(0);
const currentValue = stateArray[0];   // 0
const setterFunction = stateArray[1]; // function

// But we use destructuring for cleaner code:
const [count, setCount] = useState(0);
// count = 0
// setCount = function to update count

// You can name them anything:
const [userAge, updateUserAge] = useState(25);
const [isVisible, toggleVisibility] = useState(true);
const [todos, setTodos] = useState([]);
```

### 🎯 Simple State Examples

#### **1. Counter Component**
```jsx
const Counter = () => {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(0);
  const addFive = () => setCount(count + 5);
  
  return (
    <div className="counter">
      <h2>Count: {count}</h2>
      <div className="controls">
        <button onClick={decrement} disabled={count <= 0}>
          -1
        </button>
        <button onClick={increment}>
          +1
        </button>
        <button onClick={addFive}>
          +5
        </button>
        <button onClick={reset}>
          Reset
        </button>
      </div>
    </div>
  );
};
```

#### **2. Toggle Component**
```jsx
const ToggleSwitch = () => {
  const [isOn, setIsOn] = useState(false);
  
  const toggle = () => setIsOn(!isOn);
  
  return (
    <div className="toggle-switch">
      <div className={`switch ${isOn ? 'on' : 'off'}`} onClick={toggle}>
        <div className="switch-handle" />
      </div>
      <p>Switch is {isOn ? 'ON' : 'OFF'}</p>
      <button onClick={() => setIsOn(true)}>Turn On</button>
      <button onClick={() => setIsOn(false)}>Turn Off</button>
    </div>
  );
};
```

#### **3. Text Input Component**
```jsx
const TextInput = () => {
  const [text, setText] = useState('');
  const [wordCount, setWordCount] = useState(0);
  
  const handleChange = (event) => {
    const newText = event.target.value;
    setText(newText);
    setWordCount(newText.trim().split(/\s+/).filter(word => word).length);
  };
  
  const clearText = () => {
    setText('');
    setWordCount(0);
  };
  
  return (
    <div className="text-input">
      <textarea 
        value={text}
        onChange={handleChange}
        placeholder="Start typing..."
        rows={4}
        cols={50}
      />
      <div className="stats">
        <p>Characters: {text.length}</p>
        <p>Words: {wordCount}</p>
      </div>
      <button onClick={clearText} disabled={!text}>
        Clear
      </button>
    </div>
  );
};
```

## 🔥 Advanced State Patterns

### 🎨 Multiple State Variables

```jsx
const UserForm = () => {
  // Each piece of state is independent
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(18);
  const [isSubscribed, setIsSubscribed] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [errors, setErrors] = useState({});
  
  const handleSubmit = async (event) => {
    event.preventDefault();
    setIsLoading(true);
    setErrors({});
    
    try {
      const userData = {
        firstName,
        lastName,
        email,
        age,
        isSubscribed
      };
      
      await submitUserData(userData);
      
      // Reset form on success
      setFirstName('');
      setLastName('');
      setEmail('');
      setAge(18);
      setIsSubscribed(false);
      
    } catch (error) {
      setErrors({ submit: 'Failed to submit form' });
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="user-form">
      <div className="form-group">
        <input
          type="text"
          value={firstName}
          onChange={(e) => setFirstName(e.target.value)}
          placeholder="First Name"
          required
        />
      </div>
      
      <div className="form-group">
        <input
          type="text"
          value={lastName}
          onChange={(e) => setLastName(e.target.value)}
          placeholder="Last Name"
          required
        />
      </div>
      
      <div className="form-group">
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
          required
        />
      </div>
      
      <div className="form-group">
        <input
          type="number"
          value={age}
          onChange={(e) => setAge(parseInt(e.target.value))}
          min="13"
          max="120"
        />
      </div>
      
      <div className="form-group">
        <label>
          <input
            type="checkbox"
            checked={isSubscribed}
            onChange={(e) => setIsSubscribed(e.target.checked)}
          />
          Subscribe to newsletter
        </label>
      </div>
      
      {errors.submit && (
        <div className="error">{errors.submit}</div>
      )}
      
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
};
```

### 🎯 Object State Management

```jsx
const UserProfile = () => {
  // Single state object for related data
  const [user, setUser] = useState({
    personalInfo: {
      firstName: '',
      lastName: '',
      email: '',
      phone: ''
    },
    preferences: {
      theme: 'light',
      notifications: true,
      language: 'en',
      timezone: 'UTC'
    },
    social: {
      twitter: '',
      linkedin: '',
      github: ''
    }
  });
  
  // Helper function to update nested objects
  const updatePersonalInfo = (field, value) => {
    setUser(prevUser => ({
      ...prevUser,
      personalInfo: {
        ...prevUser.personalInfo,
        [field]: value
      }
    }));
  };
  
  const updatePreferences = (field, value) => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        [field]: value
      }
    }));
  };
  
  const updateSocial = (platform, value) => {
    setUser(prevUser => ({
      ...prevUser,
      social: {
        ...prevUser.social,
        [platform]: value
      }
    }));
  };
  
  // Reset specific sections
  const resetPreferences = () => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        theme: 'light',
        notifications: true,
        language: 'en',
        timezone: 'UTC'
      }
    }));
  };
  
  return (
    <div className="user-profile">
      <section className="personal-info">
        <h3>Personal Information</h3>
        <input
          type="text"
          value={user.personalInfo.firstName}
          onChange={(e) => updatePersonalInfo('firstName', e.target.value)}
          placeholder="First Name"
        />
        <input
          type="text"
          value={user.personalInfo.lastName}
          onChange={(e) => updatePersonalInfo('lastName', e.target.value)}
          placeholder="Last Name"
        />
        <input
          type="email"
          value={user.personalInfo.email}
          onChange={(e) => updatePersonalInfo('email', e.target.value)}
          placeholder="Email"
        />
      </section>
      
      <section className="preferences">
        <h3>Preferences</h3>
        <select
          value={user.preferences.theme}
          onChange={(e) => updatePreferences('theme', e.target.value)}
        >
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="auto">Auto</option>
        </select>
        
        <label>
          <input
            type="checkbox"
            checked={user.preferences.notifications}
            onChange={(e) => updatePreferences('notifications', e.target.checked)}
          />
          Enable Notifications
        </label>
        
        <button onClick={resetPreferences}>
          Reset Preferences
        </button>
      </section>
      
      <section className="social">
        <h3>Social Media</h3>
        <input
          type="text"
          value={user.social.twitter}
          onChange={(e) => updateSocial('twitter', e.target.value)}
          placeholder="Twitter handle"
        />
        <input
          type="text"
          value={user.social.linkedin}
          onChange={(e) => updateSocial('linkedin', e.target.value)}
          placeholder="LinkedIn profile"
        />
      </section>
      
      <div className="debug">
        <h4>Current State:</h4>
        <pre>{JSON.stringify(user, null, 2)}</pre>
      </div>
    </div>
  );
};
```

### 🎮 Array State Management

```jsx
const TodoList = () => {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', completed: false, priority: 'high' },
    { id: 2, text: 'Build a project', completed: false, priority: 'medium' },
    { id: 3, text: 'Get a job', completed: false, priority: 'high' }
  ]);
  
  const [newTodoText, setNewTodoText] = useState('');
  const [filter, setFilter] = useState('all'); // all, completed, pending
  const [sortBy, setSortBy] = useState('id'); // id, text, priority
  
  // Add new todo
  const addTodo = () => {
    if (!newTodoText.trim()) return;
    
    const newTodo = {
      id: Date.now(), // Simple ID generation
      text: newTodoText.trim(),
      completed: false,
      priority: 'medium',
      createdAt: new Date().toISOString()
    };
    
    setTodos(prevTodos => [...prevTodos, newTodo]);
    setNewTodoText('');
  };
  
  // Toggle todo completion
  const toggleTodo = (id) => {
    setTodos(prevTodos =>
      prevTodos.map(todo =>
        todo.id === id
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };
  
  // Update todo text
  const updateTodoText = (id, newText) => {
    setTodos(prevTodos =>
      prevTodos.map(todo =>
        todo.id === id
          ? { ...todo, text: newText }
          : todo
      )
    );
  };
  
  // Update todo priority
  const updateTodoPriority = (id, priority) => {
    setTodos(prevTodos =>
      prevTodos.map(todo =>
        todo.id === id
          ? { ...todo, priority }
          : todo
      )
    );
  };
  
  // Delete todo
  const deleteTodo = (id) => {
    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));
  };
  
  // Bulk operations
  const markAllCompleted = () => {
    setTodos(prevTodos =>
      prevTodos.map(todo => ({ ...todo, completed: true }))
    );
  };
  
  const deleteCompleted = () => {
    setTodos(prevTodos => prevTodos.filter(todo => !todo.completed));
  };
  
  const clearAll = () => {
    setTodos([]);
  };
  
  // Computed values
  const filteredTodos = todos.filter(todo => {
    if (filter === 'completed') return todo.completed;
    if (filter === 'pending') return !todo.completed;
    return true; // 'all'
  });
  
  const sortedTodos = [...filteredTodos].sort((a, b) => {
    if (sortBy === 'text') return a.text.localeCompare(b.text);
    if (sortBy === 'priority') {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    }
    return a.id - b.id; // default: by ID
  });
  
  const stats = {
    total: todos.length,
    completed: todos.filter(t => t.completed).length,
    pending: todos.filter(t => !t.completed).length
  };
  
  return (
    <div className="todo-app">
      <div className="todo-header">
        <h1>Todo List</h1>
        <div className="stats">
          <span>Total: {stats.total}</span>
          <span>Completed: {stats.completed}</span>
          <span>Pending: {stats.pending}</span>
        </div>
      </div>
      
      <div className="todo-controls">
        <div className="add-todo">
          <input
            type="text"
            value={newTodoText}
            onChange={(e) => setNewTodoText(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && addTodo()}
            placeholder="Add a new todo..."
          />
          <button onClick={addTodo} disabled={!newTodoText.trim()}>
            Add
          </button>
        </div>
        
        <div className="filters">
          <select value={filter} onChange={(e) => setFilter(e.target.value)}>
            <option value="all">All</option>
            <option value="pending">Pending</option>
            <option value="completed">Completed</option>
          </select>
          
          <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
            <option value="id">Sort by Date</option>
            <option value="text">Sort by Text</option>
            <option value="priority">Sort by Priority</option>
          </select>
        </div>
        
        <div className="bulk-actions">
          <button onClick={markAllCompleted} disabled={!stats.pending}>
            Mark All Complete
          </button>
          <button onClick={deleteCompleted} disabled={!stats.completed}>
            Delete Completed
          </button>
          <button onClick={clearAll} disabled={!stats.total}>
            Clear All
          </button>
        </div>
      </div>
      
      <div className="todo-list">
        {sortedTodos.length === 0 ? (
          <div className="empty-state">
            {filter === 'all' 
              ? 'No todos yet. Add one above!' 
              : `No ${filter} todos.`
            }
          </div>
        ) : (
          sortedTodos.map(todo => (
            <TodoItem
              key={todo.id}
              todo={todo}
              onToggle={toggleTodo}
              onUpdateText={updateTodoText}
              onUpdatePriority={updateTodoPriority}
              onDelete={deleteTodo}
            />
          ))
        )}
      </div>
    </div>
  );
};

const TodoItem = ({ 
  todo, 
  onToggle, 
  onUpdateText, 
  onUpdatePriority, 
  onDelete 
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);
  
  const handleSave = () => {
    if (editText.trim()) {
      onUpdateText(todo.id, editText.trim());
      setIsEditing(false);
    }
  };
  
  const handleCancel = () => {
    setEditText(todo.text);
    setIsEditing(false);
  };
  
  return (
    <div className={`todo-item ${todo.completed ? 'completed' : ''} priority-${todo.priority}`}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      
      {isEditing ? (
        <div className="edit-mode">
          <input
            type="text"
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onKeyPress={(e) => {
              if (e.key === 'Enter') handleSave();
              if (e.key === 'Escape') handleCancel();
            }}
            autoFocus
          />
          <button onClick={handleSave}>Save</button>
          <button onClick={handleCancel}>Cancel</button>
        </div>
      ) : (
        <div className="view-mode">
          <span className="todo-text">{todo.text}</span>
          <select
            value={todo.priority}
            onChange={(e) => onUpdatePriority(todo.id, e.target.value)}
          >
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </select>
          <button onClick={() => setIsEditing(true)}>Edit</button>
          <button onClick={() => onDelete(todo.id)} className="delete-btn">
            Delete
          </button>
        </div>
      )}
    </div>
  );
};
```

## ⚡ State Update Best Practices

### 🔄 State Update Functions

```jsx
const Counter = () => {
  const [count, setCount] = useState(0);
  
  // ❌ Dangerous: Direct state reference
  const incrementBad = () => {
    setCount(count + 1);
    setCount(count + 1); // Still adds only 1!
  };
  
  // ✅ Safe: Function form
  const incrementGood = () => {
    setCount(prevCount => prevCount + 1);
    setCount(prevCount => prevCount + 1); // Adds 2!
  };
  
  // ✅ Even better: Custom hooks
  const useCounter = (initialValue = 0) => {
    const [count, setCount] = useState(initialValue);
    
    const increment = () => setCount(prev => prev + 1);
    const decrement = () => setCount(prev => prev - 1);
    const reset = () => setCount(initialValue);
    const incrementBy = (amount) => setCount(prev => prev + amount);
    
    return { count, increment, decrement, reset, incrementBy };
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={incrementGood}>Safe Increment</button>
    </div>
  );
};
```

### 🎛️ State Initialization Patterns

```jsx
const ExpensiveComponent = ({ userId }) => {
  // ❌ Bad: Expensive operation runs on every render
  const [userData, setUserData] = useState(
    JSON.parse(localStorage.getItem(`user-${userId}`)) || {}
  );
  
  // ✅ Good: Lazy initialization - runs only once
  const [userData, setUserData] = useState(() => {
    console.log('Initializing user data...'); // Runs only once
    const saved = localStorage.getItem(`user-${userId}`);
    return saved ? JSON.parse(saved) : {};
  });
  
  // ✅ Good: Different initialization patterns
  const [counts, setCounts] = useState(() => ({
    likes: 0,
    shares: 0,
    comments: 0
  }));
  
  const [settings, setSettings] = useState(() => {
    const defaults = {
      theme: 'light',
      fontSize: 14,
      autoSave: true
    };
    
    try {
      const saved = localStorage.getItem('settings');
      return saved ? { ...defaults, ...JSON.parse(saved) } : defaults;
    } catch {
      return defaults;
    }
  });
  
  return (
    <div>
      {/* Component JSX */}
    </div>
  );
};
```

useState is the foundation of React state management. Master these patterns and you'll be able to build complex, interactive user interfaces with confidence!
// What useState actually returns:
const stateArray = useState(0);
const currentValue = stateArray[0];  // 0
const updateFunction = stateArray[1];  // function

// But we use array destructuring for cleaner code:
const [count, setCount] = useState(0);
// This is equivalent to the above, but much cleaner!
```

### Simple Examples

#### 1. Counter Component

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(0);
  
  return (
    <div className="counter">
      <h2>Count: {count}</h2>
      <div className="buttons">
        <button onClick={decrement}>-</button>
        <button onClick={reset}>Reset</button>
        <button onClick={increment}>+</button>
      </div>
    </div>
  );
}
```

#### 2. Toggle Component

```jsx
function ToggleSwitch() {
  const [isOn, setIsOn] = useState(false);
  
  const toggle = () => setIsOn(!isOn);
  
  return (
    <div className={`toggle-switch ${isOn ? 'on' : 'off'}`}>
      <button onClick={toggle}>
        {isOn ? '🟢 ON' : '🔴 OFF'}
      </button>
      <p>The switch is {isOn ? 'ON' : 'OFF'}</p>
    </div>
  );
}
```

#### 3. Text Input Component

```jsx
function TextInput() {
  const [text, setText] = useState('');
  
  const handleChange = (event) => {
    setText(event.target.value);
  };
  
  const clearText = () => setText('');
  
  return (
    <div>
      <input 
        type="text" 
        value={text} 
        onChange={handleChange}
        placeholder="Type something..."
      />
      <button onClick={clearText}>Clear</button>
      <p>You typed: {text}</p>
      <p>Character count: {text.length}</p>
    </div>
  );
}
```

### Multiple State Variables

```jsx
function UserProfile() {
  // Each piece of state is independent
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [isEditing, setIsEditing] = useState(false);
  
  const handleSave = () => {
    console.log('Saving:', { name, email, age });
    setIsEditing(false);
  };
  
  if (isEditing) {
    return (
      <form>
        <div>
          <label>Name:</label>
          <input 
            value={name} 
            onChange={(e) => setName(e.target.value)} 
          />
        </div>
        <div>
          <label>Email:</label>
          <input 
            value={email} 
            onChange={(e) => setEmail(e.target.value)} 
          />
        </div>
        <div>
          <label>Age:</label>
          <input 
            type="number"
            value={age} 
            onChange={(e) => setAge(parseInt(e.target.value) || 0)} 
          />
        </div>
        <button type="button" onClick={handleSave}>Save</button>
        <button type="button" onClick={() => setIsEditing(false)}>Cancel</button>
      </form>
    );
  }
  
  return (
    <div>
      <h2>{name || 'No name set'}</h2>
      <p>Email: {email || 'No email set'}</p>
      <p>Age: {age}</p>
      <button onClick={() => setIsEditing(true)}>Edit</button>
    </div>
  );
}
```

### State with Objects

```jsx
function UserForm() {
  // Single state object instead of multiple state variables
  const [user, setUser] = useState({
    name: '',
    email: '',
    preferences: {
      theme: 'light',
      notifications: true
    }
  });
  
  // Helper function to update nested properties
  const updateUser = (field, value) => {
    setUser(prevUser => ({
      ...prevUser,  // Spread existing properties
      [field]: value  // Update specific field
    }));
  };
  
  const updatePreference = (prefKey, value) => {
    setUser(prevUser => ({
      ...prevUser,
      preferences: {
        ...prevUser.preferences,
        [prefKey]: value
      }
    }));
  };
  
  return (
    <div>
      <h2>User Settings</h2>
      
      <div>
        <label>Name:</label>
        <input 
          value={user.name}
          onChange={(e) => updateUser('name', e.target.value)}
        />
      </div>
      
      <div>
        <label>Email:</label>
        <input 
          value={user.email}
          onChange={(e) => updateUser('email', e.target.value)}
        />
      </div>
      
      <div>
        <label>Theme:</label>
        <select 
          value={user.preferences.theme}
          onChange={(e) => updatePreference('theme', e.target.value)}
        >
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
      
      <div>
        <label>
          <input 
            type="checkbox"
            checked={user.preferences.notifications}
            onChange={(e) => updatePreference('notifications', e.target.checked)}
          />
          Enable notifications
        </label>
      </div>
      
      <div className="preview">
        <h3>Current Settings:</h3>
        <pre>{JSON.stringify(user, null, 2)}</pre>
      </div>
    </div>
  );
}
```

### State with Arrays

```jsx
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [inputValue, setInputValue] = useState('');
  
  const addTodo = () => {
    if (inputValue.trim()) {
      const newTodo = {
        id: Date.now(),  // Simple ID generation
        text: inputValue.trim(),
        completed: false
      };
      
      setTodos(prevTodos => [...prevTodos, newTodo]);  // Add to end
      setInputValue('');  // Clear input
    }
  };
  
  const toggleTodo = (id) => {
    setTodos(prevTodos => 
      prevTodos.map(todo => 
        todo.id === id 
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  };
  
  const deleteTodo = (id) => {
    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));
  };
  
  const clearCompleted = () => {
    setTodos(prevTodos => prevTodos.filter(todo => !todo.completed));
  };
  
  return (
    <div className="todo-list">
      <div className="add-todo">
        <input 
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && addTodo()}
          placeholder="Add a new todo..."
        />
        <button onClick={addTodo}>Add</button>
      </div>
      
      <div className="stats">
        <p>Total: {todos.length}</p>
        <p>Completed: {todos.filter(t => t.completed).length}</p>
        <p>Remaining: {todos.filter(t => !t.completed).length}</p>
        <button onClick={clearCompleted}>Clear Completed</button>
      </div>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id} className={todo.completed ? 'completed' : ''}>
            <span 
              onClick={() => toggleTodo(todo.id)}
              style={{ 
                textDecoration: todo.completed ? 'line-through' : 'none',
                cursor: 'pointer'
              }}
            >
              {todo.text}
            </span>
            <button onClick={() => deleteTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## 3.3 Typing useState with TypeScript

TypeScript can often infer the type of your state automatically, but sometimes you need to be explicit.

### Automatic Type Inference

```tsx
// TypeScript automatically infers these types:
const [count, setCount] = useState(0);           // number
const [name, setName] = useState('');            // string
const [isVisible, setIsVisible] = useState(true); // boolean
const [items, setItems] = useState([]);          // never[] (empty array)
```

### Explicit Type Annotations

```tsx
// When TypeScript can't infer or you want to be specific:

// 1. Primitive types (usually not needed)
const [count, setCount] = useState<number>(0);
const [name, setName] = useState<string>('');

// 2. Array types
const [numbers, setNumbers] = useState<number[]>([]);
const [names, setNames] = useState<string[]>([]);

// 3. Union types
const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');

// 4. Object types
interface User {
  id: number;
  name: string;
  email: string;
}

const [user, setUser] = useState<User | null>(null);  // Important: null initially

// 5. Complex nested types
interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  settings: {
    notifications: boolean;
    language: string;
  };
}

const [appState, setAppState] = useState<AppState>({
  user: null,
  theme: 'light',
  settings: {
    notifications: true,
    language: 'en'
  }
});
```

### Real-World TypeScript Examples

#### 1. User Authentication State

```tsx
interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'moderator';
  avatar?: string;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}

function AuthComponent() {
  const [authState, setAuthState] = useState<AuthState>({
    user: null,
    isLoading: false,
    error: null
  });
  
  const login = async (email: string, password: string) => {
    setAuthState(prev => ({ ...prev, isLoading: true, error: null }));
    
    try {
      const user = await authenticateUser(email, password);
      setAuthState({
        user,
        isLoading: false,
        error: null
      });
    } catch (error) {
      setAuthState({
        user: null,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Login failed'
      });
    }
  };
  
  const logout = () => {
    setAuthState({
      user: null,
      isLoading: false,
      error: null
    });
  };
  
  if (authState.isLoading) {
    return <div>Logging in...</div>;
  }
  
  if (authState.error) {
    return <div className="error">Error: {authState.error}</div>;
  }
  
  if (!authState.user) {
    return (
      <LoginForm onLogin={login} />
    );
  }
  
  return (
    <div>
      <h2>Welcome, {authState.user.name}!</h2>
      <p>Role: {authState.user.role}</p>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

#### 2. Form State with Validation

```tsx
interface FormData {
  email: string;
  password: string;
  confirmPassword: string;
}

interface FormErrors {
  email?: string;
  password?: string;
  confirmPassword?: string;
}

function RegistrationForm() {
  const [formData, setFormData] = useState<FormData>({
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  const [errors, setErrors] = useState<FormErrors>({});
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  
  const updateField = (field: keyof FormData, value: string) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
    
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: undefined
      }));
    }
  };
  
  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};
    
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }
    
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    setIsSubmitting(true);
    try {
      await registerUser(formData);
      // Handle success
    } catch (error) {
      setErrors({ 
        email: error instanceof Error ? error.message : 'Registration failed' 
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="email"
          value={formData.email}
          onChange={(e) => updateField('email', e.target.value)}
          placeholder="Email"
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>
      
      <div>
        <input
          type="password"
          value={formData.password}
          onChange={(e) => updateField('password', e.target.value)}
          placeholder="Password"
        />
        {errors.password && <span className="error">{errors.password}</span>}
      </div>
      
      <div>
        <input
          type="password"
          value={formData.confirmPassword}
          onChange={(e) => updateField('confirmPassword', e.target.value)}
          placeholder="Confirm Password"
        />
        {errors.confirmPassword && <span className="error">{errors.confirmPassword}</span>}
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Registering...' : 'Register'}
      </button>
    </form>
  );
}
```

#### 3. API Data Fetching State

```tsx
interface ApiResponse<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

interface Product {
  id: string;
  name: string;
  price: number;
  description: string;
  inStock: boolean;
}

function ProductList() {
  const [productsState, setProductsState] = useState<ApiResponse<Product[]>>({
    data: null,
    loading: true,
    error: null
  });
  
  const [filters, setFilters] = useState<{
    category: string;
    priceRange: [number, number];
    inStockOnly: boolean;
  }>({
    category: 'all',
    priceRange: [0, 1000],
    inStockOnly: false
  });
  
  useEffect(() => {
    fetchProducts();
  }, [filters]);
  
  const fetchProducts = async () => {
    setProductsState(prev => ({ ...prev, loading: true }));
    
    try {
      const products = await api.getProducts(filters);
      setProductsState({
        data: products,
        loading: false,
        error: null
      });
    } catch (error) {
      setProductsState({
        data: null,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to fetch products'
      });
    }
  };
  
  const updateFilter = <K extends keyof typeof filters>(
    key: K, 
    value: typeof filters[K]
  ) => {
    setFilters(prev => ({
      ...prev,
      [key]: value
    }));
  };
  
  if (productsState.loading) {
    return <div>Loading products...</div>;
  }
  
  if (productsState.error) {
    return <div className="error">Error: {productsState.error}</div>;
  }
  
  return (
    <div>
      <div className="filters">
        <select 
          value={filters.category}
          onChange={(e) => updateFilter('category', e.target.value)}
        >
          <option value="all">All Categories</option>
          <option value="electronics">Electronics</option>
          <option value="clothing">Clothing</option>
        </select>
        
        <label>
          <input
            type="checkbox"
            checked={filters.inStockOnly}
            onChange={(e) => updateFilter('inStockOnly', e.target.checked)}
          />
          In stock only
        </label>
      </div>
      
      <div className="products">
        {productsState.data?.map(product => (
          <div key={product.id} className="product-card">
            <h3>{product.name}</h3>
            <p>${product.price}</p>
            <p>{product.description}</p>
            <p>Status: {product.inStock ? 'In Stock' : 'Out of Stock'}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

## 3.4 Functional Updates

Functional updates are crucial when your new state depends on the previous state. They ensure you always work with the most current state value.

### The Problem with Direct Updates

```jsx
function BadCounter() {
  const [count, setCount] = useState(0);
  
  // ❌ Problem: Multiple rapid clicks might not work as expected
  const handleMultipleIncrements = () => {
    setCount(count + 1);  // count is 0, sets to 1
    setCount(count + 1);  // count is still 0 here, sets to 1
    setCount(count + 1);  // count is still 0 here, sets to 1
    // Result: count becomes 1, not 3!
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleMultipleIncrements}>+3 (Broken)</button>
    </div>
  );
}
```

### The Solution: Functional Updates

```jsx
function GoodCounter() {
  const [count, setCount] = useState(0);
  
  // ✅ Solution: Use functional updates
  const handleMultipleIncrements = () => {
    setCount(prevCount => prevCount + 1);  // prevCount is 0, returns 1
    setCount(prevCount => prevCount + 1);  // prevCount is 1, returns 2
    setCount(prevCount => prevCount + 1);  // prevCount is 2, returns 3
    // Result: count becomes 3!
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleMultipleIncrements}>+3 (Working)</button>
    </div>
  );
}
```

### When to Use Functional Updates

#### 1. When State Depends on Previous Value

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  // ✅ Use functional update for increment/decrement
  const increment = () => setCount(prev => prev + 1);
  const decrement = () => setCount(prev => prev - 1);
  const double = () => setCount(prev => prev * 2);
  const reset = () => setCount(0);  // Direct update is fine here
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={double}>×2</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

#### 2. Working with Objects

```jsx
function UserProfile() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: 0
  });
  
  // ✅ Functional update to merge with existing state
  const updateUserField = (field, value) => {
    setUser(prevUser => ({
      ...prevUser,
      [field]: value
    }));
  };
  
  // ✅ More complex updates
  const incrementAge = () => {
    setUser(prevUser => ({
      ...prevUser,
      age: prevUser.age + 1
    }));
  };
  
  return (
    <div>
      <input 
        value={user.name}
        onChange={(e) => updateUserField('name', e.target.value)}
        placeholder="Name"
      />
      <input 
        value={user.email}
        onChange={(e) => updateUserField('email', e.target.value)}
        placeholder="Email"
      />
      <p>Age: {user.age}</p>
      <button onClick={incrementAge}>Age +1</button>
    </div>
  );
}
```

#### 3. Working with Arrays

```jsx
function ShoppingCart() {
  const [items, setItems] = useState([]);
  
  const addItem = (newItem) => {
    setItems(prevItems => [...prevItems, newItem]);
  };
  
  const removeItem = (itemId) => {
    setItems(prevItems => prevItems.filter(item => item.id !== itemId));
  };
  
  const updateQuantity = (itemId, newQuantity) => {
    setItems(prevItems =>
      prevItems.map(item =>
        item.id === itemId
          ? { ...item, quantity: newQuantity }
          : item
      )
    );
  };
  
  const clearCart = () => {
    setItems([]);  // Direct update is fine here
  };
  
  return (
    <div>
      <button onClick={() => addItem({ 
        id: Date.now(), 
        name: 'New Item', 
        quantity: 1 
      })}>
        Add Item
      </button>
      
      <ul>
        {items.map(item => (
          <li key={item.id}>
            {item.name} - Quantity: {item.quantity}
            <button onClick={() => updateQuantity(item.id, item.quantity + 1)}>
              +
            </button>
            <button onClick={() => updateQuantity(item.id, item.quantity - 1)}>
              -
            </button>
            <button onClick={() => removeItem(item.id)}>
              Remove
            </button>
          </li>
        ))}
      </ul>
      
      <button onClick={clearCart}>Clear Cart</button>
    </div>
  );
}
```

### Async Operations and State Updates

```jsx
function AsyncCounter() {
  const [count, setCount] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  
  // ❌ Potential issue with stale closure
  const incrementAfterDelay = async () => {
    setIsLoading(true);
    await new Promise(resolve => setTimeout(resolve, 1000));
    setCount(count + 1);  // 'count' might be stale here!
    setIsLoading(false);
  };
  
  // ✅ Better approach with functional update
  const incrementAfterDelayCorrect = async () => {
    setIsLoading(true);
    await new Promise(resolve => setTimeout(resolve, 1000));
    setCount(prevCount => prevCount + 1);  // Always uses current value
    setIsLoading(false);
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button 
        onClick={incrementAfterDelayCorrect} 
        disabled={isLoading}
      >
        {isLoading ? 'Loading...' : 'Increment after 1s'}
      </button>
    </div>
  );
}
```

### Complex State Updates with TypeScript

```tsx
interface TodoState {
  todos: Array<{
    id: string;
    text: string;
    completed: boolean;
    priority: 'low' | 'medium' | 'high';
  }>;
  filter: 'all' | 'active' | 'completed';
  sortBy: 'date' | 'priority' | 'alphabetical';
}

function TodoApp() {
  const [state, setState] = useState<TodoState>({
    todos: [],
    filter: 'all',
    sortBy: 'date'
  });
  
  // Add todo with functional update
  const addTodo = (text: string, priority: TodoState['todos'][0]['priority']) => {
    setState(prevState => ({
      ...prevState,
      todos: [
        ...prevState.todos,
        {
          id: crypto.randomUUID(),
          text,
          completed: false,
          priority
        }
      ]
    }));
  };
  
  // Toggle todo completion
  const toggleTodo = (id: string) => {
    setState(prevState => ({
      ...prevState,
      todos: prevState.todos.map(todo =>
        todo.id === id
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    }));
  };
  
  // Update filter
  const setFilter = (filter: TodoState['filter']) => {
    setState(prevState => ({
      ...prevState,
      filter
    }));
  };
  
  // Bulk operations
  const markAllCompleted = () => {
    setState(prevState => ({
      ...prevState,
      todos: prevState.todos.map(todo => ({
        ...todo,
        completed: true
      }))
    }));
  };
  
  const clearCompleted = () => {
    setState(prevState => ({
      ...prevState,
      todos: prevState.todos.filter(todo => !todo.completed)
    }));
  };
  
  return (
    <div>
      {/* Component implementation */}
    </div>
  );
}
```

## Common useState Patterns and Best Practices

### 1. State Normalization

```tsx
// ❌ Denormalized state - hard to update
interface BadState {
  users: Array<{
    id: string;
    name: string;
    posts: Array<{
      id: string;
      title: string;
      authorId: string;
    }>;
  }>;
}

// ✅ Normalized state - easier to update
interface GoodState {
  users: Record<string, { id: string; name: string }>;
  posts: Record<string, { id: string; title: string; authorId: string }>;
  userPosts: Record<string, string[]>; // userId -> postIds
}

function useNormalizedState() {
  const [state, setState] = useState<GoodState>({
    users: {},
    posts: {},
    userPosts: {}
  });
  
  const addPost = (post: GoodState['posts'][string]) => {
    setState(prevState => ({
      ...prevState,
      posts: {
        ...prevState.posts,
        [post.id]: post
      },
      userPosts: {
        ...prevState.userPosts,
        [post.authorId]: [
          ...(prevState.userPosts[post.authorId] || []),
          post.id
        ]
      }
    }));
  };
  
  return { state, addPost };
}
```

### 2. State Machines Pattern

```tsx
type LoadingState = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: any }
  | { status: 'error'; error: string };

function DataFetcher() {
  const [state, setState] = useState<LoadingState>({ status: 'idle' });
  
  const fetchData = async () => {
    setState({ status: 'loading' });
    
    try {
      const data = await api.getData();
      setState({ status: 'success', data });
    } catch (error) {
      setState({ 
        status: 'error', 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
    }
  };
  
  const reset = () => {
    setState({ status: 'idle' });
  };
  
  return (
    <div>
      {state.status === 'idle' && (
        <button onClick={fetchData}>Fetch Data</button>
      )}
      
      {state.status === 'loading' && <div>Loading...</div>}
      
      {state.status === 'success' && (
        <div>
          <pre>{JSON.stringify(state.data, null, 2)}</pre>
          <button onClick={reset}>Reset</button>
        </div>
      )}
      
      {state.status === 'error' && (
        <div>
          <p>Error: {state.error}</p>
          <button onClick={fetchData}>Retry</button>
          <button onClick={reset}>Reset</button>
        </div>
      )}
    </div>
  );
}
```

### 3. Reducer Pattern with useState

```tsx
// When state logic gets complex, consider this pattern
type Action = 
  | { type: 'INCREMENT' }
  | { type: 'DECREMENT' }
  | { type: 'RESET' }
  | { type: 'SET_VALUE'; payload: number };

function counterReducer(state: number, action: Action): number {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    case 'RESET':
      return 0;
    case 'SET_VALUE':
      return action.payload;
    default:
      return state;
  }
}

function AdvancedCounter() {
  const [count, setCount] = useState(0);
  
  // Dispatch function using functional updates
  const dispatch = (action: Action) => {
    setCount(prevCount => counterReducer(prevCount, action));
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
      <button onClick={() => dispatch({ type: 'SET_VALUE', payload: 100 })}>
        Set to 100
      </button>
    </div>
  );
}
```

## Performance Considerations

### 1. Avoid Unnecessary Re-renders

```tsx
// ❌ Creates new object on every render
function BadComponent() {
  const [user, setUser] = useState({ name: '', email: '' });
  
  return (
    <UserDisplay 
      user={user} 
      defaultSettings={{ theme: 'light' }}  // New object every render!
    />
  );
}

// ✅ Memoize stable values
function GoodComponent() {
  const [user, setUser] = useState({ name: '', email: '' });
  
  const defaultSettings = useMemo(() => ({ theme: 'light' }), []);
  
  return (
    <UserDisplay 
      user={user} 
      defaultSettings={defaultSettings}
    />
  );
}
```

### 2. Lazy Initial State

```tsx
// ❌ Expensive computation runs on every render
function BadComponent() {
  const [data, setData] = useState(expensiveComputation());
  // expensiveComputation() runs every render!
  
  return <div>{data}</div>;
}

// ✅ Lazy initialization runs only once
function GoodComponent() {
  const [data, setData] = useState(() => expensiveComputation());
  // expensiveComputation() runs only on first render
  
  return <div>{data}</div>;
}

// Real example: localStorage initialization
function UserPreferences() {
  const [preferences, setPreferences] = useState(() => {
    // This only runs once
    const saved = localStorage.getItem('userPreferences');
    return saved ? JSON.parse(saved) : { theme: 'light', language: 'en' };
  });
  
  useEffect(() => {
    localStorage.setItem('userPreferences', JSON.stringify(preferences));
  }, [preferences]);
  
  return (
    <div>
      {/* Component implementation */}
    </div>
  );
}
```

## Summary

Understanding `useState` is fundamental to React development:

### Key Takeaways:

1. **State vs Props**: State is internal, props are external
2. **Always use useState**: Never use regular variables for changing data
3. **TypeScript helps**: Explicit typing prevents bugs and improves DX
4. **Functional updates**: Use when new state depends on previous state
5. **Immutability**: Always create new objects/arrays, never mutate
6. **Performance matters**: Use lazy initialization and avoid unnecessary objects

### When to Use Functional Updates:
- ✅ Incrementing/decrementing numbers
- ✅ Toggling booleans based on current value
- ✅ Adding/removing items from arrays
- ✅ Updating object properties
- ✅ Any time new state depends on current state

### TypeScript Best Practices:
- Let TypeScript infer when possible
- Be explicit with complex types
- Use union types for state machines
- Define interfaces for object state
- Use generics for reusable patterns

**Next Steps**: Learn about `useEffect` for side effects, and how state and effects work together to create powerful, reactive components!