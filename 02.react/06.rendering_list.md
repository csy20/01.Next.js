# React Rendering Patterns: Conditional Logic, Lists, Keys & Dynamic UI

> Master every practical rendering scenario you face in real-world React applications: conditional branches, complex lists, dynamic updates, permissions, feature flags, virtualization, and performance.

---
## 1. Mental Model: Rendering = Pure Description
React render functions are pure. You **describe** what the UI should look like for the current state. React efficiently reconciles differences.

Rendering patterns fall into two big categories:
1. Conditional Rendering – deciding WHETHER/WHAT to show
2. List Rendering – deciding HOW MANY and in which structure

We'll go from basic to elite patterns.

---
## 2. Conditional Rendering Core Toolkit

| Technique | Use When | Pros | Caution |
|-----------|----------|------|---------|
| Ternary `? :` | Mutually exclusive 2-way choice | Compact | Becomes unreadable when nested deeply |
| Logical AND `&&` | Show element or nothing | Clean | Value before `&&` must be strictly boolean-ish |
| Early Return | Multiple exit states | Keeps main body clean | Too many returns can confuse if unordered |
| Switch / Lookup Map | Many discrete states | Explicit mapping | Keep config centralized |
| Guard Components (wrappers) | Cross-cutting concerns | Reusable | Over-abstraction risk |

### 2.1 Ternary (Binary Choice)
```jsx
const AuthGate = ({ user, isLoading, error }) => (
  <div>
    {isLoading ? (
      <Spinner label="Checking session..." />
    ) : user ? (
      <Dashboard user={user} />
    ) : error ? (
      <AuthError error={error} />
    ) : (
      <LoginPanel />
    )}
  </div>
);
```

Refactor nested ternaries once they exceed 2 levels—extract to functions.

### 2.2 Logical AND (Presence)
```jsx
{cart.total > 0 && <CheckoutSummary total={cart.total} />}
{user?.role === 'admin' && <AdminTools />}
{Boolean(message) && <Flash type="info" text={message} />}
```

### 2.3 Early Returns (Guard Clauses)
```jsx
function ReportView({ reportId, permissions }) {
  if (!reportId) return <EmptyState title="No report selected" />;
  if (!permissions.canViewReports) return <Denied reason="Need report access" />;
  // ...load data with hooks above ...
  if (loading) return <SkeletonReport />;
  if (error) return <ErrorPanel error={error} retry={refetch} />;
  if (!data) return <NotFound item="Report" />;
  return <Report data={data} />;
}
```

### 2.4 Switch / Lookup Map
```jsx
const STATUS_CONFIG = {
  success: { icon: '✅', color: 'green', label: 'Success' },
  warning: { icon: '⚠️', color: 'amber', label: 'Warning' },
  error:   { icon: '❌', color: 'red', label: 'Error' },
  info:    { icon: 'ℹ️', color: 'blue', label: 'Info' }
};

const StatusBadge = ({ status }) => {
  const cfg = STATUS_CONFIG[status] ?? STATUS_CONFIG.info;
  return <span className={`badge badge-${cfg.color}`}>{cfg.icon} {cfg.label}</span>;
};
```

### 2.5 Wrapper Guards (Reusable)
```jsx
const Require = ({ when, fallback = null, children }) => (when ? children : fallback);

<Require when={user} fallback={<LoginPanel />}> <Dashboard /> </Require>
```

---
## 3. Advanced Conditional Scenarios

### 3.1 Feature Flags
```jsx
function FeatureFlag({ name, fallback = null, children }) {
  const flags = useFeatureFlags(); // from hook / context
  if (!flags.ready) return null; // or skeleton
  return flags.enabled(name) ? children : fallback;
}

<FeatureFlag name="new_dashboard" fallback={<LegacyDashboard />}> <NewDashboard /> </FeatureFlag>
```

### 3.2 Permission Matrix
```jsx
const Can = ({ any = [], all = [], user, children, fallback = null }) => {
  const perms = user?.permissions || [];
  const passAll = all.every(p => perms.includes(p));
  const passAny = any.length === 0 || any.some(p => perms.includes(p));
  return passAll && passAny ? children : fallback;
};

<Can all={['manage:users']} user={user} fallback={<Denied />}> <UserAdmin /> </Can>
```

### 3.3 Progressive Disclosure
```jsx
function Progressive({ steps }) {
  const [idx, setIdx] = useState(0);
  const Step = steps[idx];
  return <Step onNext={() => setIdx(i => i + 1)} />;
}
```

---
## 4. List Rendering Fundamentals

### 4.1 Basics
```jsx
{items.map(item => <Row key={item.id} item={item} />)}
```

### 4.2 Why Keys Matter
React uses `key` to match previous and next tree nodes. A bad key (index, random) breaks identity, leading to:
- Lost local state
- Incorrect animations
- Performance regressions (more re-mounts)

### 4.3 Key Rules
1. Stable across renders
2. Unique among siblings
3. Derived from domain identity (id/slug/uuid)

```jsx
// ❌ Index key – fragile when items reorder
list.map((item, i) => <Item key={i} {...item} />);

// ✅ Domain identity key
list.map(item => <Item key={item.id} {...item} />);
```

---
## 5. Rich List Patterns

### 5.1 Filter + Sort + Paginate Pipeline
```jsx
const useProductsPipeline = (raw, { filters, sort, page, pageSize }) => {
  return useMemo(() => {
    let data = [...raw];
    if (filters.category) data = data.filter(p => p.category === filters.category);
    if (filters.q) {
      const q = filters.q.toLowerCase();
      data = data.filter(p => p.name.toLowerCase().includes(q));
    }
    if (filters.inStock) data = data.filter(p => p.stock > 0);
    switch (sort) {
      case 'price-asc':  data.sort((a,b)=>a.price-b.price); break;
      case 'price-desc': data.sort((a,b)=>b.price-a.price); break;
      case 'rating':     data.sort((a,b)=>b.rating-a.rating); break;
      default: break;
    }
    const total = data.length;
    const start = (page-1)*pageSize;
    return { slice: data.slice(start, start+pageSize), total };
  }, [raw, filters.category, filters.q, filters.inStock, sort, page, pageSize]);
};
```

### 5.2 Grouped Lists
```jsx
const groupBy = (arr, keyFn) => arr.reduce((acc, item) => {
  const k = keyFn(item);
  (acc[k] ||= []).push(item);
  return acc;
}, {});

const Contacts = ({ contacts }) => {
  const groups = useMemo(() => groupBy(contacts, c => c.name[0].toUpperCase()), [contacts]);
  return Object
    .entries(groups)
    .sort(([a],[b]) => a.localeCompare(b))
    .map(([letter, list]) => (
      <section key={letter}>
        <h3>{letter}</h3>
        {list.map(c => <ContactRow key={c.id} contact={c} />)}
      </section>
    ));
};
```

### 5.3 Nested & Recursive
```jsx
const Comment = ({ node }) => (
  <div className="comment">
    <Header author={node.author} />
    <p>{node.text}</p>
    {node.replies?.length > 0 && (
      <div className="replies">
        {node.replies.map(r => <Comment key={r.id} node={r} />)}
      </div>
    )}
  </div>
);
```

### 5.4 Virtualized (Large Data)
Use when list > ~500 rows or row height fixed/known.
```bash
npm install react-window
```
```jsx
import { FixedSizeList as List } from 'react-window';

const HugeList = ({ rows }) => (
  <List height={500} width={600} itemCount={rows.length} itemSize={48} itemData={rows}>
    {({ index, style, data }) => (
      <div style={style}> {data[index].label} </div>
    )}
  </List>
);
```

### 5.5 Infinite Scroll vs Pagination
| Approach | Pros | Cons |
|----------|------|------|
| Pagination | Predictable, indexable | More clicks |
| Infinite Scroll | Immersive | Hard to reach footer, SEO weaker |
| Load More Button | Balanced control | Manual action |

---
## 6. Dynamic List Mutation Patterns

### 6.1 Immutable Update Helpers
```jsx
const updateById = (list, id, updater) => list.map(i => i.id === id ? updater(i) : i);
const removeById = (list, id) => list.filter(i => i.id !== id);
const insertAt = (list, index, item) => [...list.slice(0,index), item, ...list.slice(index)];
```

### 6.2 Real-Time (WebSocket)
```jsx
function NotificationsStream() {
  const [items, setItems] = useState([]);
  useEffect(() => {
    const ws = new WebSocket('wss://example.com/notifications');
    ws.onmessage = e => {
      const note = JSON.parse(e.data);
      setItems(prev => [note, ...prev].slice(0, 100)); // cap size
    };
    return () => ws.close();
  }, []);
  return items.map(n => <Notification key={n.id} data={n} />);
}
```

### 6.3 Drag & Drop Ordering
```bash
npm install @dnd-kit/core
```
```jsx
import { DndContext, closestCenter, useSensor, PointerSensor, SortableContext, arrayMove } from '@dnd-kit/core';

function SortableList({ items, onChange }) {
  const sensors = [useSensor(PointerSensor)];
  return (
    <DndContext collisionDetection={closestCenter} sensors={sensors} onDragEnd={({ active, over }) => {
      if (over && active.id !== over.id) {
        const oldIdx = items.findIndex(i => i.id === active.id);
        const newIdx = items.findIndex(i => i.id === over.id);
        onChange(arrayMove(items, oldIdx, newIdx));
      }
    }}>
      <SortableContext items={items.map(i => i.id)}>
        {items.map(i => <SortableRow key={i.id} id={i.id} data={i} />)}
      </SortableContext>
    </DndContext>
  );
}
```

---
## 7. Performance Optimization Toolkit

| Problem | Symptom | Solution |
|---------|---------|----------|
| Unstable handlers | Child re-renders | `useCallback` on callbacks |
| Heavy calculation per item | Slow scroll | `useMemo` precompute, virtualization |
| Large list re-render on small change | UI jank | Item component `React.memo` + stable props |
| Key misuse | Lost state | Use stable unique domain keys |

### 7.1 Memoized Item
```jsx
const Row = React.memo(function Row({ item, onSelect }) {
  return (
    <div className="row" onClick={() => onSelect(item.id)}>
      {item.label}
    </div>
  );
});
```

### 7.2 Windowed Derived Data
```jsx
const useVisibleSlice = (data, { start, end }) => useMemo(() => data.slice(start, end), [data, start, end]);
```

---
## 8. UI State Patterns Inside Lists

### 8.1 Local Row State vs Central Store
| Choose | When |
|--------|------|
| Local state in item | Ephemeral UI toggles (expanded, hovered) |
| Parent-managed | Cross-row coordination (only one open) |
| External store | Persistence, multi-component sync |

### 8.2 Controlled Expansion
```jsx
function Accordion({ sections }) {
  const [openId, setOpenId] = useState(null);
  return sections.map(s => (
    <div key={s.id}>
      <button onClick={() => setOpenId(o => o === s.id ? null : s.id)}>{s.title}</button>
      {openId === s.id && <div className="panel">{s.content}</div>}
    </div>
  ));
}
```

---
## 9. Robust Empty / Loading / Error States
```jsx
function DataRegion({ state }) {
  if (state.loading) return <SkeletonRows count={8} />;
  if (state.error) return <ErrorPanel error={state.error} retry={state.retry} />;
  if (!state.items.length) return <Empty icon="📭" title="Nothing here yet" />;
  return state.items.map(i => <Row key={i.id} item={i} />);
}
```

---
## 10. Testing Rendering Logic
Focus tests on branches & identity.
```jsx
import { render, screen } from '@testing-library/react';

test('shows empty state', () => {
  render(<DataRegion state={{ loading: false, error: null, items: [] }} />);
  expect(screen.getByText(/Nothing here/i)).toBeInTheDocument();
});
```

---
## 11. Checklist & Heuristics
Render Review Checklist:
1. Are keys stable & unique? (No index unless truly static)
2. Are conditional branches readable? (Refactor nested ternaries)
3. Are loading / empty / error states explicit?
4. Are list transforms memoized when expensive?
5. Can large lists be virtualized?
6. Are permissions and flags centralized?
7. Are side-effects avoided in render logic?

---
## 12. Quick Reference
| Goal | Pattern |
|------|---------|
| Show either A or B | Ternary |
| Show only if true | `cond && <X/>` |
| Many discrete states | Lookup map / switch |
| Provide fallback layout | Wrapper Guard |
| Massive data | Virtualize |
| Mutate list immutably | map/filter/slice helpers |
| Avoid re-renders | `React.memo` + stable props |

---
## 13. Key Takeaways
1. Rendering is a pure description step; side effects belong in hooks.
2. Keys encode identity; get them wrong and UI lies to users.
3. Prefer clarity over cleverness—extract branches to functions.
4. Virtualization + memoization = scalable high-performance lists.
5. Guard early, render confidently.

> Next: Dive into effects & state sharing (Context, reducers) for managing cross-component state at scale.
# React Rendering Patterns: Lists, Conditions & Dynamic Content

## 🎯 Introduction: Building Dynamic User Interfaces

Dynamic rendering is what transforms static React components into interactive, data-driven applications. This comprehensive guide covers conditional rendering, list rendering, and advanced patterns that you'll use in every real-world React application.

## 🎭 Conditional Rendering Mastery

Conditional rendering allows you to show or hide UI elements based on state, props, or computed values. It's essential for creating responsive, interactive user interfaces.

### 🎪 The Four Pillars of Conditional Rendering

#### **1. Ternary Operator (? :) - If/Else Logic**

The ternary operator is perfect for **binary choices** where you need to render one thing or another.

```jsx
const UserAuthStatus = ({ user, isLoading, error }) => {
  return (
    <div className="auth-status">
      {/* Simple ternary for loading state */}
      {isLoading ? (
        <div className="loading">
          <Spinner />
          <p>Checking authentication...</p>
        </div>
      ) : (
        <div className="auth-content">
          {/* Nested ternary for user state */}
          {user ? (
            <div className="authenticated">
              <img src={user.avatar} alt={user.name} />
              <h2>Welcome back, {user.name}!</h2>
              <p>Last login: {formatDate(user.lastLogin)}</p>
              <LogoutButton />
            </div>
          ) : error ? (
            <div className="auth-error">
              <ErrorIcon />
              <h3>Authentication Failed</h3>
              <p>{error.message}</p>
              <RetryButton />
            </div>
          ) : (
            <div className="unauthenticated">
              <h2>Welcome, Guest!</h2>
              <p>Sign in to access your personalized experience</p>
              <LoginForm />
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// Advanced ternary with component selection
const StatusIndicator = ({ status, showDetails = false }) => {
  const StatusComponent = status === 'success' ? SuccessAlert :
                         status === 'warning' ? WarningAlert :
                         status === 'error' ? ErrorAlert :
                         InfoAlert;
  
  return (
    <div className="status-container">
      <StatusComponent detailed={showDetails} />
      {showDetails ? (
        <DetailedStatusInfo status={status} />
      ) : (
        <BasicStatusInfo status={status} />
      )}
    </div>
  );
};
```

#### **2. Logical AND (&&) - Show/Hide Elements**

Use logical AND for **conditional presence** - when you want to show something or nothing.

```jsx
const ProductCard = ({ product, user, cartItems, wishlistItems }) => {
  const isInCart = cartItems.some(item => item.id === product.id);
  const isInWishlist = wishlistItems.some(item => item.id === product.id);
  const canPurchase = product.stock > 0 && product.price > 0;
  const isDiscounted = product.originalPrice > product.currentPrice;
  
  return (
    <div className="product-card">
      <div className="product-image-container">
        <img src={product.image} alt={product.name} />
        
        {/* Sale badge - only show if discounted */}
        {isDiscounted && (
          <div className="sale-badge">
            {Math.round(((product.originalPrice - product.currentPrice) / product.originalPrice) * 100)}% OFF
          </div>
        )}
        
        {/* Stock indicator - only show if low stock */}
        {product.stock <= 5 && product.stock > 0 && (
          <div className="low-stock-warning">
            Only {product.stock} left!
          </div>
        )}
        
        {/* Out of stock overlay */}
        {product.stock === 0 && (
          <div className="out-of-stock-overlay">
            <span>Out of Stock</span>
          </div>
        )}
      </div>
      
      <div className="product-info">
        <h3>{product.name}</h3>
        <p className="description">{product.description}</p>
        
        <div className="pricing">
          <span className="current-price">${product.currentPrice}</span>
          {isDiscounted && (
            <span className="original-price">${product.originalPrice}</span>
          )}
        </div>
        
        {/* User-specific content - only show if logged in */}
        {user && (
          <div className="user-actions">
            <button 
              className={`wishlist-btn ${isInWishlist ? 'active' : ''}`}
              onClick={() => toggleWishlist(product.id)}
            >
              {isInWishlist ? '❤️ In Wishlist' : '🤍 Add to Wishlist'}
            </button>
            
            {canPurchase && (
              <button 
                className={`cart-btn ${isInCart ? 'in-cart' : ''}`}
                onClick={() => toggleCart(product.id)}
              >
                {isInCart ? '✓ In Cart' : '🛒 Add to Cart'}
              </button>
            )}
          </div>
        )}
        
        {/* Admin actions - only for admin users */}
        {user?.role === 'admin' && (
          <div className="admin-actions">
            <button onClick={() => editProduct(product.id)}>Edit</button>
            <button onClick={() => deleteProduct(product.id)}>Delete</button>
          </div>
        )}
        
        {/* Reviews section - only if product has reviews */}
        {product.reviews?.length > 0 && (
          <div className="reviews-preview">
            <div className="rating">
              ⭐ {product.averageRating} ({product.reviews.length} reviews)
            </div>
            <p className="latest-review">"{product.reviews[0].comment}"</p>
          </div>
        )}
      </div>
    </div>
  );
};
```

#### **3. Early Returns - Guard Clauses**

Use early returns for **error states** and **loading conditions** to keep your main component logic clean.

```jsx
const UserDashboard = ({ userId, permissions }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetchUserData(userId)
      .then(setUser)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [userId]);
  
  // 🛡️ Guard clause for missing userId
  if (!userId) {
    return (
      <div className="error-state">
        <h2>Invalid User</h2>
        <p>No user ID provided. Please check the URL and try again.</p>
        <Link to="/users">← Back to Users</Link>
      </div>
    );
  }
  
  // 🛡️ Guard clause for loading state
  if (loading) {
    return (
      <div className="loading-state">
        <Skeleton />
        <div className="loading-message">
          <Spinner />
          <p>Loading user dashboard...</p>
        </div>
      </div>
    );
  }
  
  // 🛡️ Guard clause for error state
  if (error) {
    return (
      <div className="error-state">
        <ErrorIcon />
        <h2>Failed to Load Dashboard</h2>
        <p>{error.message}</p>
        <div className="error-actions">
          <button onClick={() => window.location.reload()}>
            Retry
          </button>
          <Link to="/users">← Back to Users</Link>
        </div>
      </div>
    );
  }
  
  // 🛡️ Guard clause for missing user data
  if (!user) {
    return (
      <div className="not-found-state">
        <h2>User Not Found</h2>
        <p>The user with ID {userId} doesn't exist.</p>
        <Link to="/users">← Back to Users</Link>
      </div>
    );
  }
  
  // 🛡️ Guard clause for insufficient permissions
  if (!permissions.canViewDashboard) {
    return (
      <div className="access-denied">
        <h2>Access Denied</h2>
        <p>You don't have permission to view this dashboard.</p>
        <ContactSupportButton />
      </div>
    );
  }
  
  // 🎯 Main component logic - only runs with valid data
  return (
    <div className="user-dashboard">
      <DashboardHeader user={user} />
      
      <div className="dashboard-content">
        <div className="sidebar">
          <UserProfile user={user} />
          <QuickActions user={user} permissions={permissions} />
        </div>
        
        <div className="main-content">
          <RecentActivity userId={user.id} />
          <UserStats user={user} />
          <NotificationsPanel userId={user.id} />
        </div>
      </div>
    </div>
  );
};
```

#### **4. Switch-Case Pattern for Multiple Conditions**

Use switch-case patterns for **multiple distinct states** with clear, predictable outcomes.

```jsx
const NotificationItem = ({ notification }) => {
  const getNotificationConfig = (type) => {
    switch (type) {
      case 'success':
        return {
          icon: '✅',
          bgColor: 'bg-green-100',
          textColor: 'text-green-800',
          borderColor: 'border-green-200',
          title: 'Success',
          action: 'dismiss'
        };
      case 'warning':
        return {
          icon: '⚠️',
          bgColor: 'bg-yellow-100',
          textColor: 'text-yellow-800',
          borderColor: 'border-yellow-200',
          title: 'Warning',
          action: 'acknowledge'
        };
      case 'error':
        return {
          icon: '❌',
          bgColor: 'bg-red-100',
          textColor: 'text-red-800',
          borderColor: 'border-red-200',
          title: 'Error',
          action: 'retry'
        };
      case 'info':
        return {
          icon: 'ℹ️',
          bgColor: 'bg-blue-100',
          textColor: 'text-blue-800',
          borderColor: 'border-blue-200',
          title: 'Information',
          action: 'dismiss'
        };
      case 'promotion':
        return {
          icon: '🎉',
          bgColor: 'bg-purple-100',
          textColor: 'text-purple-800',
          borderColor: 'border-purple-200',
          title: 'Special Offer',
          action: 'view'
        };
      default:
        return {
          icon: '📢',
          bgColor: 'bg-gray-100',
          textColor: 'text-gray-800',
          borderColor: 'border-gray-200',
          title: 'Notification',
          action: 'dismiss'
        };
    }
  };
  
  const config = getNotificationConfig(notification.type);
  
  const getActionButton = (actionType, notification) => {
    switch (actionType) {
      case 'retry':
        return (
          <button 
            onClick={() => retryAction(notification.id)}
            className="bg-red-600 text-white px-3 py-1 rounded text-sm"
          >
            Retry
          </button>
        );
      case 'acknowledge':
        return (
          <button 
            onClick={() => acknowledgeNotification(notification.id)}
            className="bg-yellow-600 text-white px-3 py-1 rounded text-sm"
          >
            Got it
          </button>
        );
      case 'view':
        return (
          <button 
            onClick={() => viewPromotion(notification.id)}
            className="bg-purple-600 text-white px-3 py-1 rounded text-sm"
          >
            View Offer
          </button>
        );
      case 'dismiss':
      default:
        return (
          <button 
            onClick={() => dismissNotification(notification.id)}
            className="bg-gray-600 text-white px-3 py-1 rounded text-sm"
          >
            Dismiss
          </button>
        );
    }
  };
  
  return (
    <div className={`notification-item ${config.bgColor} ${config.borderColor} ${config.textColor} border-l-4 p-4 mb-2`}>
      <div className="flex items-start">
        <span className="text-2xl mr-3">{config.icon}</span>
        <div className="flex-1">
          <h4 className="font-semibold">{config.title}</h4>
          <p className="text-sm mt-1">{notification.message}</p>
          <p className="text-xs mt-2 opacity-75">
            {formatTimeAgo(notification.timestamp)}
          </p>
        </div>
        <div className="ml-4">
          {getActionButton(config.action, notification)}
        </div>
      </div>
    </div>
  );
};

// State-based rendering with switch
const ConnectionStatus = ({ status, lastSync, retryAttempts }) => {
  const renderStatusContent = () => {
    switch (status) {
      case 'connected':
        return (
          <div className="status-connected">
            <div className="status-indicator bg-green-500"></div>
            <div>
              <h3>Connected</h3>
              <p>Last sync: {formatTimeAgo(lastSync)}</p>
            </div>
          </div>
        );
        
      case 'connecting':
        return (
          <div className="status-connecting">
            <div className="status-indicator bg-yellow-500 animate-pulse"></div>
            <div>
              <h3>Connecting...</h3>
              <p>Establishing connection</p>
            </div>
          </div>
        );
        
      case 'disconnected':
        return (
          <div className="status-disconnected">
            <div className="status-indicator bg-red-500"></div>
            <div>
              <h3>Disconnected</h3>
              <p>Unable to connect to server</p>
              <button onClick={handleRetry}>
                Retry ({retryAttempts}/3)
              </button>
            </div>
          </div>
        );
        
      case 'error':
        return (
          <div className="status-error">
            <div className="status-indicator bg-red-600"></div>
            <div>
              <h3>Connection Error</h3>
              <p>Failed to establish connection</p>
              <div className="error-actions">
                <button onClick={handleRetry}>Retry</button>
                <button onClick={handleReset}>Reset</button>
              </div>
            </div>
          </div>
        );
        
      default:
        return (
          <div className="status-unknown">
            <div className="status-indicator bg-gray-500"></div>
            <div>
              <h3>Unknown Status</h3>
              <p>Unable to determine connection status</p>
            </div>
          </div>
        );
    }
  };
  
  return (
    <div className="connection-status">
      {renderStatusContent()}
    </div>
  );
};
```

### 🎨 Advanced Conditional Patterns

#### **1. Permission-Based Rendering**
```jsx
const ProtectedContent = ({ 
  children, 
  requiredPermissions = [], 
  requiredRole,
  user, 
  fallback,
  showFallback = true 
}) => {
  const hasPermission = (permission) => {
    return user?.permissions?.includes(permission);
  };
  
  const hasRole = (role) => {
    return user?.role === role || user?.roles?.includes(role);
  };
  
  const hasAllPermissions = requiredPermissions.every(hasPermission);
  const hasRequiredRole = !requiredRole || hasRole(requiredRole);
  const canAccess = hasAllPermissions && hasRequiredRole;
  
  if (!user) {
    return showFallback ? (
      <div className="auth-required">
        <h3>Authentication Required</h3>
        <p>Please log in to view this content.</p>
        <LoginButton />
      </div>
    ) : null;
  }
  
  if (!canAccess) {
    return showFallback ? (
      fallback || (
        <div className="access-denied">
          <h3>Access Denied</h3>
          <p>You don't have permission to view this content.</p>
          <ContactSupportButton />
        </div>
      )
    ) : null;
  }
  
  return children;
};

// Usage examples
<ProtectedContent 
  requiredPermissions={['read_users', 'manage_users']}
  user={currentUser}
>
  <UserManagementPanel />
</ProtectedContent>

<ProtectedContent 
  requiredRole="admin"
  user={currentUser}
  fallback={<p>Admin access only</p>}
>
  <AdminDashboard />
</ProtectedContent>
```

#### **2. Feature Flag Rendering**
```jsx
const FeatureFlag = ({ 
  feature, 
  children, 
  fallback = null,
  user,
  environment = 'production' 
}) => {
  const [featureFlags, setFeatureFlags] = useState({});
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchFeatureFlags(user?.id, environment)
      .then(setFeatureFlags)
      .finally(() => setLoading(false));
  }, [user?.id, environment]);
  
  if (loading) {
    return <div className="feature-loading">Loading...</div>;
  }
  
  const isEnabled = featureFlags[feature]?.enabled;
  const userInTestGroup = featureFlags[feature]?.testGroup?.includes(user?.id);
  const rolloutPercentage = featureFlags[feature]?.rollout || 0;
  const isInRollout = Math.random() * 100 < rolloutPercentage;
  
  const shouldShowFeature = isEnabled && (userInTestGroup || isInRollout);
  
  return shouldShowFeature ? children : fallback;
};

// Usage
<FeatureFlag feature="new_dashboard" user={user}>
  <NewDashboard />
</FeatureFlag>

<FeatureFlag 
  feature="beta_messaging" 
  user={user}
  fallback={<LegacyMessaging />}
>
  <BetaMessaging />
</FeatureFlag>
```

#### **3. Device-Based Rendering**
```jsx
const ResponsiveContent = ({ children }) => {
  const [deviceInfo, setDeviceInfo] = useState({
    isMobile: false,
    isTablet: false,
    isDesktop: false,
    screenWidth: 0,
    touchSupport: false
  });
  
  useEffect(() => {
    const updateDeviceInfo = () => {
      const width = window.innerWidth;
      setDeviceInfo({
        isMobile: width < 768,
        isTablet: width >= 768 && width < 1024,
        isDesktop: width >= 1024,
        screenWidth: width,
        touchSupport: 'ontouchstart' in window
      });
    };
    
    updateDeviceInfo();
    window.addEventListener('resize', updateDeviceInfo);
    return () => window.removeEventListener('resize', updateDeviceInfo);
  }, []);
  
  return React.Children.map(children, child => {
    if (React.isValidElement(child)) {
      return React.cloneElement(child, { deviceInfo });
    }
    return child;
  });
};

const AdaptiveNavigation = ({ deviceInfo }) => {
  if (deviceInfo?.isMobile) {
    return <MobileNavigation />;
  }
  
  if (deviceInfo?.isTablet) {
    return <TabletNavigation />;
  }
  
  return <DesktopNavigation />;
};

// Usage
<ResponsiveContent>
  <AdaptiveNavigation />
  <MainContent />
</ResponsiveContent>
```
      <button>System Settings</button>
    </div>
  );
  
  const UserPanel = () => (
    <div className="user-panel">
      <h3>User Dashboard</h3>
      <button>View Profile</button>
      <button>Change Password</button>
    </div>
  );
  
  return (
    <div>
      <h1>Dashboard</h1>
      {userRole === 'admin' ? <AdminPanel /> : <UserPanel />}
      
      {/* Multiple conditions */}
      {data ? (
        data.length > 0 ? (
          <DataTable data={data} />
        ) : (
          <EmptyState message="No data available" />
        )
      ) : (
        <LoadingSpinner />
      )}
    </div>
  );
}
```

### 2. Logical AND Operator (&&)

The `&&` operator is perfect for **if-then** scenarios where you either render something or nothing at all.

#### Basic AND Examples

```jsx
function Notifications({ notifications, showNotifications }) {
  return (
    <div>
      <h1>My App</h1>
      
      {/* Show notifications only if there are any */}
      {notifications.length > 0 && (
        <div className="notifications">
          <h3>Notifications ({notifications.length})</h3>
          {notifications.map(notification => (
            <div key={notification.id} className="notification">
              {notification.message}
            </div>
          ))}
        </div>
      )}
      
      {/* Show toggle only when notifications exist */}
      {notifications.length > 0 && (
        <button onClick={showNotifications}>
          {showNotifications ? 'Hide' : 'Show'} Notifications
        </button>
      )}
    </div>
  );
}

function UserBadge({ user, showBadge }) {
  return (
    <div className="user-info">
      <span>{user.name}</span>
      
      {/* Conditional badges */}
      {user.isPremium && <span className="badge premium">Premium</span>}
      {user.isVerified && <span className="badge verified">✓ Verified</span>}
      {user.isOnline && <span className="badge online">🟢 Online</span>}
      {user.unreadMessages > 0 && (
        <span className="badge messages">
          {user.unreadMessages} new messages
        </span>
      )}
    </div>
  );
}
```

#### Advanced AND Patterns

```jsx
function ShoppingCart({ items, isLoggedIn, shippingAddress }) {
  const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  const hasItems = items.length > 0;
  const canCheckout = isLoggedIn && hasItems && shippingAddress;
  
  return (
    <div className="shopping-cart">
      <h2>Shopping Cart</h2>
      
      {/* Show cart items only if there are any */}
      {hasItems && (
        <div className="cart-items">
          {items.map(item => (
            <div key={item.id} className="cart-item">
              <span>{item.name}</span>
              <span>Qty: {item.quantity}</span>
              <span>${item.price}</span>
            </div>
          ))}
        </div>
      )}
      
      {/* Show total only if there are items */}
      {hasItems && (
        <div className="cart-total">
          <strong>Total: ${total.toFixed(2)}</strong>
        </div>
      )}
      
      {/* Show empty state if no items */}
      {!hasItems && (
        <div className="empty-cart">
          <p>Your cart is empty</p>
          <button>Continue Shopping</button>
        </div>
      )}
      
      {/* Show login prompt if not logged in */}
      {!isLoggedIn && hasItems && (
        <div className="login-prompt">
          <p>Please log in to proceed with checkout</p>
          <button>Log In</button>
        </div>
      )}
      
      {/* Show address prompt if logged in but no address */}
      {isLoggedIn && hasItems && !shippingAddress && (
        <div className="address-prompt">
          <p>Please add a shipping address</p>
          <button>Add Address</button>
        </div>
      )}
      
      {/* Show checkout button only when everything is ready */}
      {canCheckout && (
        <button className="checkout-btn">
          Proceed to Checkout
        </button>
      )}
    </div>
  );
}
```

### 3. Early Return Pattern

For complex conditional logic, consider using early returns to make code more readable.

```jsx
function UserProfileCard({ user, isLoading, error }) {
  // Early returns for error states
  if (isLoading) {
    return (
      <div className="profile-card loading">
        <div className="skeleton"></div>
        <div className="skeleton"></div>
        <div className="skeleton"></div>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="profile-card error">
        <h3>Error Loading Profile</h3>
        <p>{error.message}</p>
        <button>Try Again</button>
      </div>
    );
  }
  
  if (!user) {
    return (
      <div className="profile-card empty">
        <p>No user data available</p>
      </div>
    );
  }
  
  // Main render
  return (
    <div className="profile-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      
      {user.bio && <p className="bio">{user.bio}</p>}
      {user.isVerified && <span className="verified">✓ Verified</span>}
      
      <div className="actions">
        <button>Message</button>
        <button>Follow</button>
      </div>
    </div>
  );
}
```

### 4. State-Based Conditional Rendering

```jsx
function WeatherWidget() {
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [unit, setUnit] = useState('celsius');
  
  const fetchWeather = async (city) => {
    setLoading(true);
    setError(null);
    
    try {
      const data = await weatherAPI.getWeather(city);
      setWeather(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="weather-widget">
      <h3>Weather Widget</h3>
      
      {/* Search form */}
      <form onSubmit={(e) => {
        e.preventDefault();
        const city = e.target.city.value;
        fetchWeather(city);
      }}>
        <input name="city" placeholder="Enter city name" />
        <button type="submit" disabled={loading}>
          {loading ? 'Searching...' : 'Get Weather'}
        </button>
      </form>
      
      {/* Unit toggle - only show if we have weather data */}
      {weather && (
        <div className="unit-toggle">
          <button 
            className={unit === 'celsius' ? 'active' : ''}
            onClick={() => setUnit('celsius')}
          >
            °C
          </button>
          <button 
            className={unit === 'fahrenheit' ? 'active' : ''}
            onClick={() => setUnit('fahrenheit')}
          >
            °F
          </button>
        </div>
      )}
      
      {/* Loading state */}
      {loading && (
        <div className="loading">
          <div className="spinner"></div>
          <p>Fetching weather data...</p>
        </div>
      )}
      
      {/* Error state */}
      {error && (
        <div className="error">
          <p>⚠️ {error}</p>
          <button onClick={() => setError(null)}>Dismiss</button>
        </div>
      )}
      
      {/* Weather data */}
      {weather && !loading && !error && (
        <div className="weather-info">
          <h4>{weather.city}</h4>
          <div className="temperature">
            {unit === 'celsius' ? weather.tempC : weather.tempF}°
            {unit === 'celsius' ? 'C' : 'F'}
          </div>
          <div className="condition">{weather.condition}</div>
          <div className="details">
            <span>Humidity: {weather.humidity}%</span>
            <span>Wind: {weather.windSpeed} km/h</span>
          </div>
        </div>
      )}
      
      {/* No data state */}
      {!weather && !loading && !error && (
        <div className="no-data">
          <p>🌤️ Enter a city name to get weather information</p>
        </div>
      )}
    </div>
  );
}
```

## 5.2 Rendering Lists with .map()

The `.map()` method is the standard React pattern for transforming arrays of data into arrays of JSX elements. It's the go-to solution for rendering dynamic lists.

### Basic List Rendering

```jsx
function BasicList() {
  const fruits = ['Apple', 'Banana', 'Orange', 'Grape'];
  
  return (
    <div>
      <h3>Fruits List</h3>
      <ul>
        {fruits.map((fruit, index) => (
          <li key={index}>{fruit}</li>
        ))}
      </ul>
    </div>
  );
}

function NumbersList() {
  const numbers = [1, 2, 3, 4, 5];
  
  return (
    <div>
      <h3>Numbers</h3>
      <div className="numbers-grid">
        {numbers.map(number => (
          <div key={number} className="number-card">
            <span>{number}</span>
            <span>Square: {number * number}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Rendering Objects

```jsx
function UserList() {
  const users = [
    { id: 1, name: 'John Doe', email: 'john@example.com', role: 'admin' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'user' },
    { id: 3, name: 'Bob Johnson', email: 'bob@example.com', role: 'user' }
  ];
  
  return (
    <div className="user-list">
      <h3>Users</h3>
      {users.map(user => (
        <div key={user.id} className="user-card">
          <h4>{user.name}</h4>
          <p>{user.email}</p>
          <span className={`role ${user.role}`}>
            {user.role}
          </span>
        </div>
      ))}
    </div>
  );
}

function ProductGrid() {
  const products = [
    {
      id: 'p1',
      name: 'Laptop',
      price: 999,
      image: '/laptop.jpg',
      rating: 4.5,
      inStock: true
    },
    {
      id: 'p2',
      name: 'Smartphone',
      price: 599,
      image: '/phone.jpg',
      rating: 4.2,
      inStock: false
    },
    {
      id: 'p3',
      name: 'Headphones',
      price: 199,
      image: '/headphones.jpg',
      rating: 4.8,
      inStock: true
    }
  ];
  
  return (
    <div className="product-grid">
      {products.map(product => (
        <div key={product.id} className="product-card">
          <img src={product.image} alt={product.name} />
          <h3>{product.name}</h3>
          <div className="price">${product.price}</div>
          <div className="rating">
            {'★'.repeat(Math.floor(product.rating))} {product.rating}
          </div>
          
          {product.inStock ? (
            <button className="add-to-cart">Add to Cart</button>
          ) : (
            <button className="out-of-stock" disabled>
              Out of Stock
            </button>
          )}
        </div>
      ))}
    </div>
  );
}
```

### Interactive Lists with State

```jsx
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', completed: false, priority: 'high' },
    { id: 2, text: 'Build a project', completed: false, priority: 'medium' },
    { id: 3, text: 'Deploy to production', completed: false, priority: 'low' }
  ]);
  
  const [filter, setFilter] = useState('all'); // 'all', 'completed', 'pending'
  const [sortBy, setSortBy] = useState('priority'); // 'priority', 'alphabetical'
  
  const toggleTodo = (id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  const deleteTodo = (id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };
  
  // Filter todos based on current filter
  const filteredTodos = todos.filter(todo => {
    if (filter === 'completed') return todo.completed;
    if (filter === 'pending') return !todo.completed;
    return true; // 'all'
  });
  
  // Sort todos
  const sortedTodos = [...filteredTodos].sort((a, b) => {
    if (sortBy === 'alphabetical') {
      return a.text.localeCompare(b.text);
    }
    if (sortBy === 'priority') {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    }
    return 0;
  });
  
  return (
    <div className="todo-app">
      <h3>Todo List</h3>
      
      {/* Filters and sorting */}
      <div className="controls">
        <div className="filters">
          <button 
            className={filter === 'all' ? 'active' : ''}
            onClick={() => setFilter('all')}
          >
            All ({todos.length})
          </button>
          <button 
            className={filter === 'pending' ? 'active' : ''}
            onClick={() => setFilter('pending')}
          >
            Pending ({todos.filter(t => !t.completed).length})
          </button>
          <button 
            className={filter === 'completed' ? 'active' : ''}
            onClick={() => setFilter('completed')}
          >
            Completed ({todos.filter(t => t.completed).length})
          </button>
        </div>
        
        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
          <option value="priority">Sort by Priority</option>
          <option value="alphabetical">Sort Alphabetically</option>
        </select>
      </div>
      
      {/* Todo list */}
      <div className="todo-list">
        {sortedTodos.length === 0 ? (
          <div className="empty-state">
            <p>No todos found for "{filter}" filter</p>
          </div>
        ) : (
          sortedTodos.map(todo => (
            <div 
              key={todo.id} 
              className={`todo-item ${todo.completed ? 'completed' : ''} priority-${todo.priority}`}
            >
              <input
                type="checkbox"
                checked={todo.completed}
                onChange={() => toggleTodo(todo.id)}
              />
              
              <span className="todo-text">{todo.text}</span>
              
              <span className={`priority-badge ${todo.priority}`}>
                {todo.priority}
              </span>
              
              <button 
                className="delete-btn"
                onClick={() => deleteTodo(todo.id)}
              >
                ×
              </button>
            </div>
          ))
        )}
      </div>
    </div>
  );
}
```

### Nested Lists

```jsx
function NestedList() {
  const categories = [
    {
      id: 'electronics',
      name: 'Electronics',
      items: [
        { id: 'laptop', name: 'Laptop', price: 999 },
        { id: 'phone', name: 'Smartphone', price: 599 }
      ]
    },
    {
      id: 'clothing',
      name: 'Clothing',
      items: [
        { id: 'shirt', name: 'T-Shirt', price: 29 },
        { id: 'jeans', name: 'Jeans', price: 79 }
      ]
    }
  ];
  
  return (
    <div className="nested-list">
      {categories.map(category => (
        <div key={category.id} className="category">
          <h3>{category.name}</h3>
          <div className="items">
            {category.items.map(item => (
              <div key={item.id} className="item">
                <span>{item.name}</span>
                <span>${item.price}</span>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}
```

### Dynamic List Updates

```jsx
function DynamicUserList() {
  const [users, setUsers] = useState([
    { id: 1, name: 'Alice', status: 'online', lastSeen: new Date() },
    { id: 2, name: 'Bob', status: 'offline', lastSeen: new Date(Date.now() - 3600000) }
  ]);
  
  const [newUserName, setNewUserName] = useState('');
  
  const addUser = () => {
    if (newUserName.trim()) {
      const newUser = {
        id: Date.now(), // Simple ID generation
        name: newUserName.trim(),
        status: 'online',
        lastSeen: new Date()
      };
      
      setUsers(prev => [...prev, newUser]);
      setNewUserName('');
    }
  };
  
  const removeUser = (id) => {
    setUsers(prev => prev.filter(user => user.id !== id));
  };
  
  const toggleUserStatus = (id) => {
    setUsers(prev => prev.map(user =>
      user.id === id
        ? { 
            ...user, 
            status: user.status === 'online' ? 'offline' : 'online',
            lastSeen: new Date()
          }
        : user
    ));
  };
  
  return (
    <div className="dynamic-user-list">
      <h3>User Management</h3>
      
      {/* Add user form */}
      <div className="add-user">
        <input
          type="text"
          value={newUserName}
          onChange={(e) => setNewUserName(e.target.value)}
          placeholder="Enter user name"
          onKeyPress={(e) => e.key === 'Enter' && addUser()}
        />
        <button onClick={addUser}>Add User</button>
      </div>
      
      {/* Users list */}
      <div className="users">
        {users.length === 0 ? (
          <p>No users found. Add some users above.</p>
        ) : (
          users.map(user => (
            <div key={user.id} className={`user-item ${user.status}`}>
              <div className="user-info">
                <span className="name">{user.name}</span>
                <span className={`status ${user.status}`}>
                  {user.status === 'online' ? '🟢' : '🔴'} {user.status}
                </span>
                <span className="last-seen">
                  Last seen: {user.lastSeen.toLocaleTimeString()}
                </span>
              </div>
              
              <div className="actions">
                <button onClick={() => toggleUserStatus(user.id)}>
                  {user.status === 'online' ? 'Set Offline' : 'Set Online'}
                </button>
                <button onClick={() => removeUser(user.id)}>
                  Remove
                </button>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
}
```

## 5.3 The key Prop

The `key` prop is one of the most critical concepts in React list rendering. It helps React identify which items have changed, been added, or been removed, enabling efficient updates and preventing bugs.

### Why Keys Matter

Without proper keys, React uses the array index by default, which can cause:
- **Performance issues**: Unnecessary re-renders
- **State bugs**: Component state getting mixed up
- **Animation glitches**: Incorrect transitions
- **Focus problems**: Input focus jumping to wrong elements

### What Makes a Good Key

#### ✅ Good Keys
```jsx
// Unique, stable identifiers
const users = [
  { id: 'user_123', name: 'Alice' },
  { id: 'user_456', name: 'Bob' }
];

users.map(user => (
  <UserCard key={user.id} user={user} />
));

// Database IDs
const posts = [
  { postId: 1, title: 'First Post' },
  { postId: 2, title: 'Second Post' }
];

posts.map(post => (
  <BlogPost key={post.postId} post={post} />
));

// UUIDs
const items = [
  { uuid: 'a1b2c3d4-e5f6-7890', name: 'Item 1' },
  { uuid: 'x1y2z3w4-a5b6-7890', name: 'Item 2' }
];

items.map(item => (
  <Item key={item.uuid} item={item} />
));
```

#### ❌ Bad Keys
```jsx
// Array index (can cause bugs when order changes)
items.map((item, index) => (
  <Item key={index} item={item} /> // ❌ Don't use index
));

// Non-unique values
items.map(item => (
  <Item key={item.category} item={item} /> // ❌ Multiple items might have same category
));

// Changing values
items.map(item => (
  <Item key={Math.random()} item={item} /> // ❌ Key changes every render
));
```

### Demonstrating Key Problems

```jsx
function KeyProblemDemo() {
  const [items, setItems] = useState([
    { id: 1, name: 'Apple', color: 'red' },
    { id: 2, name: 'Banana', color: 'yellow' },
    { id: 3, name: 'Orange', color: 'orange' }
  ]);
  
  const addItemToTop = () => {
    const newItem = {
      id: Date.now(),
      name: 'New Fruit',
      color: 'green'
    };
    setItems(prev => [newItem, ...prev]);
  };
  
  const removeFirstItem = () => {
    setItems(prev => prev.slice(1));
  };
  
  // Component that maintains its own state
  const ItemWithInput = ({ item, keyType }) => {
    const [inputValue, setInputValue] = useState('');
    
    return (
      <div className="item-with-input">
        <span>{item.name} ({item.color})</span>
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Type something..."
        />
      </div>
    );
  };
  
  return (
    <div className="key-demo">
      <h3>Key Demonstration</h3>
      
      <div className="controls">
        <button onClick={addItemToTop}>Add Item to Top</button>
        <button onClick={removeFirstItem}>Remove First Item</button>
      </div>
      
      <div className="comparison">
        <div className="list-section">
          <h4>❌ Bad: Using Array Index as Key</h4>
          {items.map((item, index) => (
            <ItemWithInput 
              key={index} // Bad: using index
              item={item} 
            />
          ))}
        </div>
        
        <div className="list-section">
          <h4>✅ Good: Using Stable ID as Key</h4>
          {items.map(item => (
            <ItemWithInput 
              key={item.id} // Good: using stable ID
              item={item} 
            />
          ))}
        </div>
      </div>
      
      <div className="explanation">
        <p>
          <strong>Try this:</strong> Type different text in each input, then add or remove items.
          Notice how the text moves incorrectly in the "bad" example but stays correct in the "good" example.
        </p>
      </div>
    </div>
  );
}
```

### Keys in Different Scenarios

#### 1. Reordering Lists

```jsx
function ReorderableList() {
  const [tasks, setTasks] = useState([
    { id: 'task_1', name: 'Design mockups', priority: 1 },
    { id: 'task_2', name: 'Implement frontend', priority: 2 },
    { id: 'task_3', name: 'Write tests', priority: 3 },
    { id: 'task_4', name: 'Deploy to staging', priority: 4 }
  ]);
  
  const moveUp = (id) => {
    setTasks(prev => {
      const index = prev.findIndex(task => task.id === id);
      if (index <= 0) return prev;
      
      const newTasks = [...prev];
      [newTasks[index - 1], newTasks[index]] = [newTasks[index], newTasks[index - 1]];
      return newTasks;
    });
  };
  
  const moveDown = (id) => {
    setTasks(prev => {
      const index = prev.findIndex(task => task.id === id);
      if (index >= prev.length - 1) return prev;
      
      const newTasks = [...prev];
      [newTasks[index], newTasks[index + 1]] = [newTasks[index + 1], newTasks[index]];
      return newTasks;
    });
  };
  
  return (
    <div className="reorderable-list">
      <h3>Task Priority List</h3>
      <p>Use the arrows to reorder tasks. Notice how the keys prevent state bugs.</p>
      
      {tasks.map((task, index) => (
        <div key={task.id} className="task-item">
          <span className="priority">#{task.priority}</span>
          <span className="name">{task.name}</span>
          
          <div className="controls">
            <button 
              onClick={() => moveUp(task.id)}
              disabled={index === 0}
            >
              ↑
            </button>
            <button 
              onClick={() => moveDown(task.id)}
              disabled={index === tasks.length - 1}
            >
              ↓
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}
```

#### 2. Filtering Lists

```jsx
function FilterableList() {
  const [filter, setFilter] = useState('');
  
  const allItems = [
    { id: 'item_1', name: 'Apple iPhone', category: 'electronics', price: 999 },
    { id: 'item_2', name: 'Samsung Galaxy', category: 'electronics', price: 899 },
    { id: 'item_3', name: 'Nike Shoes', category: 'clothing', price: 120 },
    { id: 'item_4', name: 'Adidas Jacket', category: 'clothing', price: 80 },
    { id: 'item_5', name: 'MacBook Pro', category: 'electronics', price: 1999 }
  ];
  
  const filteredItems = allItems.filter(item =>
    item.name.toLowerCase().includes(filter.toLowerCase()) ||
    item.category.toLowerCase().includes(filter.toLowerCase())
  );
  
  return (
    <div className="filterable-list">
      <h3>Product Search</h3>
      
      <input
        type="text"
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        placeholder="Search products..."
      />
      
      <div className="results">
        {filteredItems.length === 0 ? (
          <p>No products found matching "{filter}"</p>
        ) : (
          filteredItems.map(item => (
            <div key={item.id} className="product-item">
              <h4>{item.name}</h4>
              <span className="category">{item.category}</span>
              <span className="price">${item.price}</span>
            </div>
          ))
        )}
      </div>
      
      <div className="meta">
        Showing {filteredItems.length} of {allItems.length} products
      </div>
    </div>
  );
}
```

#### 3. Dynamic Lists with User Input

```jsx
function DynamicList() {
  const [items, setItems] = useState([]);
  const [newItem, setNewItem] = useState('');
  const [editingId, setEditingId] = useState(null);
  
  const addItem = () => {
    if (newItem.trim()) {
      const item = {
        id: crypto.randomUUID(), // Modern way to generate unique IDs
        text: newItem.trim(),
        createdAt: new Date(),
        isCompleted: false
      };
      
      setItems(prev => [...prev, item]);
      setNewItem('');
    }
  };
  
  const deleteItem = (id) => {
    setItems(prev => prev.filter(item => item.id !== id));
  };
  
  const toggleComplete = (id) => {
    setItems(prev => prev.map(item =>
      item.id === id 
        ? { ...item, isCompleted: !item.isCompleted }
        : item
    ));
  };
  
  const startEdit = (id) => {
    setEditingId(id);
  };
  
  const saveEdit = (id, newText) => {
    setItems(prev => prev.map(item =>
      item.id === id 
        ? { ...item, text: newText }
        : item
    ));
    setEditingId(null);
  };
  
  const cancelEdit = () => {
    setEditingId(null);
  };
  
  return (
    <div className="dynamic-list">
      <h3>Dynamic Todo List</h3>
      
      <div className="add-item">
        <input
          type="text"
          value={newItem}
          onChange={(e) => setNewItem(e.target.value)}
          placeholder="Add new item..."
          onKeyPress={(e) => e.key === 'Enter' && addItem()}
        />
        <button onClick={addItem}>Add</button>
      </div>
      
      <div className="items">
        {items.map(item => (
          <TodoItem
            key={item.id} // Crucial: stable unique key
            item={item}
            isEditing={editingId === item.id}
            onToggle={() => toggleComplete(item.id)}
            onDelete={() => deleteItem(item.id)}
            onStartEdit={() => startEdit(item.id)}
            onSaveEdit={(text) => saveEdit(item.id, text)}
            onCancelEdit={cancelEdit}
          />
        ))}
      </div>
      
      {items.length === 0 && (
        <div className="empty-state">
          <p>No items yet. Add one above!</p>
        </div>
      )}
    </div>
  );
}

function TodoItem({ 
  item, 
  isEditing, 
  onToggle, 
  onDelete, 
  onStartEdit, 
  onSaveEdit, 
  onCancelEdit 
}) {
  const [editText, setEditText] = useState(item.text);
  
  const handleSave = () => {
    if (editText.trim()) {
      onSaveEdit(editText.trim());
    } else {
      onCancelEdit();
    }
  };
  
  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      handleSave();
    } else if (e.key === 'Escape') {
      setEditText(item.text);
      onCancelEdit();
    }
  };
  
  if (isEditing) {
    return (
      <div className="todo-item editing">
        <input
          type="text"
          value={editText}
          onChange={(e) => setEditText(e.target.value)}
          onKeyPress={handleKeyPress}
          onBlur={handleSave}
          autoFocus
        />
        <button onClick={handleSave}>Save</button>
        <button onClick={onCancelEdit}>Cancel</button>
      </div>
    );
  }
  
  return (
    <div className={`todo-item ${item.isCompleted ? 'completed' : ''}`}>
      <input
        type="checkbox"
        checked={item.isCompleted}
        onChange={onToggle}
      />
      
      <span className="text" onClick={onToggle}>
        {item.text}
      </span>
      
      <span className="created-at">
        {item.createdAt.toLocaleTimeString()}
      </span>
      
      <div className="actions">
        <button onClick={onStartEdit}>Edit</button>
        <button onClick={onDelete}>Delete</button>
      </div>
    </div>
  );
}
```

### Performance Implications of Keys

```jsx
function PerformanceDemo() {
  const [items, setItems] = useState(
    Array.from({ length: 1000 }, (_, i) => ({
      id: `item_${i}`,
      value: Math.random(),
      timestamp: Date.now() + i
    }))
  );
  
  const [renderCount, setRenderCount] = useState(0);
  
  const shuffleItems = () => {
    setItems(prev => [...prev].sort(() => Math.random() - 0.5));
    setRenderCount(prev => prev + 1);
  };
  
  const addItemToMiddle = () => {
    const newItem = {
      id: `item_${Date.now()}`,
      value: Math.random(),
      timestamp: Date.now()
    };
    
    setItems(prev => {
      const middle = Math.floor(prev.length / 2);
      return [
        ...prev.slice(0, middle),
        newItem,
        ...prev.slice(middle)
      ];
    });
    setRenderCount(prev => prev + 1);
  };
  
  return (
    <div className="performance-demo">
      <h3>Performance Demo (1000 items)</h3>
      <p>Render count: {renderCount}</p>
      
      <div className="controls">
        <button onClick={shuffleItems}>Shuffle Items</button>
        <button onClick={addItemToMiddle}>Add Item to Middle</button>
      </div>
      
      <div className="items-container" style={{ maxHeight: '300px', overflow: 'auto' }}>
        {items.map(item => (
          <PerformanceItem key={item.id} item={item} />
        ))}
      </div>
    </div>
  );
}

function PerformanceItem({ item }) {
  const [renderCount, setRenderCount] = useState(0);
  
  // Track renders (development only)
  useEffect(() => {
    setRenderCount(prev => prev + 1);
  });
  
  return (
    <div className="performance-item">
      <span>ID: {item.id}</span>
      <span>Value: {item.value.toFixed(4)}</span>
      <span>Renders: {renderCount}</span>
    </div>
  );
}
```

### Key Best Practices Summary

#### ✅ Do:
- Use unique, stable identifiers (database IDs, UUIDs)
- Keep keys consistent across re-renders
- Use the same key for the same logical item
- Consider performance with large lists

#### ❌ Don't:
- Use array indices unless the list never changes
- Use random values or dates as keys
- Use non-unique values as keys
- Change key values unnecessarily

```jsx
// ✅ Perfect key usage
function BestPracticeExample() {
  const [users, setUsers] = useState([
    { userId: 'u123', name: 'Alice', email: 'alice@example.com' },
    { userId: 'u456', name: 'Bob', email: 'bob@example.com' }
  ]);
  
  return (
    <div>
      {users.map(user => (
        <UserProfile 
          key={user.userId} // ✅ Stable, unique identifier
          user={user}
        />
      ))}
    </div>
  );
}
```

## Summary

Conditional rendering and list rendering are fundamental React patterns:

### Key Takeaways:

1. **Conditional Rendering**:
   - Use ternary (`? :`) for if-else scenarios
   - Use logical AND (`&&`) for if-then scenarios
   - Consider early returns for complex conditions

2. **List Rendering**:
   - Use `.map()` to transform arrays into JSX
   - Always provide a `key` prop for list items
   - Handle empty states gracefully

3. **The Key Prop**:
   - Critical for performance and correctness
   - Must be unique and stable
   - Never use array indices for dynamic lists
   - Use database IDs or UUIDs when possible

### Best Practices:
- ✅ Plan your key strategy early
- ✅ Use stable, unique identifiers
- ✅ Handle loading and empty states
- ✅ Consider performance with large lists
- ✅ Test list operations (add, remove, reorder)

### Performance Tips:
- Use `React.memo()` for expensive list items
- Consider virtualization for very large lists
- Optimize key generation for dynamic content
- Profile performance with React DevTools

**Next Steps**: Learn about `useEffect` for side effects, data fetching patterns, and advanced component lifecycle management!