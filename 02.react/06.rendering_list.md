# React Rendering Patterns: Lists and Conditional Logic

## 5.1 Conditional Rendering

Conditional rendering in React allows you to show or hide UI elements based on certain conditions. It's essential for creating dynamic, interactive user interfaces that respond to state changes and user interactions.

### Understanding Conditional Rendering

In traditional HTML, content is static. In React, you can dynamically decide what to render based on:
- Component state
- Props values
- User authentication status
- Data availability
- Error conditions

### 1. Ternary Operator (? :)

The ternary operator is perfect for **if-else** scenarios where you need to render one thing or another.

#### Basic Ternary Examples

```jsx
function UserStatus({ isLoggedIn, username }) {
  return (
    <div>
      {isLoggedIn ? (
        <h1>Welcome back, {username}!</h1>
      ) : (
        <h1>Please log in</h1>
      )}
    </div>
  );
}

function LoadingSpinner({ isLoading, data }) {
  return (
    <div>
      {isLoading ? (
        <div className="spinner">Loading...</div>
      ) : (
        <div className="content">{data}</div>
      )}
    </div>
  );
}
```

#### Complex Ternary Patterns

```jsx
function UserProfile({ user, isEditing }) {
  return (
    <div className="user-profile">
      {isEditing ? (
        // Edit mode
        <form>
          <input defaultValue={user.name} placeholder="Name" />
          <input defaultValue={user.email} placeholder="Email" />
          <button type="submit">Save</button>
          <button type="button">Cancel</button>
        </form>
      ) : (
        // View mode
        <div>
          <h2>{user.name}</h2>
          <p>{user.email}</p>
          <button>Edit Profile</button>
        </div>
      )}
    </div>
  );
}

// Nested ternary (use sparingly)
function MessageStatus({ status, message }) {
  return (
    <div>
      {status === 'loading' ? (
        <span>Sending...</span>
      ) : status === 'success' ? (
        <span style={{ color: 'green' }}>‚úì Sent successfully</span>
      ) : status === 'error' ? (
        <span style={{ color: 'red' }}>‚úó Failed to send</span>
      ) : (
        <span>Ready to send</span>
      )}
    </div>
  );
}
```

#### Ternary with Components

```jsx
function Dashboard({ userRole, data }) {
  const AdminPanel = () => (
    <div className="admin-panel">
      <h3>Admin Controls</h3>
      <button>Manage Users</button>
      <button>View Analytics</button>
      <button>System Settings</button>
    </div>
  );
  
  const UserPanel = () => (
    <div className="user-panel">
      <h3>User Dashboard</h3>
      <button>View Profile</button>
      <button>Change Password</button>
    </div>
  );
  
  return (
    <div>
      <h1>Dashboard</h1>
      {userRole === 'admin' ? <AdminPanel /> : <UserPanel />}
      
      {/* Multiple conditions */}
      {data ? (
        data.length > 0 ? (
          <DataTable data={data} />
        ) : (
          <EmptyState message="No data available" />
        )
      ) : (
        <LoadingSpinner />
      )}
    </div>
  );
}
```

### 2. Logical AND Operator (&&)

The `&&` operator is perfect for **if-then** scenarios where you either render something or nothing at all.

#### Basic AND Examples

```jsx
function Notifications({ notifications, showNotifications }) {
  return (
    <div>
      <h1>My App</h1>
      
      {/* Show notifications only if there are any */}
      {notifications.length > 0 && (
        <div className="notifications">
          <h3>Notifications ({notifications.length})</h3>
          {notifications.map(notification => (
            <div key={notification.id} className="notification">
              {notification.message}
            </div>
          ))}
        </div>
      )}
      
      {/* Show toggle only when notifications exist */}
      {notifications.length > 0 && (
        <button onClick={showNotifications}>
          {showNotifications ? 'Hide' : 'Show'} Notifications
        </button>
      )}
    </div>
  );
}

function UserBadge({ user, showBadge }) {
  return (
    <div className="user-info">
      <span>{user.name}</span>
      
      {/* Conditional badges */}
      {user.isPremium && <span className="badge premium">Premium</span>}
      {user.isVerified && <span className="badge verified">‚úì Verified</span>}
      {user.isOnline && <span className="badge online">üü¢ Online</span>}
      {user.unreadMessages > 0 && (
        <span className="badge messages">
          {user.unreadMessages} new messages
        </span>
      )}
    </div>
  );
}
```

#### Advanced AND Patterns

```jsx
function ShoppingCart({ items, isLoggedIn, shippingAddress }) {
  const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  const hasItems = items.length > 0;
  const canCheckout = isLoggedIn && hasItems && shippingAddress;
  
  return (
    <div className="shopping-cart">
      <h2>Shopping Cart</h2>
      
      {/* Show cart items only if there are any */}
      {hasItems && (
        <div className="cart-items">
          {items.map(item => (
            <div key={item.id} className="cart-item">
              <span>{item.name}</span>
              <span>Qty: {item.quantity}</span>
              <span>${item.price}</span>
            </div>
          ))}
        </div>
      )}
      
      {/* Show total only if there are items */}
      {hasItems && (
        <div className="cart-total">
          <strong>Total: ${total.toFixed(2)}</strong>
        </div>
      )}
      
      {/* Show empty state if no items */}
      {!hasItems && (
        <div className="empty-cart">
          <p>Your cart is empty</p>
          <button>Continue Shopping</button>
        </div>
      )}
      
      {/* Show login prompt if not logged in */}
      {!isLoggedIn && hasItems && (
        <div className="login-prompt">
          <p>Please log in to proceed with checkout</p>
          <button>Log In</button>
        </div>
      )}
      
      {/* Show address prompt if logged in but no address */}
      {isLoggedIn && hasItems && !shippingAddress && (
        <div className="address-prompt">
          <p>Please add a shipping address</p>
          <button>Add Address</button>
        </div>
      )}
      
      {/* Show checkout button only when everything is ready */}
      {canCheckout && (
        <button className="checkout-btn">
          Proceed to Checkout
        </button>
      )}
    </div>
  );
}
```

### 3. Early Return Pattern

For complex conditional logic, consider using early returns to make code more readable.

```jsx
function UserProfileCard({ user, isLoading, error }) {
  // Early returns for error states
  if (isLoading) {
    return (
      <div className="profile-card loading">
        <div className="skeleton"></div>
        <div className="skeleton"></div>
        <div className="skeleton"></div>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="profile-card error">
        <h3>Error Loading Profile</h3>
        <p>{error.message}</p>
        <button>Try Again</button>
      </div>
    );
  }
  
  if (!user) {
    return (
      <div className="profile-card empty">
        <p>No user data available</p>
      </div>
    );
  }
  
  // Main render
  return (
    <div className="profile-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      
      {user.bio && <p className="bio">{user.bio}</p>}
      {user.isVerified && <span className="verified">‚úì Verified</span>}
      
      <div className="actions">
        <button>Message</button>
        <button>Follow</button>
      </div>
    </div>
  );
}
```

### 4. State-Based Conditional Rendering

```jsx
function WeatherWidget() {
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [unit, setUnit] = useState('celsius');
  
  const fetchWeather = async (city) => {
    setLoading(true);
    setError(null);
    
    try {
      const data = await weatherAPI.getWeather(city);
      setWeather(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="weather-widget">
      <h3>Weather Widget</h3>
      
      {/* Search form */}
      <form onSubmit={(e) => {
        e.preventDefault();
        const city = e.target.city.value;
        fetchWeather(city);
      }}>
        <input name="city" placeholder="Enter city name" />
        <button type="submit" disabled={loading}>
          {loading ? 'Searching...' : 'Get Weather'}
        </button>
      </form>
      
      {/* Unit toggle - only show if we have weather data */}
      {weather && (
        <div className="unit-toggle">
          <button 
            className={unit === 'celsius' ? 'active' : ''}
            onClick={() => setUnit('celsius')}
          >
            ¬∞C
          </button>
          <button 
            className={unit === 'fahrenheit' ? 'active' : ''}
            onClick={() => setUnit('fahrenheit')}
          >
            ¬∞F
          </button>
        </div>
      )}
      
      {/* Loading state */}
      {loading && (
        <div className="loading">
          <div className="spinner"></div>
          <p>Fetching weather data...</p>
        </div>
      )}
      
      {/* Error state */}
      {error && (
        <div className="error">
          <p>‚ö†Ô∏è {error}</p>
          <button onClick={() => setError(null)}>Dismiss</button>
        </div>
      )}
      
      {/* Weather data */}
      {weather && !loading && !error && (
        <div className="weather-info">
          <h4>{weather.city}</h4>
          <div className="temperature">
            {unit === 'celsius' ? weather.tempC : weather.tempF}¬∞
            {unit === 'celsius' ? 'C' : 'F'}
          </div>
          <div className="condition">{weather.condition}</div>
          <div className="details">
            <span>Humidity: {weather.humidity}%</span>
            <span>Wind: {weather.windSpeed} km/h</span>
          </div>
        </div>
      )}
      
      {/* No data state */}
      {!weather && !loading && !error && (
        <div className="no-data">
          <p>üå§Ô∏è Enter a city name to get weather information</p>
        </div>
      )}
    </div>
  );
}
```

## 5.2 Rendering Lists with .map()

The `.map()` method is the standard React pattern for transforming arrays of data into arrays of JSX elements. It's the go-to solution for rendering dynamic lists.

### Basic List Rendering

```jsx
function BasicList() {
  const fruits = ['Apple', 'Banana', 'Orange', 'Grape'];
  
  return (
    <div>
      <h3>Fruits List</h3>
      <ul>
        {fruits.map((fruit, index) => (
          <li key={index}>{fruit}</li>
        ))}
      </ul>
    </div>
  );
}

function NumbersList() {
  const numbers = [1, 2, 3, 4, 5];
  
  return (
    <div>
      <h3>Numbers</h3>
      <div className="numbers-grid">
        {numbers.map(number => (
          <div key={number} className="number-card">
            <span>{number}</span>
            <span>Square: {number * number}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Rendering Objects

```jsx
function UserList() {
  const users = [
    { id: 1, name: 'John Doe', email: 'john@example.com', role: 'admin' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'user' },
    { id: 3, name: 'Bob Johnson', email: 'bob@example.com', role: 'user' }
  ];
  
  return (
    <div className="user-list">
      <h3>Users</h3>
      {users.map(user => (
        <div key={user.id} className="user-card">
          <h4>{user.name}</h4>
          <p>{user.email}</p>
          <span className={`role ${user.role}`}>
            {user.role}
          </span>
        </div>
      ))}
    </div>
  );
}

function ProductGrid() {
  const products = [
    {
      id: 'p1',
      name: 'Laptop',
      price: 999,
      image: '/laptop.jpg',
      rating: 4.5,
      inStock: true
    },
    {
      id: 'p2',
      name: 'Smartphone',
      price: 599,
      image: '/phone.jpg',
      rating: 4.2,
      inStock: false
    },
    {
      id: 'p3',
      name: 'Headphones',
      price: 199,
      image: '/headphones.jpg',
      rating: 4.8,
      inStock: true
    }
  ];
  
  return (
    <div className="product-grid">
      {products.map(product => (
        <div key={product.id} className="product-card">
          <img src={product.image} alt={product.name} />
          <h3>{product.name}</h3>
          <div className="price">${product.price}</div>
          <div className="rating">
            {'‚òÖ'.repeat(Math.floor(product.rating))} {product.rating}
          </div>
          
          {product.inStock ? (
            <button className="add-to-cart">Add to Cart</button>
          ) : (
            <button className="out-of-stock" disabled>
              Out of Stock
            </button>
          )}
        </div>
      ))}
    </div>
  );
}
```

### Interactive Lists with State

```jsx
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', completed: false, priority: 'high' },
    { id: 2, text: 'Build a project', completed: false, priority: 'medium' },
    { id: 3, text: 'Deploy to production', completed: false, priority: 'low' }
  ]);
  
  const [filter, setFilter] = useState('all'); // 'all', 'completed', 'pending'
  const [sortBy, setSortBy] = useState('priority'); // 'priority', 'alphabetical'
  
  const toggleTodo = (id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  const deleteTodo = (id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };
  
  // Filter todos based on current filter
  const filteredTodos = todos.filter(todo => {
    if (filter === 'completed') return todo.completed;
    if (filter === 'pending') return !todo.completed;
    return true; // 'all'
  });
  
  // Sort todos
  const sortedTodos = [...filteredTodos].sort((a, b) => {
    if (sortBy === 'alphabetical') {
      return a.text.localeCompare(b.text);
    }
    if (sortBy === 'priority') {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    }
    return 0;
  });
  
  return (
    <div className="todo-app">
      <h3>Todo List</h3>
      
      {/* Filters and sorting */}
      <div className="controls">
        <div className="filters">
          <button 
            className={filter === 'all' ? 'active' : ''}
            onClick={() => setFilter('all')}
          >
            All ({todos.length})
          </button>
          <button 
            className={filter === 'pending' ? 'active' : ''}
            onClick={() => setFilter('pending')}
          >
            Pending ({todos.filter(t => !t.completed).length})
          </button>
          <button 
            className={filter === 'completed' ? 'active' : ''}
            onClick={() => setFilter('completed')}
          >
            Completed ({todos.filter(t => t.completed).length})
          </button>
        </div>
        
        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
          <option value="priority">Sort by Priority</option>
          <option value="alphabetical">Sort Alphabetically</option>
        </select>
      </div>
      
      {/* Todo list */}
      <div className="todo-list">
        {sortedTodos.length === 0 ? (
          <div className="empty-state">
            <p>No todos found for "{filter}" filter</p>
          </div>
        ) : (
          sortedTodos.map(todo => (
            <div 
              key={todo.id} 
              className={`todo-item ${todo.completed ? 'completed' : ''} priority-${todo.priority}`}
            >
              <input
                type="checkbox"
                checked={todo.completed}
                onChange={() => toggleTodo(todo.id)}
              />
              
              <span className="todo-text">{todo.text}</span>
              
              <span className={`priority-badge ${todo.priority}`}>
                {todo.priority}
              </span>
              
              <button 
                className="delete-btn"
                onClick={() => deleteTodo(todo.id)}
              >
                √ó
              </button>
            </div>
          ))
        )}
      </div>
    </div>
  );
}
```

### Nested Lists

```jsx
function NestedList() {
  const categories = [
    {
      id: 'electronics',
      name: 'Electronics',
      items: [
        { id: 'laptop', name: 'Laptop', price: 999 },
        { id: 'phone', name: 'Smartphone', price: 599 }
      ]
    },
    {
      id: 'clothing',
      name: 'Clothing',
      items: [
        { id: 'shirt', name: 'T-Shirt', price: 29 },
        { id: 'jeans', name: 'Jeans', price: 79 }
      ]
    }
  ];
  
  return (
    <div className="nested-list">
      {categories.map(category => (
        <div key={category.id} className="category">
          <h3>{category.name}</h3>
          <div className="items">
            {category.items.map(item => (
              <div key={item.id} className="item">
                <span>{item.name}</span>
                <span>${item.price}</span>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}
```

### Dynamic List Updates

```jsx
function DynamicUserList() {
  const [users, setUsers] = useState([
    { id: 1, name: 'Alice', status: 'online', lastSeen: new Date() },
    { id: 2, name: 'Bob', status: 'offline', lastSeen: new Date(Date.now() - 3600000) }
  ]);
  
  const [newUserName, setNewUserName] = useState('');
  
  const addUser = () => {
    if (newUserName.trim()) {
      const newUser = {
        id: Date.now(), // Simple ID generation
        name: newUserName.trim(),
        status: 'online',
        lastSeen: new Date()
      };
      
      setUsers(prev => [...prev, newUser]);
      setNewUserName('');
    }
  };
  
  const removeUser = (id) => {
    setUsers(prev => prev.filter(user => user.id !== id));
  };
  
  const toggleUserStatus = (id) => {
    setUsers(prev => prev.map(user =>
      user.id === id
        ? { 
            ...user, 
            status: user.status === 'online' ? 'offline' : 'online',
            lastSeen: new Date()
          }
        : user
    ));
  };
  
  return (
    <div className="dynamic-user-list">
      <h3>User Management</h3>
      
      {/* Add user form */}
      <div className="add-user">
        <input
          type="text"
          value={newUserName}
          onChange={(e) => setNewUserName(e.target.value)}
          placeholder="Enter user name"
          onKeyPress={(e) => e.key === 'Enter' && addUser()}
        />
        <button onClick={addUser}>Add User</button>
      </div>
      
      {/* Users list */}
      <div className="users">
        {users.length === 0 ? (
          <p>No users found. Add some users above.</p>
        ) : (
          users.map(user => (
            <div key={user.id} className={`user-item ${user.status}`}>
              <div className="user-info">
                <span className="name">{user.name}</span>
                <span className={`status ${user.status}`}>
                  {user.status === 'online' ? 'üü¢' : 'üî¥'} {user.status}
                </span>
                <span className="last-seen">
                  Last seen: {user.lastSeen.toLocaleTimeString()}
                </span>
              </div>
              
              <div className="actions">
                <button onClick={() => toggleUserStatus(user.id)}>
                  {user.status === 'online' ? 'Set Offline' : 'Set Online'}
                </button>
                <button onClick={() => removeUser(user.id)}>
                  Remove
                </button>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
}
```

## 5.3 The key Prop

The `key` prop is one of the most critical concepts in React list rendering. It helps React identify which items have changed, been added, or been removed, enabling efficient updates and preventing bugs.

### Why Keys Matter

Without proper keys, React uses the array index by default, which can cause:
- **Performance issues**: Unnecessary re-renders
- **State bugs**: Component state getting mixed up
- **Animation glitches**: Incorrect transitions
- **Focus problems**: Input focus jumping to wrong elements

### What Makes a Good Key

#### ‚úÖ Good Keys
```jsx
// Unique, stable identifiers
const users = [
  { id: 'user_123', name: 'Alice' },
  { id: 'user_456', name: 'Bob' }
];

users.map(user => (
  <UserCard key={user.id} user={user} />
));

// Database IDs
const posts = [
  { postId: 1, title: 'First Post' },
  { postId: 2, title: 'Second Post' }
];

posts.map(post => (
  <BlogPost key={post.postId} post={post} />
));

// UUIDs
const items = [
  { uuid: 'a1b2c3d4-e5f6-7890', name: 'Item 1' },
  { uuid: 'x1y2z3w4-a5b6-7890', name: 'Item 2' }
];

items.map(item => (
  <Item key={item.uuid} item={item} />
));
```

#### ‚ùå Bad Keys
```jsx
// Array index (can cause bugs when order changes)
items.map((item, index) => (
  <Item key={index} item={item} /> // ‚ùå Don't use index
));

// Non-unique values
items.map(item => (
  <Item key={item.category} item={item} /> // ‚ùå Multiple items might have same category
));

// Changing values
items.map(item => (
  <Item key={Math.random()} item={item} /> // ‚ùå Key changes every render
));
```

### Demonstrating Key Problems

```jsx
function KeyProblemDemo() {
  const [items, setItems] = useState([
    { id: 1, name: 'Apple', color: 'red' },
    { id: 2, name: 'Banana', color: 'yellow' },
    { id: 3, name: 'Orange', color: 'orange' }
  ]);
  
  const addItemToTop = () => {
    const newItem = {
      id: Date.now(),
      name: 'New Fruit',
      color: 'green'
    };
    setItems(prev => [newItem, ...prev]);
  };
  
  const removeFirstItem = () => {
    setItems(prev => prev.slice(1));
  };
  
  // Component that maintains its own state
  const ItemWithInput = ({ item, keyType }) => {
    const [inputValue, setInputValue] = useState('');
    
    return (
      <div className="item-with-input">
        <span>{item.name} ({item.color})</span>
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Type something..."
        />
      </div>
    );
  };
  
  return (
    <div className="key-demo">
      <h3>Key Demonstration</h3>
      
      <div className="controls">
        <button onClick={addItemToTop}>Add Item to Top</button>
        <button onClick={removeFirstItem}>Remove First Item</button>
      </div>
      
      <div className="comparison">
        <div className="list-section">
          <h4>‚ùå Bad: Using Array Index as Key</h4>
          {items.map((item, index) => (
            <ItemWithInput 
              key={index} // Bad: using index
              item={item} 
            />
          ))}
        </div>
        
        <div className="list-section">
          <h4>‚úÖ Good: Using Stable ID as Key</h4>
          {items.map(item => (
            <ItemWithInput 
              key={item.id} // Good: using stable ID
              item={item} 
            />
          ))}
        </div>
      </div>
      
      <div className="explanation">
        <p>
          <strong>Try this:</strong> Type different text in each input, then add or remove items.
          Notice how the text moves incorrectly in the "bad" example but stays correct in the "good" example.
        </p>
      </div>
    </div>
  );
}
```

### Keys in Different Scenarios

#### 1. Reordering Lists

```jsx
function ReorderableList() {
  const [tasks, setTasks] = useState([
    { id: 'task_1', name: 'Design mockups', priority: 1 },
    { id: 'task_2', name: 'Implement frontend', priority: 2 },
    { id: 'task_3', name: 'Write tests', priority: 3 },
    { id: 'task_4', name: 'Deploy to staging', priority: 4 }
  ]);
  
  const moveUp = (id) => {
    setTasks(prev => {
      const index = prev.findIndex(task => task.id === id);
      if (index <= 0) return prev;
      
      const newTasks = [...prev];
      [newTasks[index - 1], newTasks[index]] = [newTasks[index], newTasks[index - 1]];
      return newTasks;
    });
  };
  
  const moveDown = (id) => {
    setTasks(prev => {
      const index = prev.findIndex(task => task.id === id);
      if (index >= prev.length - 1) return prev;
      
      const newTasks = [...prev];
      [newTasks[index], newTasks[index + 1]] = [newTasks[index + 1], newTasks[index]];
      return newTasks;
    });
  };
  
  return (
    <div className="reorderable-list">
      <h3>Task Priority List</h3>
      <p>Use the arrows to reorder tasks. Notice how the keys prevent state bugs.</p>
      
      {tasks.map((task, index) => (
        <div key={task.id} className="task-item">
          <span className="priority">#{task.priority}</span>
          <span className="name">{task.name}</span>
          
          <div className="controls">
            <button 
              onClick={() => moveUp(task.id)}
              disabled={index === 0}
            >
              ‚Üë
            </button>
            <button 
              onClick={() => moveDown(task.id)}
              disabled={index === tasks.length - 1}
            >
              ‚Üì
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}
```

#### 2. Filtering Lists

```jsx
function FilterableList() {
  const [filter, setFilter] = useState('');
  
  const allItems = [
    { id: 'item_1', name: 'Apple iPhone', category: 'electronics', price: 999 },
    { id: 'item_2', name: 'Samsung Galaxy', category: 'electronics', price: 899 },
    { id: 'item_3', name: 'Nike Shoes', category: 'clothing', price: 120 },
    { id: 'item_4', name: 'Adidas Jacket', category: 'clothing', price: 80 },
    { id: 'item_5', name: 'MacBook Pro', category: 'electronics', price: 1999 }
  ];
  
  const filteredItems = allItems.filter(item =>
    item.name.toLowerCase().includes(filter.toLowerCase()) ||
    item.category.toLowerCase().includes(filter.toLowerCase())
  );
  
  return (
    <div className="filterable-list">
      <h3>Product Search</h3>
      
      <input
        type="text"
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        placeholder="Search products..."
      />
      
      <div className="results">
        {filteredItems.length === 0 ? (
          <p>No products found matching "{filter}"</p>
        ) : (
          filteredItems.map(item => (
            <div key={item.id} className="product-item">
              <h4>{item.name}</h4>
              <span className="category">{item.category}</span>
              <span className="price">${item.price}</span>
            </div>
          ))
        )}
      </div>
      
      <div className="meta">
        Showing {filteredItems.length} of {allItems.length} products
      </div>
    </div>
  );
}
```

#### 3. Dynamic Lists with User Input

```jsx
function DynamicList() {
  const [items, setItems] = useState([]);
  const [newItem, setNewItem] = useState('');
  const [editingId, setEditingId] = useState(null);
  
  const addItem = () => {
    if (newItem.trim()) {
      const item = {
        id: crypto.randomUUID(), // Modern way to generate unique IDs
        text: newItem.trim(),
        createdAt: new Date(),
        isCompleted: false
      };
      
      setItems(prev => [...prev, item]);
      setNewItem('');
    }
  };
  
  const deleteItem = (id) => {
    setItems(prev => prev.filter(item => item.id !== id));
  };
  
  const toggleComplete = (id) => {
    setItems(prev => prev.map(item =>
      item.id === id 
        ? { ...item, isCompleted: !item.isCompleted }
        : item
    ));
  };
  
  const startEdit = (id) => {
    setEditingId(id);
  };
  
  const saveEdit = (id, newText) => {
    setItems(prev => prev.map(item =>
      item.id === id 
        ? { ...item, text: newText }
        : item
    ));
    setEditingId(null);
  };
  
  const cancelEdit = () => {
    setEditingId(null);
  };
  
  return (
    <div className="dynamic-list">
      <h3>Dynamic Todo List</h3>
      
      <div className="add-item">
        <input
          type="text"
          value={newItem}
          onChange={(e) => setNewItem(e.target.value)}
          placeholder="Add new item..."
          onKeyPress={(e) => e.key === 'Enter' && addItem()}
        />
        <button onClick={addItem}>Add</button>
      </div>
      
      <div className="items">
        {items.map(item => (
          <TodoItem
            key={item.id} // Crucial: stable unique key
            item={item}
            isEditing={editingId === item.id}
            onToggle={() => toggleComplete(item.id)}
            onDelete={() => deleteItem(item.id)}
            onStartEdit={() => startEdit(item.id)}
            onSaveEdit={(text) => saveEdit(item.id, text)}
            onCancelEdit={cancelEdit}
          />
        ))}
      </div>
      
      {items.length === 0 && (
        <div className="empty-state">
          <p>No items yet. Add one above!</p>
        </div>
      )}
    </div>
  );
}

function TodoItem({ 
  item, 
  isEditing, 
  onToggle, 
  onDelete, 
  onStartEdit, 
  onSaveEdit, 
  onCancelEdit 
}) {
  const [editText, setEditText] = useState(item.text);
  
  const handleSave = () => {
    if (editText.trim()) {
      onSaveEdit(editText.trim());
    } else {
      onCancelEdit();
    }
  };
  
  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      handleSave();
    } else if (e.key === 'Escape') {
      setEditText(item.text);
      onCancelEdit();
    }
  };
  
  if (isEditing) {
    return (
      <div className="todo-item editing">
        <input
          type="text"
          value={editText}
          onChange={(e) => setEditText(e.target.value)}
          onKeyPress={handleKeyPress}
          onBlur={handleSave}
          autoFocus
        />
        <button onClick={handleSave}>Save</button>
        <button onClick={onCancelEdit}>Cancel</button>
      </div>
    );
  }
  
  return (
    <div className={`todo-item ${item.isCompleted ? 'completed' : ''}`}>
      <input
        type="checkbox"
        checked={item.isCompleted}
        onChange={onToggle}
      />
      
      <span className="text" onClick={onToggle}>
        {item.text}
      </span>
      
      <span className="created-at">
        {item.createdAt.toLocaleTimeString()}
      </span>
      
      <div className="actions">
        <button onClick={onStartEdit}>Edit</button>
        <button onClick={onDelete}>Delete</button>
      </div>
    </div>
  );
}
```

### Performance Implications of Keys

```jsx
function PerformanceDemo() {
  const [items, setItems] = useState(
    Array.from({ length: 1000 }, (_, i) => ({
      id: `item_${i}`,
      value: Math.random(),
      timestamp: Date.now() + i
    }))
  );
  
  const [renderCount, setRenderCount] = useState(0);
  
  const shuffleItems = () => {
    setItems(prev => [...prev].sort(() => Math.random() - 0.5));
    setRenderCount(prev => prev + 1);
  };
  
  const addItemToMiddle = () => {
    const newItem = {
      id: `item_${Date.now()}`,
      value: Math.random(),
      timestamp: Date.now()
    };
    
    setItems(prev => {
      const middle = Math.floor(prev.length / 2);
      return [
        ...prev.slice(0, middle),
        newItem,
        ...prev.slice(middle)
      ];
    });
    setRenderCount(prev => prev + 1);
  };
  
  return (
    <div className="performance-demo">
      <h3>Performance Demo (1000 items)</h3>
      <p>Render count: {renderCount}</p>
      
      <div className="controls">
        <button onClick={shuffleItems}>Shuffle Items</button>
        <button onClick={addItemToMiddle}>Add Item to Middle</button>
      </div>
      
      <div className="items-container" style={{ maxHeight: '300px', overflow: 'auto' }}>
        {items.map(item => (
          <PerformanceItem key={item.id} item={item} />
        ))}
      </div>
    </div>
  );
}

function PerformanceItem({ item }) {
  const [renderCount, setRenderCount] = useState(0);
  
  // Track renders (development only)
  useEffect(() => {
    setRenderCount(prev => prev + 1);
  });
  
  return (
    <div className="performance-item">
      <span>ID: {item.id}</span>
      <span>Value: {item.value.toFixed(4)}</span>
      <span>Renders: {renderCount}</span>
    </div>
  );
}
```

### Key Best Practices Summary

#### ‚úÖ Do:
- Use unique, stable identifiers (database IDs, UUIDs)
- Keep keys consistent across re-renders
- Use the same key for the same logical item
- Consider performance with large lists

#### ‚ùå Don't:
- Use array indices unless the list never changes
- Use random values or dates as keys
- Use non-unique values as keys
- Change key values unnecessarily

```jsx
// ‚úÖ Perfect key usage
function BestPracticeExample() {
  const [users, setUsers] = useState([
    { userId: 'u123', name: 'Alice', email: 'alice@example.com' },
    { userId: 'u456', name: 'Bob', email: 'bob@example.com' }
  ]);
  
  return (
    <div>
      {users.map(user => (
        <UserProfile 
          key={user.userId} // ‚úÖ Stable, unique identifier
          user={user}
        />
      ))}
    </div>
  );
}
```

## Summary

Conditional rendering and list rendering are fundamental React patterns:

### Key Takeaways:

1. **Conditional Rendering**:
   - Use ternary (`? :`) for if-else scenarios
   - Use logical AND (`&&`) for if-then scenarios
   - Consider early returns for complex conditions

2. **List Rendering**:
   - Use `.map()` to transform arrays into JSX
   - Always provide a `key` prop for list items
   - Handle empty states gracefully

3. **The Key Prop**:
   - Critical for performance and correctness
   - Must be unique and stable
   - Never use array indices for dynamic lists
   - Use database IDs or UUIDs when possible

### Best Practices:
- ‚úÖ Plan your key strategy early
- ‚úÖ Use stable, unique identifiers
- ‚úÖ Handle loading and empty states
- ‚úÖ Consider performance with large lists
- ‚úÖ Test list operations (add, remove, reorder)

### Performance Tips:
- Use `React.memo()` for expensive list items
- Consider virtualization for very large lists
- Optimize key generation for dynamic content
- Profile performance with React DevTools

**Next Steps**: Learn about `useEffect` for side effects, data fetching patterns, and advanced component lifecycle management!