# React Effects Mastery (useEffect & Beyond)

> A precise, practical, battle‑tested guide to managing side effects in modern React.

Side Effects = any interaction with the outside world or anything that cannot be derived purely from current props/state: network I/O, timers, subscriptions, logging, DOM APIs, storage, focus, media, performance observers, mutations, etc.

---
## 1. Core Mental Model
1. Render must stay pure (no mutations, no async calls, no subscriptions)
2. React commits DOM → then runs effects (`useEffect`) asynchronously
3. Cleanup from previous run executes before next effect run (except on initial mount)
4. Dependency array determines when logic is re‑scheduled

> If the UI can be expressed purely from state/props, do it in render. Only move to an effect when there is external coordination or imperative API boundaries.

---
## 2. The Three Effect Shapes
| Shape | Code | Runs | Use For |
|-------|------|------|---------|
| No deps | `useEffect(fn)` | After every paint | Debug logging (rare), scroll sync (prefer refs), bridging non-react libs |
| Empty deps | `useEffect(fn, [])` | Once (mount) + cleanup on unmount | Subscriptions, one-time init, analytics session start |
| With deps | `useEffect(fn, [a,b])` | On mount then when any dependency changes | Fetch-on-param-change, re-bind resources |

Avoid “no deps” unless truly needed; it often signals missing dependency modeling.

---
## 3. Anatomy & Cleanup
```jsx
useEffect(() => {
  acquire(); // subscribe / start / attach
  return () => release(); // unsubscribe / stop / detach
}, [dependencies]);
```
Cleanup executes:
1. Before effect re-runs (if dependencies changed)
2. Before component unmount

> Always return a cleanup for anything that registers, allocates, or schedules.

---
## 4. Canonical Patterns

### 4.1 Data Fetch (Parameterized + Abort)
```jsx
function useUserProfile(userId) {
  const [state, setState] = useState({ loading: false, data: null, error: null });
  useEffect(() => {
    if (!userId) return setState({ loading: false, data: null, error: null });
    const controller = new AbortController();
    (async () => {
      setState(s => ({ ...s, loading: true, error: null }));
      try {
        const res = await fetch(`/api/users/${userId}`, { signal: controller.signal });
        if (!res.ok) throw new Error(res.statusText);
        const json = await res.json();
        if (!controller.signal.aborted) setState({ loading: false, data: json, error: null });
      } catch (e) {
        if (e.name !== 'AbortError' && !controller.signal.aborted) {
          setState({ loading: false, data: null, error: e });
        }
      }
    })();
    return () => controller.abort();
  }, [userId]);
  return state;
}
```

### 4.2 Subscription (WebSocket / EventEmitter)
```jsx
function useNotifications(userId) {
  const [list, setList] = useState([]);
  useEffect(() => {
    if (!userId) return;
    const socket = new WebSocket(`wss://example.com/notify/${userId}`);
    socket.onmessage = e => setList(prev => [JSON.parse(e.data), ...prev]);
    socket.onerror = e => console.warn('ws error', e);
    return () => socket.close();
  }, [userId]);
  return list;
}
```

### 4.3 DOM Event Binding
```jsx
function useWindowSize() {
  const [size, setSize] = useState({ w: window.innerWidth, h: window.innerHeight });
  useEffect(() => {
    const onResize = () => setSize({ w: window.innerWidth, h: window.innerHeight });
    window.addEventListener('resize', onResize);
    return () => window.removeEventListener('resize', onResize);
  }, []);
  return size;
}
```

### 4.4 Polling / Interval
```jsx
function usePolling(fn, delay, deps = []) {
  useEffect(() => {
    if (delay == null) return; // paused
    let cancelled = false;
    const tick = async () => {
      await fn();
      if (!cancelled) timer = setTimeout(tick, delay);
    };
    let timer = setTimeout(tick, delay);
    return () => { cancelled = true; clearTimeout(timer); };
  }, [delay, ...deps]);
}
```

### 4.5 Debounced Input → Fetch
```jsx
function useDebouncedValue(value, ms = 400) {
  const [debounced, setDebounced] = useState(value);
  useEffect(() => {
    const t = setTimeout(() => setDebounced(value), ms);
    return () => clearTimeout(t);
  }, [value, ms]);
  return debounced;
}
```

---
## 5. Dependency Array Deep Dive

### 5.1 Include All External References
Everything referenced inside the effect that comes from the component scope (props, state, functions) must appear in dependencies, **unless** it is stable (memoized / ref) or intentionally excluded.

### 5.2 Stable Identity Strategies
| Need | Strategy |
|------|----------|
| Stable callback for dependency minimization | `useCallback(fn, [deps])` |
| Stable object/array | `useMemo(() => obj, [deps])` |
| Mutable container w/out re-renders | `const ref = useRef(init)` |

### 5.3 The “Missing Dependency” Warning
Use ESLint plugin `eslint-plugin-react-hooks` (ships with CRA / Vite templates) – follow its advice 95% of the time. Deviations should be documented inline.

### 5.4 Escape Hatches (Document Them)
```jsx
// eslint-disable-next-line react-hooks/exhaustive-deps
useEffect(() => { legacyLib.init(config); }, []); // config deliberately stable for session
```

---
## 6. Avoiding Common Pitfalls
| Pitfall | Example | Fix |
|---------|---------|-----|
| Infinite loop | Setting state unconditionally | Add deps + guards / functional update |
| Stale closure | Using outdated state inside async | Capture latest via refs or re-run effect |
| Race conditions | Rapid param changes / slow fetch | AbortController / request token discard |
| Over-fetching | Fetch on every keystroke | Debounce / combine dependencies |
| Memory leaks | Unremoved listeners / timers | Always cleanup |

### 6.1 Race Condition Example & Fix
```jsx
useEffect(() => {
  let active = true;
  (async () => {
    const res = await fetch(`/api/search?q=${q}`);
    const json = await res.json();
    if (active) setResults(json); // ignore if stale
  })();
  return () => { active = false; };
}, [q]);
```

### 6.2 Stale Closure Fix with Ref
```jsx
const latest = useRef();
latest.current = state;
useEffect(() => {
  const handler = () => doSomething(latest.current);
  window.addEventListener('focus', handler);
  return () => window.removeEventListener('focus', handler);
}, []);
```

---
## 7. Splitting Effects for Clarity
Bad: one mega-effect doing unrelated things.
```jsx
// ❌ Anti-pattern
useEffect(() => {
  fetchUser();
  setupResizeListener();
  analytics.page();
}, [userId]);
```
Better: separate concerns so each dependency set is minimal.
```jsx
useEffect(() => { fetchUser(); }, [userId]);
useEffect(() => { setupResizeListener(); }, []);
useEffect(() => { analytics.page('User'); }, [userId]);
```

> Rule: One effect = one cohesive responsibility.

---
## 8. When NOT to Use useEffect
| Goal | Correct Alternative |
|------|---------------------|
| Derive value from props/state | Compute directly in render / `useMemo` |
| Update state based on previous state | Pass function to `setState` |
| Prefill controlled input from props once | Initialize state in `useState(() => initial)` |
| Execute logic on event | Put logic directly into event handler |

Example (Wrong vs Right):
```jsx
// ❌ uses effect just to sync derived state
const [fullName, setFullName] = useState('');
useEffect(() => { setFullName(`${first} ${last}`); }, [first, last]);

// ✅ derive on the fly
const fullName = `${first} ${last}`;
```

---
## 9. Performance Patterns
### 9.1 Debounce + Abort Hybrid
```jsx
function useSmartSearch(term) {
  const q = useDebouncedValue(term, 400);
  const [state, setState] = useState({ loading: false, results: [], error: null });
  useEffect(() => {
    if (!q) return setState({ loading: false, results: [], error: null });
    const ctrl = new AbortController();
    (async () => {
      setState(s => ({ ...s, loading: true }));
      try {
        const res = await fetch(`/api/search?q=${encodeURIComponent(q)}`, { signal: ctrl.signal });
        const json = await res.json();
        if (!ctrl.signal.aborted) setState({ loading: false, results: json, error: null });
      } catch (e) {
        if (e.name !== 'AbortError') setState({ loading: false, results: [], error: e });
      }
    })();
    return () => ctrl.abort();
  }, [q]);
  return state;
}
```

### 9.2 Throttled Scroll Listener
```jsx
function useScrollPosition(throttleMs = 100) {
  const [pos, setPos] = useState(0);
  useEffect(() => {
    let ticking = false;
    const onScroll = () => {
      if (ticking) return; ticking = true;
      requestAnimationFrame(() => {
        setPos(window.scrollY); ticking = false;
      });
    };
    window.addEventListener('scroll', onScroll, { passive: true });
    return () => window.removeEventListener('scroll', onScroll);
  }, [throttleMs]);
  return pos;
}
```

---
## 10. Advanced Orchestration
### 10.1 Sequenced Effects
```jsx
const useSequenced = (steps) => {
  const [idx, setIdx] = useState(0);
  useEffect(() => {
    if (idx >= steps.length) return;
    const next = steps[idx];
    const done = () => setIdx(i => i + 1);
    return next(done); // each step returns (optional) cleanup
  }, [idx, steps]);
};
```

### 10.2 Effect Event Pattern (React 19+ Conceptual)
If you need a stable callback that always sees fresh state, use a ref or upcoming `useEffectEvent` (polyfill concept):
```jsx
function useEvent(fn) {
  const ref = useRef(fn);
  ref.current = fn;
  return useCallback((...args) => ref.current(...args), []);
}
```

---
## 11. Testing Effects
Use Testing Library + MSW (for network) + Jest fake timers.
```jsx
test('fetches profile on id change', async () => {
  render(<Profile userId="123" />);
  expect(await screen.findByText(/Loading/i)).toBeInTheDocument();
  expect(await screen.findByText(/Alice/)).toBeInTheDocument();
});
```

For timers:
```jsx
jest.useFakeTimers();
render(<Timer />);
act(() => { jest.advanceTimersByTime(3000); });
expect(screen.getByText(/3s/)).toBeInTheDocument();
```

---
## 12. Checklist Before Shipping
1. Any effect doing more than ONE concern? Split.
2. Are all dependencies declared? (ESLint clean?)
3. Are abort / cleanup paths implemented?
4. Is an effect replacing something derivable? (Remove it.)
5. Could ref stabilize non-react value instead of effect dance?
6. Could concurrency/race cause stale updates? (Abort / token)
7. Are heavy transforms memoized outside effect?

---
## 13. Quick Reference
| Intent | Pattern |
|--------|---------|
| Fetch on param change | Effect + param dependency | 
| Cancel fetch on change | AbortController in cleanup |
| Subscriptions | Setup in effect, teardown in return |
| Debounce input | Separate debounced state hook |
| Avoid stale closure | useRef + stable callback |
| Skip run until condition | Guard inside effect |
| Once-only init | Empty dependency array |

---
## 14. Key Takeaways
1. Most “effect bugs” are dependency misunderstandings or misuse of effect for derivation.
2. Cleanup is non-negotiable for acquired resources.
3. Collapse race conditions with cancellation.
4. Split effects by responsibility; readability wins.
5. Prefer deriving over syncing state.

> Next: Share state across tree and reduce prop drilling with Context + custom hooks.
# React useEffect: Managing Side Effects

## 6.1 What is a "Side Effect"?

A side effect is any operation that affects something **outside** of the component itself. React components should be "pure" functions that only depend on their props and state, but real applications need to interact with the outside world.

### Understanding Pure vs Side Effects

```jsx
// ✅ Pure function - no side effects
function PureComponent({ name, age }) {
  const greeting = `Hello, ${name}! You are ${age} years old.`;
  return <div>{greeting}</div>;
}

// ❌ Side effects mixed in render (DON'T DO THIS)
function ImpureComponent({ userId }) {
  // These are side effects happening during render!
  fetch(`/api/users/${userId}`);  // API call
  document.title = `User ${userId}`;  // DOM manipulation
  localStorage.setItem('lastUser', userId);  // External storage
  
  return <div>User Profile</div>;
}

// ✅ Side effects properly managed with useEffect
function ProperComponent({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    // Side effects belong here, not in render
    fetch(`/api/users/${userId}`)
      .then(response => response.json())
      .then(setUser);
    
    document.title = `User ${userId}`;
    localStorage.setItem('lastUser', userId);
  }, [userId]);
  
  return <div>{user ? user.name : 'Loading...'}</div>;
}
```

### Common Types of Side Effects

#### 1. Data Fetching

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const userData = await response.json();
        setUser(userData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUser();
  }, [userId]);
  
  if (loading) return <div>Loading user...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <p>Joined: {new Date(user.joinDate).toLocaleDateString()}</p>
    </div>
  );
}
```

#### 2. Timers and Intervals

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  
  useEffect(() => {
    let intervalId;
    
    if (isRunning) {
      intervalId = setInterval(() => {
        setSeconds(prev => prev + 1);
      }, 1000);
    }
    
    // Cleanup function
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isRunning]);
  
  const formatTime = (totalSeconds) => {
    const minutes = Math.floor(totalSeconds / 60);
    const secs = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };
  
  return (
    <div className="timer">
      <h2>{formatTime(seconds)}</h2>
      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? 'Pause' : 'Start'}
      </button>
      <button onClick={() => {
        setSeconds(0);
        setIsRunning(false);
      }}>
        Reset
      </button>
    </div>
  );
}
```

#### 3. DOM Manipulation

```jsx
function DocumentTitle({ title, count }) {
  useEffect(() => {
    // Update document title
    const originalTitle = document.title;
    document.title = count > 0 ? `(${count}) ${title}` : title;
    
    // Restore original title on cleanup
    return () => {
      document.title = originalTitle;
    };
  }, [title, count]);
  
  return <div>Check the browser tab title!</div>;
}

function ScrollToTop() {
  useEffect(() => {
    // Scroll to top when component mounts
    window.scrollTo(0, 0);
  }, []); // Empty dependency array = run once on mount
  
  return <div>Content that might be scrolled to...</div>;
}

function FocusInput() {
  const inputRef = useRef(null);
  
  useEffect(() => {
    // Focus input when component mounts
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  
  return (
    <div>
      <input 
        ref={inputRef}
        type="text" 
        placeholder="This input gets focused automatically"
      />
    </div>
  );
}
```

#### 4. Event Listeners

```jsx
function WindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    // Add event listener
    window.addEventListener('resize', handleResize);
    
    // Cleanup: remove event listener
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // No dependencies, setup once
  
  return (
    <div>
      <p>Window size: {windowSize.width} x {windowSize.height}</p>
      <p>Try resizing your browser window!</p>
    </div>
  );
}

function KeyLogger() {
  const [lastKey, setLastKey] = useState('');
  const [keyHistory, setKeyHistory] = useState([]);
  
  useEffect(() => {
    const handleKeyPress = (event) => {
      setLastKey(event.key);
      setKeyHistory(prev => [...prev.slice(-9), event.key]); // Keep last 10 keys
    };
    
    // Add event listener to document
    document.addEventListener('keydown', handleKeyPress);
    
    // Cleanup
    return () => {
      document.removeEventListener('keydown', handleKeyPress);
    };
  }, []);
  
  return (
    <div>
      <p>Last key pressed: <strong>{lastKey}</strong></p>
      <p>Recent keys: {keyHistory.join(' → ')}</p>
      <p>Press any key to see it logged here!</p>
    </div>
  );
}
```

#### 5. Local Storage and Browser APIs

```jsx
function LocalStorageCounter() {
  const [count, setCount] = useState(() => {
    // Initialize from localStorage
    const saved = localStorage.getItem('counter');
    return saved ? parseInt(saved, 10) : 0;
  });
  
  useEffect(() => {
    // Save to localStorage whenever count changes
    localStorage.setItem('counter', count.toString());
  }, [count]);
  
  return (
    <div>
      <p>Count: {count} (persisted in localStorage)</p>
      <button onClick={() => setCount(prev => prev + 1)}>
        Increment
      </button>
      <button onClick={() => setCount(0)}>
        Reset
      </button>
    </div>
  );
}

function GeolocationTracker() {
  const [location, setLocation] = useState(null);
  const [error, setError] = useState(null);
  const [watching, setWatching] = useState(false);
  
  useEffect(() => {
    let watchId;
    
    if (watching && 'geolocation' in navigator) {
      watchId = navigator.geolocation.watchPosition(
        (position) => {
          setLocation({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy
          });
          setError(null);
        },
        (error) => {
          setError(error.message);
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    }
    
    // Cleanup: stop watching location
    return () => {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
      }
    };
  }, [watching]);
  
  if (!('geolocation' in navigator)) {
    return <div>Geolocation is not supported by this browser.</div>;
  }
  
  return (
    <div>
      <button onClick={() => setWatching(!watching)}>
        {watching ? 'Stop Tracking' : 'Start Tracking'}
      </button>
      
      {error && <p>Error: {error}</p>}
      
      {location && (
        <div>
          <p>Latitude: {location.latitude}</p>
          <p>Longitude: {location.longitude}</p>
          <p>Accuracy: {location.accuracy} meters</p>
        </div>
      )}
    </div>
  );
}
```

## 6.2 The useEffect Hook

The `useEffect` hook is React's way of handling side effects in functional components. It replaces lifecycle methods from class components and provides a more intuitive way to manage effects.

### Basic Syntax

```jsx
import React, { useEffect, useState } from 'react';

function MyComponent() {
  useEffect(() => {
    // Side effect code here
    console.log('Effect runs');
    
    // Optional cleanup function
    return () => {
      console.log('Cleanup runs');
    };
  }, [/* dependency array */]);
  
  return <div>My Component</div>;
}
```

### useEffect Lifecycle

```jsx
function EffectLifecycleDemo() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('React');
  
  // Effect with no dependencies - runs after every render
  useEffect(() => {
    console.log('Effect runs after every render');
  });
  
  // Effect with empty dependencies - runs only on mount
  useEffect(() => {
    console.log('Effect runs only on mount');
    
    return () => {
      console.log('Cleanup runs only on unmount');
    };
  }, []);
  
  // Effect with specific dependencies
  useEffect(() => {
    console.log(`Effect runs when count changes: ${count}`);
    
    return () => {
      console.log(`Cleanup before count changes from: ${count}`);
    };
  }, [count]);
  
  // Effect with multiple dependencies
  useEffect(() => {
    console.log(`Effect runs when count or name changes: ${count}, ${name}`);
  }, [count, name]);
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Name: {name}</p>
      <button onClick={() => setCount(prev => prev + 1)}>
        Increment Count
      </button>
      <input 
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Change name"
      />
    </div>
  );
}
```

### Common useEffect Patterns

#### 1. Data Fetching Pattern

```jsx
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [page, setPage] = useState(1);
  
  useEffect(() => {
    const fetchUsers = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/users?page=${page}&limit=10`);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch users: ${response.status}`);
        }
        
        const data = await response.json();
        setUsers(data.users);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUsers();
  }, [page]); // Re-run when page changes
  
  const nextPage = () => setPage(prev => prev + 1);
  const prevPage = () => setPage(prev => Math.max(1, prev - 1));
  
  if (loading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <div className="users">
        {users.map(user => (
          <div key={user.id} className="user-card">
            <h3>{user.name}</h3>
            <p>{user.email}</p>
          </div>
        ))}
      </div>
      
      <div className="pagination">
        <button onClick={prevPage} disabled={page === 1}>
          Previous
        </button>
        <span>Page {page}</span>
        <button onClick={nextPage}>
          Next
        </button>
      </div>
    </div>
  );
}
```

#### 2. Real-time Data Updates

```jsx
function LiveDataFeed() {
  const [data, setData] = useState([]);
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    // Simulate WebSocket connection
    const ws = new WebSocket('wss://api.example.com/live-data');
    
    ws.onopen = () => {
      setIsConnected(true);
      console.log('Connected to live data feed');
    };
    
    ws.onmessage = (event) => {
      const newData = JSON.parse(event.data);
      setData(prev => [newData, ...prev.slice(0, 9)]); // Keep last 10 items
    };
    
    ws.onclose = () => {
      setIsConnected(false);
      console.log('Disconnected from live data feed');
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      setIsConnected(false);
    };
    
    // Cleanup: close connection when component unmounts
    return () => {
      ws.close();
    };
  }, []); // No dependencies - setup once
  
  return (
    <div>
      <div className="status">
        Status: {isConnected ? '🟢 Connected' : '🔴 Disconnected'}
      </div>
      
      <div className="live-data">
        <h3>Live Data Feed</h3>
        {data.map((item, index) => (
          <div key={item.id || index} className="data-item">
            <span>{item.timestamp}</span>
            <span>{item.value}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### 3. Animation and Visual Effects

```jsx
function FadeInComponent({ children, delay = 0 }) {
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(true);
    }, delay);
    
    return () => clearTimeout(timer);
  }, [delay]);
  
  return (
    <div 
      style={{
        opacity: isVisible ? 1 : 0,
        transition: 'opacity 0.5s ease-in-out',
        transform: isVisible ? 'translateY(0)' : 'translateY(20px)'
      }}
    >
      {children}
    </div>
  );
}

function ProgressBar({ target, duration = 2000 }) {
  const [progress, setProgress] = useState(0);
  
  useEffect(() => {
    if (target === 0) {
      setProgress(0);
      return;
    }
    
    const increment = target / (duration / 50); // Update every 50ms
    let current = 0;
    
    const timer = setInterval(() => {
      current += increment;
      if (current >= target) {
        setProgress(target);
        clearInterval(timer);
      } else {
        setProgress(current);
      }
    }, 50);
    
    return () => clearInterval(timer);
  }, [target, duration]);
  
  return (
    <div className="progress-container">
      <div 
        className="progress-bar"
        style={{
          width: `${progress}%`,
          transition: 'width 0.1s ease-out'
        }}
      />
      <span>{Math.round(progress)}%</span>
    </div>
  );
}
```

## 6.3 The Dependency Array

The dependency array is the second argument to `useEffect` and controls when the effect runs. Understanding it properly is crucial for preventing bugs and optimizing performance.

### Dependency Array Patterns

#### 1. No Dependency Array - Runs Every Render

```jsx
function RunsEveryRender() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('This runs after every render');
    // ⚠️ This can cause performance issues!
  }); // No dependency array
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

#### 2. Empty Dependency Array - Runs Once on Mount

```jsx
function RunsOnceOnMount() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    console.log('This runs only once when component mounts');
    
    // Perfect for:
    // - Initial data fetching
    // - Setting up event listeners
    // - Initializing third-party libraries
    
    fetchInitialData().then(setData);
  }, []); // Empty array = run once
  
  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;
}
```

#### 3. Specific Dependencies - Runs When Dependencies Change

```jsx
function RunsWhenDependenciesChange() {
  const [userId, setUserId] = useState(1);
  const [userData, setUserData] = useState(null);
  const [theme, setTheme] = useState('light');
  
  // Effect depends on userId only
  useEffect(() => {
    console.log(`Fetching data for user ${userId}`);
    fetchUserData(userId).then(setUserData);
  }, [userId]); // Runs when userId changes
  
  // Effect depends on theme only
  useEffect(() => {
    console.log(`Applying theme: ${theme}`);
    document.body.className = `theme-${theme}`;
  }, [theme]); // Runs when theme changes
  
  // Effect depends on both userId and theme
  useEffect(() => {
    console.log(`User ${userId} using ${theme} theme`);
    analytics.track('user_theme_combo', { userId, theme });
  }, [userId, theme]); // Runs when either changes
  
  return (
    <div>
      <button onClick={() => setUserId(prev => prev + 1)}>
        Next User
      </button>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Toggle Theme
      </button>
      <p>Current user: {userId}</p>
      <p>Current theme: {theme}</p>
    </div>
  );
}
```

### Dependency Array Best Practices

#### 1. Include All Dependencies

```jsx
// ❌ Missing dependencies - can cause stale closure bugs
function MissingDependencies() {
  const [count, setCount] = useState(0);
  const [multiplier, setMultiplier] = useState(2);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count * multiplier); // Uses stale values!
    }, 1000);
    
    return () => clearInterval(timer);
  }, []); // Missing count and multiplier dependencies
  
  return <div>Count: {count}</div>;
}

// ✅ All dependencies included
function AllDependenciesIncluded() {
  const [count, setCount] = useState(0);
  const [multiplier, setMultiplier] = useState(2);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(prevCount => prevCount * multiplier); // Use functional update
    }, 1000);
    
    return () => clearInterval(timer);
  }, [multiplier]); // Include multiplier, use functional update for count
  
  return <div>Count: {count}</div>;
}
```

#### 2. Functional Updates to Avoid Dependencies

```jsx
function FunctionalUpdates() {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(1);
  
  // ❌ Adding count to dependencies causes effect to re-run frequently
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count + step);
    }, 1000);
    
    return () => clearInterval(timer);
  }, [count, step]); // Effect restarts every second!
  
  // ✅ Use functional update to avoid count dependency
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(prevCount => prevCount + step);
    }, 1000);
    
    return () => clearInterval(timer);
  }, [step]); // Only re-run when step changes
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setStep(step + 1)}>
        Increase Step (current: {step})
      </button>
    </div>
  );
}
```

#### 3. Extracting Functions to Avoid Dependencies

```jsx
// ❌ Function in dependency array can cause issues
function FunctionInDependencies({ userId }) {
  const [user, setUser] = useState(null);
  
  const fetchUser = async (id) => {
    const response = await fetch(`/api/users/${id}`);
    const userData = await response.json();
    setUser(userData);
  };
  
  useEffect(() => {
    fetchUser(userId);
  }, [userId, fetchUser]); // fetchUser reference changes every render!
  
  return <div>{user?.name}</div>;
}

// ✅ Use useCallback to stabilize function reference
function StableFunctionReference({ userId }) {
  const [user, setUser] = useState(null);
  
  const fetchUser = useCallback(async (id) => {
    const response = await fetch(`/api/users/${id}`);
    const userData = await response.json();
    setUser(userData);
  }, []); // No dependencies, function is stable
  
  useEffect(() => {
    fetchUser(userId);
  }, [userId, fetchUser]); // fetchUser is now stable
  
  return <div>{user?.name}</div>;
}

// ✅ Or define function inside effect
function FunctionInsideEffect({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    const fetchUser = async (id) => {
      const response = await fetch(`/api/users/${id}`);
      const userData = await response.json();
      setUser(userData);
    };
    
    fetchUser(userId);
  }, [userId]); // Only userId dependency needed
  
  return <div>{user?.name}</div>;
}
```

### Advanced Dependency Patterns

#### 1. Object and Array Dependencies

```jsx
function ObjectDependencies() {
  const [config, setConfig] = useState({ theme: 'light', lang: 'en' });
  const [data, setData] = useState(null);
  
  // ❌ Object reference changes every render even if values are the same
  useEffect(() => {
    fetchDataWithConfig(config).then(setData);
  }, [config]); // Effect runs on every render!
  
  // ✅ Use individual properties as dependencies
  useEffect(() => {
    const configObj = { theme: config.theme, lang: config.lang };
    fetchDataWithConfig(configObj).then(setData);
  }, [config.theme, config.lang]); // Only run when actual values change
  
  return <div>{data ? 'Data loaded' : 'Loading...'}</div>;
}

function ArrayDependencies() {
  const [filters, setFilters] = useState(['active', 'verified']);
  const [results, setResults] = useState([]);
  
  // ❌ Array reference changes even if contents are the same
  useEffect(() => {
    searchWithFilters(filters).then(setResults);
  }, [filters]);
  
  // ✅ Use useMemo to stabilize array reference
  const stableFilters = useMemo(() => filters, [filters.join(',')]);
  
  useEffect(() => {
    searchWithFilters(stableFilters).then(setResults);
  }, [stableFilters]);
  
  return <div>Results: {results.length}</div>;
}
```

#### 2. Custom Dependency Comparison

```jsx
function DeepComparisonEffect({ user }) {
  const [profile, setProfile] = useState(null);
  
  // Custom hook for deep comparison
  const usePrevious = (value) => {
    const ref = useRef();
    useEffect(() => {
      ref.current = value;
    });
    return ref.current;
  };
  
  const useDeepEffect = (callback, dependencies) => {
    const prevDeps = usePrevious(dependencies);
    const hasChanged = !prevDeps || !deepEqual(prevDeps, dependencies);
    
    useEffect(() => {
      if (hasChanged) {
        callback();
      }
    });
  };
  
  useDeepEffect(() => {
    fetchUserProfile(user.id).then(setProfile);
  }, [user]);
  
  return <div>{profile?.name}</div>;
}
```

## 6.4 The Cleanup Function

The cleanup function is crucial for preventing memory leaks and ensuring your application performs well. It runs before the component unmounts or before the effect runs again.

### When Cleanup Runs

```jsx
function CleanupTiming() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log(`Effect runs for count: ${count}`);
    
    return () => {
      console.log(`Cleanup runs for count: ${count}`);
    };
  }, [count]);
  
  // Cleanup sequence when count changes from 0 to 1:
  // 1. "Effect runs for count: 0" (initial)
  // 2. User clicks button
  // 3. "Cleanup runs for count: 0" (before new effect)
  // 4. "Effect runs for count: 1" (new effect)
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Common Cleanup Scenarios

#### 1. Cleaning Up Timers

```jsx
function CountdownTimer({ initialSeconds }) {
  const [seconds, setSeconds] = useState(initialSeconds);
  const [isActive, setIsActive] = useState(false);
  
  useEffect(() => {
    let intervalId;
    
    if (isActive && seconds > 0) {
      intervalId = setInterval(() => {
        setSeconds(prev => {
          if (prev <= 1) {
            setIsActive(false);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }
    
    // Cleanup: Clear interval
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isActive, seconds]);
  
  const reset = () => {
    setSeconds(initialSeconds);
    setIsActive(false);
  };
  
  return (
    <div className="countdown-timer">
      <div className="display">
        {Math.floor(seconds / 60)}:{(seconds % 60).toString().padStart(2, '0')}
      </div>
      
      <div className="controls">
        <button onClick={() => setIsActive(!isActive)}>
          {isActive ? 'Pause' : 'Start'}
        </button>
        <button onClick={reset}>Reset</button>
      </div>
      
      {seconds === 0 && <div className="finished">Time's up!</div>}
    </div>
  );
}
```

#### 2. Cleaning Up Event Listeners

```jsx
function MouseTracker() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isTracking, setIsTracking] = useState(false);
  
  useEffect(() => {
    if (!isTracking) return;
    
    const handleMouseMove = (event) => {
      setPosition({
        x: event.clientX,
        y: event.clientY
      });
    };
    
    const handleKeyPress = (event) => {
      if (event.key === 'Escape') {
        setIsTracking(false);
      }
    };
    
    // Add event listeners
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('keydown', handleKeyPress);
    
    // Cleanup: Remove event listeners
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('keydown', handleKeyPress);
    };
  }, [isTracking]);
  
  return (
    <div className="mouse-tracker">
      <button onClick={() => setIsTracking(!isTracking)}>
        {isTracking ? 'Stop Tracking' : 'Start Tracking'}
      </button>
      
      {isTracking && (
        <div>
          <p>Mouse position: ({position.x}, {position.y})</p>
          <p>Press Escape to stop tracking</p>
        </div>
      )}
    </div>
  );
}
```

#### 3. Cleaning Up Network Requests

```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    if (!query.trim()) {
      setResults([]);
      return;
    }
    
    // Create AbortController for this request
    const abortController = new AbortController();
    const signal = abortController.signal;
    
    const searchData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`, {
          signal // Pass signal to fetch
        });
        
        if (!response.ok) {
          throw new Error(`Search failed: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Check if request was aborted
        if (!signal.aborted) {
          setResults(data.results);
        }
      } catch (err) {
        if (err.name !== 'AbortError' && !signal.aborted) {
          setError(err.message);
        }
      } finally {
        if (!signal.aborted) {
          setLoading(false);
        }
      }
    };
    
    searchData();
    
    // Cleanup: Abort ongoing request
    return () => {
      abortController.abort();
    };
  }, [query]);
  
  return (
    <div className="search-results">
      {loading && <div>Searching...</div>}
      {error && <div>Error: {error}</div>}
      
      <div className="results">
        {results.map(result => (
          <div key={result.id} className="result-item">
            <h3>{result.title}</h3>
            <p>{result.description}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### 4. Cleaning Up Subscriptions

```jsx
function LiveChat({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  
  useEffect(() => {
    if (!roomId) return;
    
    // Create connection
    const chatClient = new ChatClient(roomId);
    
    const handleConnect = () => {
      setConnectionStatus('connected');
    };
    
    const handleDisconnect = () => {
      setConnectionStatus('disconnected');
    };
    
    const handleMessage = (message) => {
      setMessages(prev => [...prev, message]);
    };
    
    const handleError = (error) => {
      console.error('Chat error:', error);
      setConnectionStatus('error');
    };
    
    // Subscribe to events
    chatClient.on('connect', handleConnect);
    chatClient.on('disconnect', handleDisconnect);
    chatClient.on('message', handleMessage);
    chatClient.on('error', handleError);
    
    // Connect
    chatClient.connect();
    
    // Cleanup: Unsubscribe and disconnect
    return () => {
      chatClient.off('connect', handleConnect);
      chatClient.off('disconnect', handleDisconnect);
      chatClient.off('message', handleMessage);
      chatClient.off('error', handleError);
      chatClient.disconnect();
    };
  }, [roomId]);
  
  return (
    <div className="live-chat">
      <div className="status">
        Status: <span className={connectionStatus}>{connectionStatus}</span>
      </div>
      
      <div className="messages">
        {messages.map(message => (
          <div key={message.id} className="message">
            <strong>{message.author}:</strong> {message.text}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Memory Leak Prevention

```jsx
function MemoryLeakPrevention() {
  const [data, setData] = useState(null);
  const isMountedRef = useRef(true);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('/api/data');
        const result = await response.json();
        
        // Only update state if component is still mounted
        if (isMountedRef.current) {
          setData(result);
        }
      } catch (error) {
        if (isMountedRef.current) {
          console.error('Failed to fetch data:', error);
        }
      }
    };
    
    fetchData();
    
    // Cleanup: Mark component as unmounted
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  
  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;
}

// Custom hook for safer async operations
function useSafeAsync() {
  const isMountedRef = useRef(true);
  
  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  
  const safeSetState = useCallback((setState) => {
    return (...args) => {
      if (isMountedRef.current) {
        setState(...args);
      }
    };
  }, []);
  
  return safeSetState;
}

function SafeAsyncComponent() {
  const [data, setData] = useState(null);
  const safeSetState = useSafeAsync();
  const safeSetData = safeSetState(setData);
  
  useEffect(() => {
    fetch('/api/data')
      .then(response => response.json())
      .then(safeSetData); // Safe to call even if component unmounts
  }, [safeSetData]);
  
  return <div>{data ? 'Data loaded' : 'Loading...'}</div>;
}
```

## Common useEffect Patterns and Best Practices

### 1. Custom Hooks for Reusable Effects

```jsx
// Custom hook for data fetching
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    if (!url) return;
    
    const abortController = new AbortController();
    
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(url, {
          signal: abortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
    
    return () => {
      abortController.abort();
    };
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useApi(`/api/users/${userId}`);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;
  
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

### 2. Effect Composition and Separation

```jsx
function UserDashboard({ userId }) {
  const [user, setUser] = useState(null);
  const [notifications, setNotifications] = useState([]);
  const [activityLog, setActivityLog] = useState([]);
  
  // Separate effect for user data
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  // Separate effect for notifications
  useEffect(() => {
    fetchNotifications(userId).then(setNotifications);
  }, [userId]);
  
  // Separate effect for activity log
  useEffect(() => {
    fetchActivityLog(userId).then(setActivityLog);
  }, [userId]);
  
  // Separate effect for document title
  useEffect(() => {
    if (user) {
      document.title = `Dashboard - ${user.name}`;
    }
    
    return () => {
      document.title = 'Dashboard';
    };
  }, [user]);
  
  return (
    <div>
      {/* Dashboard content */}
    </div>
  );
}
```

## Summary

Understanding `useEffect` is crucial for React development:

### Key Takeaways:

1. **Side Effects**: Operations that affect the outside world (API calls, timers, DOM manipulation)
2. **useEffect Hook**: React's way to handle side effects in functional components
3. **Dependency Array**: Controls when effects run - crucial for performance and correctness
4. **Cleanup Function**: Prevents memory leaks and maintains good performance

### Dependency Array Rules:
- **No array**: Runs after every render
- **Empty array []**: Runs once on mount
- **With dependencies [a, b]**: Runs when dependencies change
- **Include all dependencies**: Prevents stale closure bugs

### Cleanup Best Practices:
- ✅ Clear timers and intervals
- ✅ Remove event listeners
- ✅ Cancel network requests
- ✅ Unsubscribe from services
- ✅ Reset global state

### Performance Tips:
- Use functional updates to reduce dependencies
- Extract functions with `useCallback` when needed
- Separate concerns with multiple effects
- Create custom hooks for reusable logic
- Use ESLint plugin for exhaustive deps

**Next Steps**: Learn about custom hooks for reusable logic, advanced state management patterns, and optimizing React applications for performance!