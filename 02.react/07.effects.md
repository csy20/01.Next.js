# React useEffect: Managing Side Effects

## 6.1 What is a "Side Effect"?

A side effect is any operation that affects something **outside** of the component itself. React components should be "pure" functions that only depend on their props and state, but real applications need to interact with the outside world.

### Understanding Pure vs Side Effects

```jsx
// ‚úÖ Pure function - no side effects
function PureComponent({ name, age }) {
  const greeting = `Hello, ${name}! You are ${age} years old.`;
  return <div>{greeting}</div>;
}

// ‚ùå Side effects mixed in render (DON'T DO THIS)
function ImpureComponent({ userId }) {
  // These are side effects happening during render!
  fetch(`/api/users/${userId}`);  // API call
  document.title = `User ${userId}`;  // DOM manipulation
  localStorage.setItem('lastUser', userId);  // External storage
  
  return <div>User Profile</div>;
}

// ‚úÖ Side effects properly managed with useEffect
function ProperComponent({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    // Side effects belong here, not in render
    fetch(`/api/users/${userId}`)
      .then(response => response.json())
      .then(setUser);
    
    document.title = `User ${userId}`;
    localStorage.setItem('lastUser', userId);
  }, [userId]);
  
  return <div>{user ? user.name : 'Loading...'}</div>;
}
```

### Common Types of Side Effects

#### 1. Data Fetching

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const userData = await response.json();
        setUser(userData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUser();
  }, [userId]);
  
  if (loading) return <div>Loading user...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <p>Joined: {new Date(user.joinDate).toLocaleDateString()}</p>
    </div>
  );
}
```

#### 2. Timers and Intervals

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  
  useEffect(() => {
    let intervalId;
    
    if (isRunning) {
      intervalId = setInterval(() => {
        setSeconds(prev => prev + 1);
      }, 1000);
    }
    
    // Cleanup function
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isRunning]);
  
  const formatTime = (totalSeconds) => {
    const minutes = Math.floor(totalSeconds / 60);
    const secs = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };
  
  return (
    <div className="timer">
      <h2>{formatTime(seconds)}</h2>
      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? 'Pause' : 'Start'}
      </button>
      <button onClick={() => {
        setSeconds(0);
        setIsRunning(false);
      }}>
        Reset
      </button>
    </div>
  );
}
```

#### 3. DOM Manipulation

```jsx
function DocumentTitle({ title, count }) {
  useEffect(() => {
    // Update document title
    const originalTitle = document.title;
    document.title = count > 0 ? `(${count}) ${title}` : title;
    
    // Restore original title on cleanup
    return () => {
      document.title = originalTitle;
    };
  }, [title, count]);
  
  return <div>Check the browser tab title!</div>;
}

function ScrollToTop() {
  useEffect(() => {
    // Scroll to top when component mounts
    window.scrollTo(0, 0);
  }, []); // Empty dependency array = run once on mount
  
  return <div>Content that might be scrolled to...</div>;
}

function FocusInput() {
  const inputRef = useRef(null);
  
  useEffect(() => {
    // Focus input when component mounts
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  
  return (
    <div>
      <input 
        ref={inputRef}
        type="text" 
        placeholder="This input gets focused automatically"
      />
    </div>
  );
}
```

#### 4. Event Listeners

```jsx
function WindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    // Add event listener
    window.addEventListener('resize', handleResize);
    
    // Cleanup: remove event listener
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // No dependencies, setup once
  
  return (
    <div>
      <p>Window size: {windowSize.width} x {windowSize.height}</p>
      <p>Try resizing your browser window!</p>
    </div>
  );
}

function KeyLogger() {
  const [lastKey, setLastKey] = useState('');
  const [keyHistory, setKeyHistory] = useState([]);
  
  useEffect(() => {
    const handleKeyPress = (event) => {
      setLastKey(event.key);
      setKeyHistory(prev => [...prev.slice(-9), event.key]); // Keep last 10 keys
    };
    
    // Add event listener to document
    document.addEventListener('keydown', handleKeyPress);
    
    // Cleanup
    return () => {
      document.removeEventListener('keydown', handleKeyPress);
    };
  }, []);
  
  return (
    <div>
      <p>Last key pressed: <strong>{lastKey}</strong></p>
      <p>Recent keys: {keyHistory.join(' ‚Üí ')}</p>
      <p>Press any key to see it logged here!</p>
    </div>
  );
}
```

#### 5. Local Storage and Browser APIs

```jsx
function LocalStorageCounter() {
  const [count, setCount] = useState(() => {
    // Initialize from localStorage
    const saved = localStorage.getItem('counter');
    return saved ? parseInt(saved, 10) : 0;
  });
  
  useEffect(() => {
    // Save to localStorage whenever count changes
    localStorage.setItem('counter', count.toString());
  }, [count]);
  
  return (
    <div>
      <p>Count: {count} (persisted in localStorage)</p>
      <button onClick={() => setCount(prev => prev + 1)}>
        Increment
      </button>
      <button onClick={() => setCount(0)}>
        Reset
      </button>
    </div>
  );
}

function GeolocationTracker() {
  const [location, setLocation] = useState(null);
  const [error, setError] = useState(null);
  const [watching, setWatching] = useState(false);
  
  useEffect(() => {
    let watchId;
    
    if (watching && 'geolocation' in navigator) {
      watchId = navigator.geolocation.watchPosition(
        (position) => {
          setLocation({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy
          });
          setError(null);
        },
        (error) => {
          setError(error.message);
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    }
    
    // Cleanup: stop watching location
    return () => {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
      }
    };
  }, [watching]);
  
  if (!('geolocation' in navigator)) {
    return <div>Geolocation is not supported by this browser.</div>;
  }
  
  return (
    <div>
      <button onClick={() => setWatching(!watching)}>
        {watching ? 'Stop Tracking' : 'Start Tracking'}
      </button>
      
      {error && <p>Error: {error}</p>}
      
      {location && (
        <div>
          <p>Latitude: {location.latitude}</p>
          <p>Longitude: {location.longitude}</p>
          <p>Accuracy: {location.accuracy} meters</p>
        </div>
      )}
    </div>
  );
}
```

## 6.2 The useEffect Hook

The `useEffect` hook is React's way of handling side effects in functional components. It replaces lifecycle methods from class components and provides a more intuitive way to manage effects.

### Basic Syntax

```jsx
import React, { useEffect, useState } from 'react';

function MyComponent() {
  useEffect(() => {
    // Side effect code here
    console.log('Effect runs');
    
    // Optional cleanup function
    return () => {
      console.log('Cleanup runs');
    };
  }, [/* dependency array */]);
  
  return <div>My Component</div>;
}
```

### useEffect Lifecycle

```jsx
function EffectLifecycleDemo() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('React');
  
  // Effect with no dependencies - runs after every render
  useEffect(() => {
    console.log('Effect runs after every render');
  });
  
  // Effect with empty dependencies - runs only on mount
  useEffect(() => {
    console.log('Effect runs only on mount');
    
    return () => {
      console.log('Cleanup runs only on unmount');
    };
  }, []);
  
  // Effect with specific dependencies
  useEffect(() => {
    console.log(`Effect runs when count changes: ${count}`);
    
    return () => {
      console.log(`Cleanup before count changes from: ${count}`);
    };
  }, [count]);
  
  // Effect with multiple dependencies
  useEffect(() => {
    console.log(`Effect runs when count or name changes: ${count}, ${name}`);
  }, [count, name]);
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Name: {name}</p>
      <button onClick={() => setCount(prev => prev + 1)}>
        Increment Count
      </button>
      <input 
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Change name"
      />
    </div>
  );
}
```

### Common useEffect Patterns

#### 1. Data Fetching Pattern

```jsx
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [page, setPage] = useState(1);
  
  useEffect(() => {
    const fetchUsers = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/users?page=${page}&limit=10`);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch users: ${response.status}`);
        }
        
        const data = await response.json();
        setUsers(data.users);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUsers();
  }, [page]); // Re-run when page changes
  
  const nextPage = () => setPage(prev => prev + 1);
  const prevPage = () => setPage(prev => Math.max(1, prev - 1));
  
  if (loading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <div className="users">
        {users.map(user => (
          <div key={user.id} className="user-card">
            <h3>{user.name}</h3>
            <p>{user.email}</p>
          </div>
        ))}
      </div>
      
      <div className="pagination">
        <button onClick={prevPage} disabled={page === 1}>
          Previous
        </button>
        <span>Page {page}</span>
        <button onClick={nextPage}>
          Next
        </button>
      </div>
    </div>
  );
}
```

#### 2. Real-time Data Updates

```jsx
function LiveDataFeed() {
  const [data, setData] = useState([]);
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    // Simulate WebSocket connection
    const ws = new WebSocket('wss://api.example.com/live-data');
    
    ws.onopen = () => {
      setIsConnected(true);
      console.log('Connected to live data feed');
    };
    
    ws.onmessage = (event) => {
      const newData = JSON.parse(event.data);
      setData(prev => [newData, ...prev.slice(0, 9)]); // Keep last 10 items
    };
    
    ws.onclose = () => {
      setIsConnected(false);
      console.log('Disconnected from live data feed');
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      setIsConnected(false);
    };
    
    // Cleanup: close connection when component unmounts
    return () => {
      ws.close();
    };
  }, []); // No dependencies - setup once
  
  return (
    <div>
      <div className="status">
        Status: {isConnected ? 'üü¢ Connected' : 'üî¥ Disconnected'}
      </div>
      
      <div className="live-data">
        <h3>Live Data Feed</h3>
        {data.map((item, index) => (
          <div key={item.id || index} className="data-item">
            <span>{item.timestamp}</span>
            <span>{item.value}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### 3. Animation and Visual Effects

```jsx
function FadeInComponent({ children, delay = 0 }) {
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(true);
    }, delay);
    
    return () => clearTimeout(timer);
  }, [delay]);
  
  return (
    <div 
      style={{
        opacity: isVisible ? 1 : 0,
        transition: 'opacity 0.5s ease-in-out',
        transform: isVisible ? 'translateY(0)' : 'translateY(20px)'
      }}
    >
      {children}
    </div>
  );
}

function ProgressBar({ target, duration = 2000 }) {
  const [progress, setProgress] = useState(0);
  
  useEffect(() => {
    if (target === 0) {
      setProgress(0);
      return;
    }
    
    const increment = target / (duration / 50); // Update every 50ms
    let current = 0;
    
    const timer = setInterval(() => {
      current += increment;
      if (current >= target) {
        setProgress(target);
        clearInterval(timer);
      } else {
        setProgress(current);
      }
    }, 50);
    
    return () => clearInterval(timer);
  }, [target, duration]);
  
  return (
    <div className="progress-container">
      <div 
        className="progress-bar"
        style={{
          width: `${progress}%`,
          transition: 'width 0.1s ease-out'
        }}
      />
      <span>{Math.round(progress)}%</span>
    </div>
  );
}
```

## 6.3 The Dependency Array

The dependency array is the second argument to `useEffect` and controls when the effect runs. Understanding it properly is crucial for preventing bugs and optimizing performance.

### Dependency Array Patterns

#### 1. No Dependency Array - Runs Every Render

```jsx
function RunsEveryRender() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('This runs after every render');
    // ‚ö†Ô∏è This can cause performance issues!
  }); // No dependency array
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

#### 2. Empty Dependency Array - Runs Once on Mount

```jsx
function RunsOnceOnMount() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    console.log('This runs only once when component mounts');
    
    // Perfect for:
    // - Initial data fetching
    // - Setting up event listeners
    // - Initializing third-party libraries
    
    fetchInitialData().then(setData);
  }, []); // Empty array = run once
  
  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;
}
```

#### 3. Specific Dependencies - Runs When Dependencies Change

```jsx
function RunsWhenDependenciesChange() {
  const [userId, setUserId] = useState(1);
  const [userData, setUserData] = useState(null);
  const [theme, setTheme] = useState('light');
  
  // Effect depends on userId only
  useEffect(() => {
    console.log(`Fetching data for user ${userId}`);
    fetchUserData(userId).then(setUserData);
  }, [userId]); // Runs when userId changes
  
  // Effect depends on theme only
  useEffect(() => {
    console.log(`Applying theme: ${theme}`);
    document.body.className = `theme-${theme}`;
  }, [theme]); // Runs when theme changes
  
  // Effect depends on both userId and theme
  useEffect(() => {
    console.log(`User ${userId} using ${theme} theme`);
    analytics.track('user_theme_combo', { userId, theme });
  }, [userId, theme]); // Runs when either changes
  
  return (
    <div>
      <button onClick={() => setUserId(prev => prev + 1)}>
        Next User
      </button>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Toggle Theme
      </button>
      <p>Current user: {userId}</p>
      <p>Current theme: {theme}</p>
    </div>
  );
}
```

### Dependency Array Best Practices

#### 1. Include All Dependencies

```jsx
// ‚ùå Missing dependencies - can cause stale closure bugs
function MissingDependencies() {
  const [count, setCount] = useState(0);
  const [multiplier, setMultiplier] = useState(2);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count * multiplier); // Uses stale values!
    }, 1000);
    
    return () => clearInterval(timer);
  }, []); // Missing count and multiplier dependencies
  
  return <div>Count: {count}</div>;
}

// ‚úÖ All dependencies included
function AllDependenciesIncluded() {
  const [count, setCount] = useState(0);
  const [multiplier, setMultiplier] = useState(2);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(prevCount => prevCount * multiplier); // Use functional update
    }, 1000);
    
    return () => clearInterval(timer);
  }, [multiplier]); // Include multiplier, use functional update for count
  
  return <div>Count: {count}</div>;
}
```

#### 2. Functional Updates to Avoid Dependencies

```jsx
function FunctionalUpdates() {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(1);
  
  // ‚ùå Adding count to dependencies causes effect to re-run frequently
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count + step);
    }, 1000);
    
    return () => clearInterval(timer);
  }, [count, step]); // Effect restarts every second!
  
  // ‚úÖ Use functional update to avoid count dependency
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(prevCount => prevCount + step);
    }, 1000);
    
    return () => clearInterval(timer);
  }, [step]); // Only re-run when step changes
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setStep(step + 1)}>
        Increase Step (current: {step})
      </button>
    </div>
  );
}
```

#### 3. Extracting Functions to Avoid Dependencies

```jsx
// ‚ùå Function in dependency array can cause issues
function FunctionInDependencies({ userId }) {
  const [user, setUser] = useState(null);
  
  const fetchUser = async (id) => {
    const response = await fetch(`/api/users/${id}`);
    const userData = await response.json();
    setUser(userData);
  };
  
  useEffect(() => {
    fetchUser(userId);
  }, [userId, fetchUser]); // fetchUser reference changes every render!
  
  return <div>{user?.name}</div>;
}

// ‚úÖ Use useCallback to stabilize function reference
function StableFunctionReference({ userId }) {
  const [user, setUser] = useState(null);
  
  const fetchUser = useCallback(async (id) => {
    const response = await fetch(`/api/users/${id}`);
    const userData = await response.json();
    setUser(userData);
  }, []); // No dependencies, function is stable
  
  useEffect(() => {
    fetchUser(userId);
  }, [userId, fetchUser]); // fetchUser is now stable
  
  return <div>{user?.name}</div>;
}

// ‚úÖ Or define function inside effect
function FunctionInsideEffect({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    const fetchUser = async (id) => {
      const response = await fetch(`/api/users/${id}`);
      const userData = await response.json();
      setUser(userData);
    };
    
    fetchUser(userId);
  }, [userId]); // Only userId dependency needed
  
  return <div>{user?.name}</div>;
}
```

### Advanced Dependency Patterns

#### 1. Object and Array Dependencies

```jsx
function ObjectDependencies() {
  const [config, setConfig] = useState({ theme: 'light', lang: 'en' });
  const [data, setData] = useState(null);
  
  // ‚ùå Object reference changes every render even if values are the same
  useEffect(() => {
    fetchDataWithConfig(config).then(setData);
  }, [config]); // Effect runs on every render!
  
  // ‚úÖ Use individual properties as dependencies
  useEffect(() => {
    const configObj = { theme: config.theme, lang: config.lang };
    fetchDataWithConfig(configObj).then(setData);
  }, [config.theme, config.lang]); // Only run when actual values change
  
  return <div>{data ? 'Data loaded' : 'Loading...'}</div>;
}

function ArrayDependencies() {
  const [filters, setFilters] = useState(['active', 'verified']);
  const [results, setResults] = useState([]);
  
  // ‚ùå Array reference changes even if contents are the same
  useEffect(() => {
    searchWithFilters(filters).then(setResults);
  }, [filters]);
  
  // ‚úÖ Use useMemo to stabilize array reference
  const stableFilters = useMemo(() => filters, [filters.join(',')]);
  
  useEffect(() => {
    searchWithFilters(stableFilters).then(setResults);
  }, [stableFilters]);
  
  return <div>Results: {results.length}</div>;
}
```

#### 2. Custom Dependency Comparison

```jsx
function DeepComparisonEffect({ user }) {
  const [profile, setProfile] = useState(null);
  
  // Custom hook for deep comparison
  const usePrevious = (value) => {
    const ref = useRef();
    useEffect(() => {
      ref.current = value;
    });
    return ref.current;
  };
  
  const useDeepEffect = (callback, dependencies) => {
    const prevDeps = usePrevious(dependencies);
    const hasChanged = !prevDeps || !deepEqual(prevDeps, dependencies);
    
    useEffect(() => {
      if (hasChanged) {
        callback();
      }
    });
  };
  
  useDeepEffect(() => {
    fetchUserProfile(user.id).then(setProfile);
  }, [user]);
  
  return <div>{profile?.name}</div>;
}
```

## 6.4 The Cleanup Function

The cleanup function is crucial for preventing memory leaks and ensuring your application performs well. It runs before the component unmounts or before the effect runs again.

### When Cleanup Runs

```jsx
function CleanupTiming() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log(`Effect runs for count: ${count}`);
    
    return () => {
      console.log(`Cleanup runs for count: ${count}`);
    };
  }, [count]);
  
  // Cleanup sequence when count changes from 0 to 1:
  // 1. "Effect runs for count: 0" (initial)
  // 2. User clicks button
  // 3. "Cleanup runs for count: 0" (before new effect)
  // 4. "Effect runs for count: 1" (new effect)
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Common Cleanup Scenarios

#### 1. Cleaning Up Timers

```jsx
function CountdownTimer({ initialSeconds }) {
  const [seconds, setSeconds] = useState(initialSeconds);
  const [isActive, setIsActive] = useState(false);
  
  useEffect(() => {
    let intervalId;
    
    if (isActive && seconds > 0) {
      intervalId = setInterval(() => {
        setSeconds(prev => {
          if (prev <= 1) {
            setIsActive(false);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }
    
    // Cleanup: Clear interval
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isActive, seconds]);
  
  const reset = () => {
    setSeconds(initialSeconds);
    setIsActive(false);
  };
  
  return (
    <div className="countdown-timer">
      <div className="display">
        {Math.floor(seconds / 60)}:{(seconds % 60).toString().padStart(2, '0')}
      </div>
      
      <div className="controls">
        <button onClick={() => setIsActive(!isActive)}>
          {isActive ? 'Pause' : 'Start'}
        </button>
        <button onClick={reset}>Reset</button>
      </div>
      
      {seconds === 0 && <div className="finished">Time's up!</div>}
    </div>
  );
}
```

#### 2. Cleaning Up Event Listeners

```jsx
function MouseTracker() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isTracking, setIsTracking] = useState(false);
  
  useEffect(() => {
    if (!isTracking) return;
    
    const handleMouseMove = (event) => {
      setPosition({
        x: event.clientX,
        y: event.clientY
      });
    };
    
    const handleKeyPress = (event) => {
      if (event.key === 'Escape') {
        setIsTracking(false);
      }
    };
    
    // Add event listeners
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('keydown', handleKeyPress);
    
    // Cleanup: Remove event listeners
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('keydown', handleKeyPress);
    };
  }, [isTracking]);
  
  return (
    <div className="mouse-tracker">
      <button onClick={() => setIsTracking(!isTracking)}>
        {isTracking ? 'Stop Tracking' : 'Start Tracking'}
      </button>
      
      {isTracking && (
        <div>
          <p>Mouse position: ({position.x}, {position.y})</p>
          <p>Press Escape to stop tracking</p>
        </div>
      )}
    </div>
  );
}
```

#### 3. Cleaning Up Network Requests

```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    if (!query.trim()) {
      setResults([]);
      return;
    }
    
    // Create AbortController for this request
    const abortController = new AbortController();
    const signal = abortController.signal;
    
    const searchData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`, {
          signal // Pass signal to fetch
        });
        
        if (!response.ok) {
          throw new Error(`Search failed: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Check if request was aborted
        if (!signal.aborted) {
          setResults(data.results);
        }
      } catch (err) {
        if (err.name !== 'AbortError' && !signal.aborted) {
          setError(err.message);
        }
      } finally {
        if (!signal.aborted) {
          setLoading(false);
        }
      }
    };
    
    searchData();
    
    // Cleanup: Abort ongoing request
    return () => {
      abortController.abort();
    };
  }, [query]);
  
  return (
    <div className="search-results">
      {loading && <div>Searching...</div>}
      {error && <div>Error: {error}</div>}
      
      <div className="results">
        {results.map(result => (
          <div key={result.id} className="result-item">
            <h3>{result.title}</h3>
            <p>{result.description}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### 4. Cleaning Up Subscriptions

```jsx
function LiveChat({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  
  useEffect(() => {
    if (!roomId) return;
    
    // Create connection
    const chatClient = new ChatClient(roomId);
    
    const handleConnect = () => {
      setConnectionStatus('connected');
    };
    
    const handleDisconnect = () => {
      setConnectionStatus('disconnected');
    };
    
    const handleMessage = (message) => {
      setMessages(prev => [...prev, message]);
    };
    
    const handleError = (error) => {
      console.error('Chat error:', error);
      setConnectionStatus('error');
    };
    
    // Subscribe to events
    chatClient.on('connect', handleConnect);
    chatClient.on('disconnect', handleDisconnect);
    chatClient.on('message', handleMessage);
    chatClient.on('error', handleError);
    
    // Connect
    chatClient.connect();
    
    // Cleanup: Unsubscribe and disconnect
    return () => {
      chatClient.off('connect', handleConnect);
      chatClient.off('disconnect', handleDisconnect);
      chatClient.off('message', handleMessage);
      chatClient.off('error', handleError);
      chatClient.disconnect();
    };
  }, [roomId]);
  
  return (
    <div className="live-chat">
      <div className="status">
        Status: <span className={connectionStatus}>{connectionStatus}</span>
      </div>
      
      <div className="messages">
        {messages.map(message => (
          <div key={message.id} className="message">
            <strong>{message.author}:</strong> {message.text}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Memory Leak Prevention

```jsx
function MemoryLeakPrevention() {
  const [data, setData] = useState(null);
  const isMountedRef = useRef(true);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('/api/data');
        const result = await response.json();
        
        // Only update state if component is still mounted
        if (isMountedRef.current) {
          setData(result);
        }
      } catch (error) {
        if (isMountedRef.current) {
          console.error('Failed to fetch data:', error);
        }
      }
    };
    
    fetchData();
    
    // Cleanup: Mark component as unmounted
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  
  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;
}

// Custom hook for safer async operations
function useSafeAsync() {
  const isMountedRef = useRef(true);
  
  useEffect(() => {
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  
  const safeSetState = useCallback((setState) => {
    return (...args) => {
      if (isMountedRef.current) {
        setState(...args);
      }
    };
  }, []);
  
  return safeSetState;
}

function SafeAsyncComponent() {
  const [data, setData] = useState(null);
  const safeSetState = useSafeAsync();
  const safeSetData = safeSetState(setData);
  
  useEffect(() => {
    fetch('/api/data')
      .then(response => response.json())
      .then(safeSetData); // Safe to call even if component unmounts
  }, [safeSetData]);
  
  return <div>{data ? 'Data loaded' : 'Loading...'}</div>;
}
```

## Common useEffect Patterns and Best Practices

### 1. Custom Hooks for Reusable Effects

```jsx
// Custom hook for data fetching
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    if (!url) return;
    
    const abortController = new AbortController();
    
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(url, {
          signal: abortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
    
    return () => {
      abortController.abort();
    };
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useApi(`/api/users/${userId}`);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;
  
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

### 2. Effect Composition and Separation

```jsx
function UserDashboard({ userId }) {
  const [user, setUser] = useState(null);
  const [notifications, setNotifications] = useState([]);
  const [activityLog, setActivityLog] = useState([]);
  
  // Separate effect for user data
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  // Separate effect for notifications
  useEffect(() => {
    fetchNotifications(userId).then(setNotifications);
  }, [userId]);
  
  // Separate effect for activity log
  useEffect(() => {
    fetchActivityLog(userId).then(setActivityLog);
  }, [userId]);
  
  // Separate effect for document title
  useEffect(() => {
    if (user) {
      document.title = `Dashboard - ${user.name}`;
    }
    
    return () => {
      document.title = 'Dashboard';
    };
  }, [user]);
  
  return (
    <div>
      {/* Dashboard content */}
    </div>
  );
}
```

## Summary

Understanding `useEffect` is crucial for React development:

### Key Takeaways:

1. **Side Effects**: Operations that affect the outside world (API calls, timers, DOM manipulation)
2. **useEffect Hook**: React's way to handle side effects in functional components
3. **Dependency Array**: Controls when effects run - crucial for performance and correctness
4. **Cleanup Function**: Prevents memory leaks and maintains good performance

### Dependency Array Rules:
- **No array**: Runs after every render
- **Empty array []**: Runs once on mount
- **With dependencies [a, b]**: Runs when dependencies change
- **Include all dependencies**: Prevents stale closure bugs

### Cleanup Best Practices:
- ‚úÖ Clear timers and intervals
- ‚úÖ Remove event listeners
- ‚úÖ Cancel network requests
- ‚úÖ Unsubscribe from services
- ‚úÖ Reset global state

### Performance Tips:
- Use functional updates to reduce dependencies
- Extract functions with `useCallback` when needed
- Separate concerns with multiple effects
- Create custom hooks for reusable logic
- Use ESLint plugin for exhaustive deps

**Next Steps**: Learn about custom hooks for reusable logic, advanced state management patterns, and optimizing React applications for performance!