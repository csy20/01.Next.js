# React Props: The Data Highway Between Components

## üéØ Introduction: Understanding Props

Props (short for "properties") are React's fundamental mechanism for **passing data from parent components to child components**. Think of props as the "parameters" of your React components - they allow you to customize and configure how a component behaves and what it displays.

### üîÑ The Props Flow Paradigm

```jsx
// üè† Parent Component (Data Source)
const UserDashboard = () => {
  const userData = {
    id: 1,
    name: 'Sarah Chen',
    email: 'sarah@example.com',
    role: 'admin',
    avatar: '/avatars/sarah.jpg',
    lastLogin: '2024-08-14T10:30:00Z',
    preferences: {
      theme: 'dark',
      notifications: true,
      language: 'en'
    }
  };

  const handleUserUpdate = (updatedUser) => {
    console.log('User updated:', updatedUser);
  };

  return (
    <div className="dashboard">
      {/* üì§ Passing props DOWN to child */}
      <UserProfile 
        user={userData}
        onUpdate={handleUserUpdate}
        showEditButton={true}
        theme={userData.preferences.theme}
      />
      
      <UserStats userId={userData.id} />
      <UserActivity user={userData} />
    </div>
  );
};

// üë∂ Child Component (Data Receiver)
const UserProfile = (props) => {
  // üì• Receiving props from parent
  const { user, onUpdate, showEditButton, theme } = props;
  
  return (
    <div className={`user-profile theme-${theme}`}>
      <img src={user.avatar} alt={user.name} />
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <span className="role">{user.role}</span>
      
      {showEditButton && (
        <button onClick={() => onUpdate(user)}>
          Edit Profile
        </button>
      )}
    </div>
  );
};
```

### üé≠ Props Characteristics: The Four Pillars

#### 1. **Read-Only Nature**
```jsx
// ‚ùå NEVER modify props directly
const BadComponent = ({ user }) => {
  user.name = 'Modified Name'; // This is forbidden!
  return <div>{user.name}</div>;
};

// ‚úÖ Props are immutable - treat them as read-only
const GoodComponent = ({ user }) => {
  const displayName = user.name.toUpperCase(); // Create new value
  return <div>{displayName}</div>;
};
```

#### 2. **Unidirectional Data Flow**
```jsx
// Data flows DOWN the component tree
Parent Component
‚îú‚îÄ‚îÄ Props ‚Üí Child Component A
‚îú‚îÄ‚îÄ Props ‚Üí Child Component B
‚îÇ   ‚îî‚îÄ‚îÄ Props ‚Üí Grandchild Component
‚îî‚îÄ‚îÄ Props ‚Üí Child Component C

// Children cannot directly modify parent data
// They communicate UP through callback functions
```

#### 3. **Type Flexibility**
```jsx
const FlexibleComponent = ({
  // Primitive types
  name,           // string
  age,            // number
  isActive,       // boolean
  
  // Complex types
  user,           // object
  hobbies,        // array
  onSave,         // function
  
  // Special types
  children,       // JSX/React nodes
  render,         // render function
  component       // React component
}) => {
  return (
    <div>
      {/* Use all different prop types */}
    </div>
  );
};
```

#### 4. **Dynamic Configuration**
```jsx
// Same component, different configurations
<Button variant="primary" size="large">Submit</Button>
<Button variant="secondary" size="small">Cancel</Button>
<Button variant="danger" size="medium" disabled>Delete</Button>
```

## üì¶ Props Types & Patterns

### üé® Basic Props Usage

#### **Simple Data Props**
```jsx
const WelcomeCard = ({ title, message, userName, timestamp }) => {
  return (
    <div className="welcome-card">
      <h1>{title}</h1>
      <p>{message}</p>
      <div className="user-info">
        <span>Welcome, {userName}!</span>
        <time>{new Date(timestamp).toLocaleDateString()}</time>
      </div>
    </div>
  );
};

// Usage
<WelcomeCard 
  title="Good Morning!"
  message="Ready to start your productive day?"
  userName="Alex"
  timestamp="2024-08-14T09:00:00Z"
/>
```

#### **Object Props Pattern**
```jsx
const ProductCard = ({ product, seller, pricing }) => {
  return (
    <div className="product-card">
      {/* Product object */}
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>{product.description}</p>
      <div className="category">{product.category}</div>
      
      {/* Seller object */}
      <div className="seller-info">
        <img src={seller.avatar} alt={seller.name} />
        <span>{seller.name}</span>
        <div className="rating">‚òÖ {seller.rating}</div>
      </div>
      
      {/* Pricing object */}
      <div className="pricing">
        <span className="price">${pricing.current}</span>
        {pricing.original && (
          <span className="original-price">${pricing.original}</span>
        )}
        {pricing.discount && (
          <span className="discount">{pricing.discount}% OFF</span>
        )}
      </div>
    </div>
  );
};

// Usage
<ProductCard 
  product={{
    id: 1,
    name: 'Wireless Headphones',
    description: 'High-quality noise-canceling headphones',
    image: '/products/headphones.jpg',
    category: 'Electronics'
  }}
  seller={{
    id: 101,
    name: 'TechStore Plus',
    avatar: '/sellers/techstore.jpg',
    rating: 4.8
  }}
  pricing={{
    current: 199,
    original: 299,
    discount: 33
  }}
/>
```

### üé≠ Advanced Props Patterns

#### 1. **Props Destructuring Mastery**
```jsx
// ‚úÖ Basic destructuring
const UserCard = ({ name, email, role }) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>{email}</p>
      <span>{role}</span>
    </div>
  );
};

// ‚úÖ Destructuring with defaults
const Button = ({ 
  text = 'Click me',
  variant = 'primary',
  size = 'medium',
  disabled = false,
  loading = false,
  onClick = () => {}
}) => {
  return (
    <button 
      className={`btn btn-${variant} btn-${size}`}
      disabled={disabled || loading}
      onClick={onClick}
    >
      {loading ? 'Loading...' : text}
    </button>
  );
};

// ‚úÖ Nested object destructuring
const UserProfile = ({ 
  user: { 
    name, 
    email, 
    avatar,
    preferences: { theme, notifications } = {} 
  },
  onEdit,
  showActions = true 
}) => {
  return (
    <div className={`profile theme-${theme}`}>
      <img src={avatar} alt={name} />
      <h2>{name}</h2>
      <p>{email}</p>
      {notifications && <span>üîî Notifications ON</span>}
      {showActions && <button onClick={onEdit}>Edit</button>}
    </div>
  );
};

// ‚úÖ Rest props pattern
const CustomInput = ({ 
  label, 
  error, 
  helpText,
  ...inputProps  // Collects all remaining props
}) => {
  return (
    <div className="input-group">
      {label && <label>{label}</label>}
      <input 
        className={`form-input ${error ? 'error' : ''}`}
        {...inputProps}  // Spreads all collected props to input
      />
      {error && <span className="error-text">{error}</span>}
      {helpText && <span className="help-text">{helpText}</span>}
    </div>
  );
};

// Usage - all standard input props are passed through
<CustomInput 
  label="Email Address"
  type="email"
  placeholder="Enter your email"
  value={email}
  onChange={handleEmailChange}
  required
  autoComplete="email"
  maxLength={100}
  error={emailError}
  helpText="We'll never share your email"
/>
```

#### 2. **Function Props for Communication**
```jsx
const TodoItem = ({ 
  todo, 
  onToggle, 
  onEdit, 
  onDelete,
  onPriorityChange 
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);

  const handleSave = () => {
    onEdit(todo.id, editText);
    setIsEditing(false);
  };

  return (
    <div className={`todo-item ${todo.completed ? 'completed' : ''}`}>
      <input 
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      
      {isEditing ? (
        <div className="edit-mode">
          <input 
            value={editText}
            onChange={(e) => setEditText(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSave()}
          />
          <button onClick={handleSave}>Save</button>
          <button onClick={() => setIsEditing(false)}>Cancel</button>
        </div>
      ) : (
        <div className="view-mode">
          <span className="todo-text">{todo.text}</span>
          <select 
            value={todo.priority}
            onChange={(e) => onPriorityChange(todo.id, e.target.value)}
          >
            <option value="low">Low</option>
            <option value="medium">Medium</option>
            <option value="high">High</option>
          </select>
          <button onClick={() => setIsEditing(true)}>Edit</button>
          <button onClick={() => onDelete(todo.id)}>Delete</button>
        </div>
      )}
    </div>
  );
};

// Parent component with multiple handlers
const TodoList = () => {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', completed: false, priority: 'high' },
    { id: 2, text: 'Build a project', completed: false, priority: 'medium' }
  ]);

  const handleToggle = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const handleEdit = (id, newText) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, text: newText } : todo
    ));
  };

  const handleDelete = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  const handlePriorityChange = (id, priority) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, priority } : todo
    ));
  };

  return (
    <div className="todo-list">
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
          onEdit={handleEdit}
          onDelete={handleDelete}
          onPriorityChange={handlePriorityChange}
        />
      ))}
    </div>
  );
};
```

#### 3. **Children Prop for Composition**
```jsx
// ‚úÖ Basic children usage
const Modal = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={e => e.stopPropagation()}>
        <button className="close-button" onClick={onClose}>√ó</button>
        {children}
      </div>
    </div>
  );
};

// Usage
<Modal isOpen={showModal} onClose={() => setShowModal(false)}>
  <h2>Confirm Action</h2>
  <p>Are you sure you want to delete this item?</p>
  <div className="modal-actions">
    <button onClick={handleDelete}>Delete</button>
    <button onClick={() => setShowModal(false)}>Cancel</button>
  </div>
</Modal>

// ‚úÖ Advanced children manipulation
const Tabs = ({ children, activeTab, onTabChange }) => {
  const tabs = React.Children.toArray(children);
  
  return (
    <div className="tabs">
      <div className="tab-headers">
        {tabs.map((tab, index) => (
          <button
            key={index}
            className={`tab-header ${index === activeTab ? 'active' : ''}`}
            onClick={() => onTabChange(index)}
          >
            {tab.props.label}
          </button>
        ))}
      </div>
      
      <div className="tab-content">
        {tabs[activeTab]}
      </div>
    </div>
  );
};

const Tab = ({ label, children }) => {
  return <div className="tab-panel">{children}</div>;
};

// Usage
<Tabs activeTab={activeTab} onTabChange={setActiveTab}>
  <Tab label="Profile">
    <UserProfile user={user} />
  </Tab>
  <Tab label="Settings">
    <UserSettings user={user} />
  </Tab>
  <Tab label="Activity">
    <UserActivity user={user} />
  </Tab>
</Tabs>
```

#### 4. **Render Props Pattern**
```jsx
const DataFetcher = ({ url, children }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  // Pass state as arguments to children function
  return children({ data, loading, error });
};

// Usage - Same data fetcher, different UIs
<DataFetcher url="/api/users">
  {({ data, loading, error }) => {
    if (loading) return <LoadingSpinner />;
    if (error) return <ErrorAlert message={error} />;
    return <UserTable users={data} />;
  }}
</DataFetcher>

<DataFetcher url="/api/products">
  {({ data, loading, error }) => {
    if (loading) return <SkeletonGrid />;
    if (error) return <ErrorBanner error={error} />;
    return <ProductGrid products={data} />;
  }}
</DataFetcher>
```

## üîß Props Validation & TypeScript

### üõ°Ô∏è TypeScript Props Interfaces

```tsx
// ‚úÖ Comprehensive TypeScript props interface
interface UserCardProps {
  // Required props
  user: {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user' | 'moderator';
  };
  
  // Optional props with defaults
  showAvatar?: boolean;
  showActions?: boolean;
  size?: 'small' | 'medium' | 'large';
  theme?: 'light' | 'dark';
  
  // Function props
  onEdit?: (userId: string) => void;
  onDelete?: (userId: string) => void;
  onRoleChange?: (userId: string, newRole: string) => void;
  
  // Advanced props
  className?: string;
  children?: React.ReactNode;
  renderActions?: (user: UserCardProps['user']) => React.ReactNode;
}

const UserCard: React.FC<UserCardProps> = ({
  user,
  showAvatar = true,
  showActions = true,
  size = 'medium',
  theme = 'light',
  onEdit,
  onDelete,
  onRoleChange,
  className = '',
  children,
  renderActions
}) => {
  return (
    <div className={`user-card size-${size} theme-${theme} ${className}`}>
      {showAvatar && (
        <img 
          src={user.avatar || '/default-avatar.png'} 
          alt={user.name}
          className="avatar"
        />
      )}
      
      <div className="user-info">
        <h3>{user.name}</h3>
        <p>{user.email}</p>
        <span className="role">{user.role}</span>
      </div>
      
      {children}
      
      {showActions && (
        <div className="actions">
          {renderActions ? (
            renderActions(user)
          ) : (
            <>
              {onEdit && (
                <button onClick={() => onEdit(user.id)}>Edit</button>
              )}
              {onDelete && (
                <button onClick={() => onDelete(user.id)}>Delete</button>
              )}
              {onRoleChange && (
                <select
                  value={user.role}
                  onChange={(e) => onRoleChange(user.id, e.target.value)}
                >
                  <option value="user">User</option>
                  <option value="moderator">Moderator</option>
                  <option value="admin">Admin</option>
                </select>
              )}
            </>
          )}
        </div>
      )}
    </div>
  );
};
```

### üéØ Props Best Practices

#### 1. **Naming Conventions**
```jsx
// ‚úÖ Good prop names
<UserCard
  user={userData}           // Clear, descriptive
  showAvatar={true}         // Boolean prefix with 'is', 'has', 'show', 'can'
  onEdit={handleEdit}       // Event handlers with 'on' prefix
  className="custom-style"  // Standard HTML attributes
  theme="dark"             // Enum-like values
/>

// ‚ùå Bad prop names
<UserCard
  data={userData}          // Too generic
  avatar={true}            // Boolean without clear prefix
  edit={handleEdit}        // Missing 'on' prefix for handler
  class="custom-style"     // Use className, not class
  color="dark"             // Ambiguous, could be many things
/>
```

#### 2. **Default Props Strategies**
```jsx
// ‚úÖ Method 1: Default parameters (Modern, preferred)
const Button = ({ 
  variant = 'primary',
  size = 'medium',
  disabled = false,
  children,
  ...props 
}) => {
  return (
    <button 
      className={`btn btn-${variant} btn-${size}`}
      disabled={disabled}
      {...props}
    >
      {children}
    </button>
  );
};

// ‚úÖ Method 2: Object destructuring with defaults
const Card = (props) => {
  const {
    title,
    children,
    showHeader = true,
    showFooter = false,
    className = '',
    padding = 'medium'
  } = props;
  
  return (
    <div className={`card padding-${padding} ${className}`}>
      {showHeader && title && (
        <div className="card-header">
          <h3>{title}</h3>
        </div>
      )}
      
      <div className="card-body">
        {children}
      </div>
      
      {showFooter && (
        <div className="card-footer">
          {/* Footer content */}
        </div>
      )}
    </div>
  );
};

// ‚úÖ Method 3: Using defaultProps (Legacy, but still valid)
const OldStyleComponent = ({ title, size, theme }) => {
  return (
    <div className={`component size-${size} theme-${theme}`}>
      <h2>{title}</h2>
    </div>
  );
};

OldStyleComponent.defaultProps = {
  size: 'medium',
  theme: 'light',
  title: 'Default Title'
};
```

#### 3. **Props Optimization Patterns**
```jsx
// ‚úÖ Memoized callback props
const TodoList = ({ todos }) => {
  const [selectedTodos, setSelectedTodos] = useState([]);
  
  // Memoize handlers to prevent unnecessary re-renders
  const handleToggle = useCallback((id) => {
    setSelectedTodos(prev => 
      prev.includes(id) 
        ? prev.filter(todoId => todoId !== id)
        : [...prev, id]
    );
  }, []);
  
  const handleEdit = useCallback((id, newText) => {
    // Edit logic
  }, []);
  
  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          isSelected={selectedTodos.includes(todo.id)}
          onToggle={handleToggle}
          onEdit={handleEdit}
        />
      ))}
    </div>
  );
};

// ‚úÖ Memoized component to prevent unnecessary re-renders
const TodoItem = React.memo(({ 
  todo, 
  isSelected, 
  onToggle, 
  onEdit 
}) => {
  return (
    <div className={`todo-item ${isSelected ? 'selected' : ''}`}>
      <input
        type="checkbox"
        checked={isSelected}
        onChange={() => onToggle(todo.id)}
      />
      <span>{todo.text}</span>
      <button onClick={() => onEdit(todo.id)}>Edit</button>
    </div>
  );
});
```

Props are the foundation of React's component communication system. Master them, and you'll be able to build flexible, reusable, and maintainable component architectures!
    <div>
      <h3>{props.name}</h3>
      <p>Age: {props.age}</p>
      <p>Email: {props.email}</p>
    </div>
  );
}

// Use destructuring for cleaner code
function UserCard({ name, age, email }) {
  return (
    <div>
      <h3>{name}</h3>
      <p>Age: {age}</p>
      <p>Email: {email}</p>
    </div>
  );
}

// You can also destructure with default values
function Button({ text = "Click me", variant = "primary", disabled = false }) {
  return (
    <button className={`btn btn-${variant}`} disabled={disabled}>
      {text}
    </button>
  );
}
```

## Why Props Are Read-Only

Props enforce a **unidirectional data flow** which makes React applications predictable and easier to debug.

### What NOT to Do (Mutating Props)

```jsx
// ‚ùå NEVER DO THIS - Mutating props
function BadComponent(props) {
  props.name = "Modified Name";  // This will cause errors!
  props.items.push("new item");  // This modifies the parent's data!
  
  return <div>{props.name}</div>;
}
```

### What TO Do (Using State for Changes)

```jsx
import React, { useState } from 'react';

// ‚úÖ Correct approach - Use state for internal changes
function EditableProfile({ initialName, onNameChange }) {
  const [name, setName] = useState(initialName);
  const [isEditing, setIsEditing] = useState(false);

  const handleSave = () => {
    onNameChange(name);  // Communicate back to parent via callback
    setIsEditing(false);
  };

  if (isEditing) {
    return (
      <div>
        <input 
          value={name} 
          onChange={(e) => setName(e.target.value)} 
        />
        <button onClick={handleSave}>Save</button>
        <button onClick={() => setIsEditing(false)}>Cancel</button>
      </div>
    );
  }

  return (
    <div>
      <span>{name}</span>
      <button onClick={() => setIsEditing(true)}>Edit</button>
    </div>
  );
}
```

## Function Props (Callbacks)

Props can also be functions, allowing child components to communicate back to their parents.

### Event Handling Through Props

```jsx
function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <div className={`todo-item ${todo.completed ? 'completed' : ''}`}>
      <span 
        onClick={() => onToggle(todo.id)}
        style={{ 
          textDecoration: todo.completed ? 'line-through' : 'none',
          cursor: 'pointer'
        }}
      >
        {todo.text}
      </span>
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </div>
  );
}

function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: "Learn React", completed: false },
    { id: 2, text: "Build an app", completed: false }
  ]);

  const toggleTodo = (id) => {
    setTodos(todos.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div>
      {todos.map(todo => (
        <TodoItem 
          key={todo.id}
          todo={todo}
          onToggle={toggleTodo}
          onDelete={deleteTodo}
        />
      ))}
    </div>
  );
}
```

### Complex Callback Examples

```jsx
function ProductCard({ product, onAddToCart, onToggleFavorite, onViewDetails }) {
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      
      <div className="actions">
        <button 
          onClick={() => onAddToCart(product.id, 1)}
          disabled={!product.inStock}
        >
          {product.inStock ? 'Add to Cart' : 'Out of Stock'}
        </button>
        
        <button 
          onClick={() => onToggleFavorite(product.id)}
          className={product.isFavorite ? 'favorited' : ''}
        >
          ‚ô• {product.isFavorite ? 'Unfavorite' : 'Favorite'}
        </button>
        
        <button onClick={() => onViewDetails(product)}>
          View Details
        </button>
      </div>
    </div>
  );
}

// Usage
function ProductGrid({ products }) {
  const handleAddToCart = (productId, quantity) => {
    console.log(`Adding ${quantity} of product ${productId} to cart`);
    // Add to cart logic
  };

  const handleToggleFavorite = (productId) => {
    console.log(`Toggling favorite for product ${productId}`);
    // Toggle favorite logic
  };

  const handleViewDetails = (product) => {
    console.log(`Viewing details for`, product);
    // Navigation or modal logic
  };

  return (
    <div className="product-grid">
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={handleAddToCart}
          onToggleFavorite={handleToggleFavorite}
          onViewDetails={handleViewDetails}
        />
      ))}
    </div>
  );
}
```

## Typing Props with TypeScript

TypeScript brings **type safety** to props, catching errors at compile time and providing excellent developer experience with autocomplete and documentation.

### Basic Prop Types

```tsx
// Method 1: Type alias
type GreetingProps = {
  name: string;
  age: number;
  isStudent?: boolean;  // Optional prop
};

function Greeting(props: GreetingProps) {
  return (
    <div>
      <h1>Hello, {props.name}!</h1>
      <p>Age: {props.age}</p>
      {props.isStudent && <p>Student discount available!</p>}
    </div>
  );
}

// Method 2: Interface (preferred for object types)
interface UserProfileProps {
  name: string;
  email: string;
  age: number;
  avatar?: string;
  isOnline: boolean;
}

function UserProfile(props: UserProfileProps) {
  return (
    <div className="user-profile">
      <div className="avatar">
        {props.avatar ? (
          <img src={props.avatar} alt={props.name} />
        ) : (
          <div className="default-avatar">{props.name[0]}</div>
        )}
        <span className={`status ${props.isOnline ? 'online' : 'offline'}`} />
      </div>
      <h2>{props.name}</h2>
      <p>{props.email}</p>
      <p>Age: {props.age}</p>
    </div>
  );
}
```

### Destructuring with TypeScript

```tsx
// Destructuring in function parameters
function UserCard({ name, email, age, isOnline }: UserProfileProps) {
  return (
    <div className="user-card">
      <h3>{name}</h3>
      <p>{email}</p>
      <p>Age: {age}</p>
      <span className={isOnline ? 'online' : 'offline'}>
        {isOnline ? 'üü¢ Online' : 'üî¥ Offline'}
      </span>
    </div>
  );
}

// With default values
interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onClick?: () => void;
}

function Button({ 
  children, 
  variant = 'primary', 
  size = 'medium', 
  disabled = false,
  onClick 
}: ButtonProps) {
  return (
    <button 
      className={`btn btn-${variant} btn-${size}`}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
}
```

### Advanced Prop Types

```tsx
// Union types for specific values
interface AlertProps {
  message: string;
  type: 'success' | 'warning' | 'error' | 'info';
  dismissible?: boolean;
  onDismiss?: () => void;
}

// Function prop types
interface SearchProps {
  placeholder?: string;
  onSearch: (query: string) => void;
  onFilter?: (filters: { category: string; priceRange: [number, number] }) => void;
  debounceMs?: number;
}

// Array and object prop types
interface BlogPostProps {
  post: {
    id: string;
    title: string;
    content: string;
    author: {
      name: string;
      avatar: string;
    };
    tags: string[];
    publishedAt: Date;
    stats: {
      views: number;
      likes: number;
      comments: number;
    };
  };
  onLike: (postId: string) => Promise<void>;
  onShare: (postId: string, platform: 'twitter' | 'facebook' | 'linkedin') => void;
}

function BlogPost({ post, onLike, onShare }: BlogPostProps) {
  const [isLiking, setIsLiking] = useState(false);

  const handleLike = async () => {
    setIsLiking(true);
    try {
      await onLike(post.id);
    } finally {
      setIsLiking(false);
    }
  };

  return (
    <article className="blog-post">
      <header>
        <h1>{post.title}</h1>
        <div className="author">
          <img src={post.author.avatar} alt={post.author.name} />
          <span>{post.author.name}</span>
          <time>{post.publishedAt.toLocaleDateString()}</time>
        </div>
      </header>
      
      <div className="content">
        {post.content}
      </div>
      
      <div className="tags">
        {post.tags.map(tag => (
          <span key={tag} className="tag">#{tag}</span>
        ))}
      </div>
      
      <footer className="stats">
        <span>{post.stats.views} views</span>
        <button onClick={handleLike} disabled={isLiking}>
          ‚ô• {post.stats.likes} {isLiking ? 'liking...' : 'likes'}
        </button>
        <span>{post.stats.comments} comments</span>
        
        <div className="share-buttons">
          <button onClick={() => onShare(post.id, 'twitter')}>Share on Twitter</button>
          <button onClick={() => onShare(post.id, 'facebook')}>Share on Facebook</button>
          <button onClick={() => onShare(post.id, 'linkedin')}>Share on LinkedIn</button>
        </div>
      </footer>
    </article>
  );
}
```

## Typing the children Prop

The `children` prop is special in React - it represents content passed between component tags. TypeScript provides `React.ReactNode` for typing this.

### Understanding React.ReactNode

```tsx
// React.ReactNode includes:
// - JSX elements
// - strings
// - numbers
// - arrays of the above
// - null/undefined
// - boolean (rendered as nothing)

type CardProps = {
  title?: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
};

function Card({ title, children, footer }: CardProps) {
  return (
    <div className="card">
      {title && (
        <div className="card-header">
          <h3>{title}</h3>
        </div>
      )}
      
      <div className="card-body">
        {children}
      </div>
      
      {footer && (
        <div className="card-footer">
          {footer}
        </div>
      )}
    </div>
  );
}
```

### Children Usage Examples

```tsx
// Example 1: Simple text children
<Card title="Welcome">
  <p>This is a simple card with text content.</p>
</Card>

// Example 2: Complex JSX children
<Card title="User Profile">
  <div className="profile-info">
    <img src="/avatar.jpg" alt="User" />
    <h4>John Doe</h4>
    <p>Software Engineer</p>
    <div className="skills">
      <span className="skill">React</span>
      <span className="skill">TypeScript</span>
      <span className="skill">Node.js</span>
    </div>
  </div>
</Card>

// Example 3: Multiple children elements
<Card 
  title="Product Details"
  footer={
    <div>
      <button>Add to Cart</button>
      <button>Add to Wishlist</button>
    </div>
  }
>
  <img src="/product.jpg" alt="Product" />
  <h4>Awesome Product</h4>
  <p>This is an amazing product description.</p>
  <div className="price">$99.99</div>
</Card>
```

### Advanced Children Patterns

```tsx
// 1. Children as render props
interface RenderPropCardProps {
  title: string;
  children: (data: { isExpanded: boolean; toggle: () => void }) => React.ReactNode;
}

function ExpandableCard({ title, children }: RenderPropCardProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  
  const toggle = () => setIsExpanded(!isExpanded);
  
  return (
    <div className="expandable-card">
      <div className="card-header" onClick={toggle}>
        <h3>{title}</h3>
        <span>{isExpanded ? '‚ñº' : '‚ñ∂'}</span>
      </div>
      
      {isExpanded && (
        <div className="card-body">
          {children({ isExpanded, toggle })}
        </div>
      )}
    </div>
  );
}

// Usage
<ExpandableCard title="Advanced Settings">
  {({ isExpanded, toggle }) => (
    <div>
      <p>These settings are currently {isExpanded ? 'visible' : 'hidden'}</p>
      <button onClick={toggle}>Toggle Visibility</button>
      <div className="settings">
        {/* Settings content */}
      </div>
    </div>
  )}
</ExpandableCard>

// 2. Restricting children types
interface TabsProps {
  children: React.ReactElement<TabProps> | React.ReactElement<TabProps>[];
  activeTab?: string;
  onTabChange?: (tabId: string) => void;
}

interface TabProps {
  id: string;
  label: string;
  children: React.ReactNode;
  disabled?: boolean;
}

function Tabs({ children, activeTab, onTabChange }: TabsProps) {
  const [activeTabId, setActiveTabId] = useState(activeTab || '');
  
  const tabs = React.Children.toArray(children) as React.ReactElement<TabProps>[];
  
  const handleTabClick = (tabId: string) => {
    setActiveTabId(tabId);
    onTabChange?.(tabId);
  };
  
  const activeTabContent = tabs.find(tab => tab.props.id === activeTabId);
  
  return (
    <div className="tabs">
      <div className="tab-headers">
        {tabs.map(tab => (
          <button
            key={tab.props.id}
            className={`tab-header ${tab.props.id === activeTabId ? 'active' : ''}`}
            onClick={() => handleTabClick(tab.props.id)}
            disabled={tab.props.disabled}
          >
            {tab.props.label}
          </button>
        ))}
      </div>
      
      <div className="tab-content">
        {activeTabContent?.props.children}
      </div>
    </div>
  );
}

function Tab({ children }: TabProps) {
  return <>{children}</>;
}

// Usage
<Tabs activeTab="profile" onTabChange={(tab) => console.log(`Switched to ${tab}`)}>
  <Tab id="profile" label="Profile">
    <div>Profile content here</div>
  </Tab>
  <Tab id="settings" label="Settings">
    <div>Settings content here</div>
  </Tab>
  <Tab id="billing" label="Billing" disabled>
    <div>Billing content here</div>
  </Tab>
</Tabs>
```

### Children Manipulation Utilities

```tsx
import React from 'react';

interface ListProps {
  children: React.ReactNode;
  separator?: React.ReactNode;
}

function List({ children, separator = ', ' }: ListProps) {
  const childArray = React.Children.toArray(children);
  
  return (
    <div>
      {childArray.map((child, index) => (
        <React.Fragment key={index}>
          {child}
          {index < childArray.length - 1 && separator}
        </React.Fragment>
      ))}
    </div>
  );
}

// Usage
<List separator=" | ">
  <span>Home</span>
  <span>About</span>
  <span>Contact</span>
</List>
// Renders: Home | About | Contact

// Count and filter children
interface ConditionalWrapperProps {
  condition: boolean;
  wrapper: (children: React.ReactNode) => React.ReactNode;
  children: React.ReactNode;
}

function ConditionalWrapper({ condition, wrapper, children }: ConditionalWrapperProps) {
  return condition ? <>{wrapper(children)}</> : <>{children}</>;
}

// Usage
<ConditionalWrapper
  condition={user.isAdmin}
  wrapper={(children) => <div className="admin-panel">{children}</div>}
>
  <button>Regular Content</button>
</ConditionalWrapper>
```

## Props vs State

Understanding when to use props vs state is crucial:

### Props: External Configuration

```tsx
// Props are for data that comes from parent components
interface WeatherWidgetProps {
  city: string;          // Configuration from parent
  units: 'celsius' | 'fahrenheit';  // User preference from parent
  onCityChange: (city: string) => void;  // Callback to parent
}

function WeatherWidget({ city, units, onCityChange }: WeatherWidgetProps) {
  // State is for internal component behavior
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Props tell us WHAT to do, state tracks HOW we're doing it
  useEffect(() => {
    fetchWeather(city, units);
  }, [city, units]);  // Re-fetch when props change
  
  return (
    <div className="weather-widget">
      <h3>Weather in {city}</h3>
      {loading && <p>Loading...</p>}
      {error && <p>Error: {error}</p>}
      {weather && (
        <div>
          <p>Temperature: {weather.temperature}¬∞{units === 'celsius' ? 'C' : 'F'}</p>
          <p>Condition: {weather.condition}</p>
        </div>
      )}
      <button onClick={() => onCityChange('New York')}>
        Switch to New York
      </button>
    </div>
  );
}
```

## Common Props Patterns and Best Practices

### 1. Spreading Props

```tsx
interface BaseButtonProps {
  variant?: 'primary' | 'secondary';
  size?: 'small' | medium' | 'large';
}

interface ButtonProps extends BaseButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  // Accept any additional HTML button attributes
  [key: string]: any;
}

function Button({ variant = 'primary', size = 'medium', children, ...otherProps }: ButtonProps) {
  return (
    <button 
      className={`btn btn-${variant} btn-${size}`}
      {...otherProps}  // Spread remaining props
    >
      {children}
    </button>
  );
}

// Usage - any HTML button attribute works
<Button 
  variant="primary" 
  onClick={() => alert('Clicked!')}
  disabled={true}
  title="This is a tooltip"
  data-testid="submit-button"
  style={{ marginTop: '10px' }}
>
  Submit
</Button>
```

### 2. Compound Components

```tsx
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

interface ModalHeaderProps {
  children: React.ReactNode;
}

interface ModalBodyProps {
  children: React.ReactNode;
}

interface ModalFooterProps {
  children: React.ReactNode;
}

function Modal({ isOpen, onClose, children }: ModalProps) {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={(e) => e.stopPropagation()}>
        {children}
      </div>
    </div>
  );
}

function ModalHeader({ children }: ModalHeaderProps) {
  return <div className="modal-header">{children}</div>;
}

function ModalBody({ children }: ModalBodyProps) {
  return <div className="modal-body">{children}</div>;
}

function ModalFooter({ children }: ModalFooterProps) {
  return <div className="modal-footer">{children}</div>;
}

// Attach sub-components to main component
Modal.Header = ModalHeader;
Modal.Body = ModalBody;
Modal.Footer = ModalFooter;

// Usage
<Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}>
  <Modal.Header>
    <h2>Confirm Action</h2>
  </Modal.Header>
  
  <Modal.Body>
    <p>Are you sure you want to delete this item?</p>
  </Modal.Body>
  
  <Modal.Footer>
    <Button variant="secondary" onClick={() => setIsModalOpen(false)}>
      Cancel
    </Button>
    <Button variant="danger" onClick={handleDelete}>
      Delete
    </Button>
  </Modal.Footer>
</Modal>
```

### 3. Props Validation with Runtime Checks

```tsx
// Using runtime validation for critical props
interface CriticalComponentProps {
  userId: string;
  permissions: string[];
  onAction: (action: string) => void;
}

function CriticalComponent({ userId, permissions, onAction }: CriticalComponentProps) {
  // Runtime validation for critical business logic
  if (!userId || userId.trim() === '') {
    throw new Error('CriticalComponent: userId is required and cannot be empty');
  }
  
  if (!permissions || permissions.length === 0) {
    console.warn('CriticalComponent: No permissions provided, component may not function correctly');
  }
  
  if (typeof onAction !== 'function') {
    throw new Error('CriticalComponent: onAction must be a function');
  }
  
  return (
    <div>
      {/* Component implementation */}
    </div>
  );
}
```

## Summary

Props are fundamental to React development:

### Key Takeaways:

1. **Props are read-only**: Never mutate props directly
2. **Use TypeScript**: Always type your props for better development experience
3. **Destructure for clarity**: Makes code more readable and maintainable
4. **Children are special**: Use `React.ReactNode` for maximum flexibility
5. **Function props enable communication**: Allow child-to-parent communication
6. **Composition over inheritance**: Use props and children for flexible component design

### TypeScript Benefits:
- **Compile-time safety**: Catch prop-related errors before runtime
- **Excellent IntelliSense**: Autocomplete and documentation
- **Refactoring confidence**: Safe to rename and restructure
- **Self-documenting code**: Props interface serves as documentation

### Next Steps:
- Learn about **React Hooks** for state management
- Explore **Context API** for prop drilling solutions
- Understand **component composition patterns**
- Practice **custom hook creation** for reusable logic

Props are the foundation of component communication in React. Master them, and you'll be well on your way to building maintainable, type-safe React applications!