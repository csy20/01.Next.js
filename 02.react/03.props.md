# React Props: Passing Data Between Components

## Introduction to Props

Props (short for "properties") are the mechanism for passing data from parent components to child components in React. Think of props as **function parameters for React components** - they allow you to customize and configure how a component behaves and what it displays.

### The Fundamental Concept

```jsx
// Just like a regular function takes parameters...
function greetUser(name, age) {
  return `Hello ${name}, you are ${age} years old!`;
}

// React components take props
function UserGreeting(props) {
  return <h1>Hello {props.name}, you are {props.age} years old!</h1>;
}
```

### Key Properties of Props

1. **Read-only**: Props cannot be modified by the receiving component
2. **Unidirectional**: Data flows from parent to child only
3. **Immutable**: Props should never be mutated directly
4. **Customizable**: Allow the same component to display different data

## Basic Props Usage

### Simple Example

```jsx
// Child Component
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

// Parent Component
function App() {
  return (
    <div>
      <Welcome name="Alice" />
      <Welcome name="Bob" />
      <Welcome name="Charlie" />
    </div>
  );
}

// Output:
// Hello, Alice!
// Hello, Bob!
// Hello, Charlie!
```

### Props with Different Data Types

```jsx
function UserProfile(props) {
  return (
    <div className="user-profile">
      <h2>{props.name}</h2>                     {/* String */}
      <p>Age: {props.age}</p>                   {/* Number */}
      <p>Active: {props.isActive ? 'Yes' : 'No'}</p>  {/* Boolean */}
      <p>Hobbies: {props.hobbies.join(', ')}</p>      {/* Array */}
      <p>Location: {props.address.city}, {props.address.country}</p>  {/* Object */}
    </div>
  );
}

// Usage
function App() {
  const user = {
    name: "John Doe",
    age: 30,
    isActive: true,
    hobbies: ["reading", "coding", "gaming"],
    address: {
      city: "New York",
      country: "USA"
    }
  };

  return (
    <UserProfile 
      name={user.name}
      age={user.age}
      isActive={user.isActive}
      hobbies={user.hobbies}
      address={user.address}
    />
  );
}
```

### Props Destructuring for Cleaner Code

```jsx
// Instead of accessing props.name, props.age, etc.
function UserCard(props) {
  return (
    <div>
      <h3>{props.name}</h3>
      <p>Age: {props.age}</p>
      <p>Email: {props.email}</p>
    </div>
  );
}

// Use destructuring for cleaner code
function UserCard({ name, age, email }) {
  return (
    <div>
      <h3>{name}</h3>
      <p>Age: {age}</p>
      <p>Email: {email}</p>
    </div>
  );
}

// You can also destructure with default values
function Button({ text = "Click me", variant = "primary", disabled = false }) {
  return (
    <button className={`btn btn-${variant}`} disabled={disabled}>
      {text}
    </button>
  );
}
```

## Why Props Are Read-Only

Props enforce a **unidirectional data flow** which makes React applications predictable and easier to debug.

### What NOT to Do (Mutating Props)

```jsx
// ‚ùå NEVER DO THIS - Mutating props
function BadComponent(props) {
  props.name = "Modified Name";  // This will cause errors!
  props.items.push("new item");  // This modifies the parent's data!
  
  return <div>{props.name}</div>;
}
```

### What TO Do (Using State for Changes)

```jsx
import React, { useState } from 'react';

// ‚úÖ Correct approach - Use state for internal changes
function EditableProfile({ initialName, onNameChange }) {
  const [name, setName] = useState(initialName);
  const [isEditing, setIsEditing] = useState(false);

  const handleSave = () => {
    onNameChange(name);  // Communicate back to parent via callback
    setIsEditing(false);
  };

  if (isEditing) {
    return (
      <div>
        <input 
          value={name} 
          onChange={(e) => setName(e.target.value)} 
        />
        <button onClick={handleSave}>Save</button>
        <button onClick={() => setIsEditing(false)}>Cancel</button>
      </div>
    );
  }

  return (
    <div>
      <span>{name}</span>
      <button onClick={() => setIsEditing(true)}>Edit</button>
    </div>
  );
}
```

## Function Props (Callbacks)

Props can also be functions, allowing child components to communicate back to their parents.

### Event Handling Through Props

```jsx
function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <div className={`todo-item ${todo.completed ? 'completed' : ''}`}>
      <span 
        onClick={() => onToggle(todo.id)}
        style={{ 
          textDecoration: todo.completed ? 'line-through' : 'none',
          cursor: 'pointer'
        }}
      >
        {todo.text}
      </span>
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </div>
  );
}

function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: "Learn React", completed: false },
    { id: 2, text: "Build an app", completed: false }
  ]);

  const toggleTodo = (id) => {
    setTodos(todos.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div>
      {todos.map(todo => (
        <TodoItem 
          key={todo.id}
          todo={todo}
          onToggle={toggleTodo}
          onDelete={deleteTodo}
        />
      ))}
    </div>
  );
}
```

### Complex Callback Examples

```jsx
function ProductCard({ product, onAddToCart, onToggleFavorite, onViewDetails }) {
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      
      <div className="actions">
        <button 
          onClick={() => onAddToCart(product.id, 1)}
          disabled={!product.inStock}
        >
          {product.inStock ? 'Add to Cart' : 'Out of Stock'}
        </button>
        
        <button 
          onClick={() => onToggleFavorite(product.id)}
          className={product.isFavorite ? 'favorited' : ''}
        >
          ‚ô• {product.isFavorite ? 'Unfavorite' : 'Favorite'}
        </button>
        
        <button onClick={() => onViewDetails(product)}>
          View Details
        </button>
      </div>
    </div>
  );
}

// Usage
function ProductGrid({ products }) {
  const handleAddToCart = (productId, quantity) => {
    console.log(`Adding ${quantity} of product ${productId} to cart`);
    // Add to cart logic
  };

  const handleToggleFavorite = (productId) => {
    console.log(`Toggling favorite for product ${productId}`);
    // Toggle favorite logic
  };

  const handleViewDetails = (product) => {
    console.log(`Viewing details for`, product);
    // Navigation or modal logic
  };

  return (
    <div className="product-grid">
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={handleAddToCart}
          onToggleFavorite={handleToggleFavorite}
          onViewDetails={handleViewDetails}
        />
      ))}
    </div>
  );
}
```

## Typing Props with TypeScript

TypeScript brings **type safety** to props, catching errors at compile time and providing excellent developer experience with autocomplete and documentation.

### Basic Prop Types

```tsx
// Method 1: Type alias
type GreetingProps = {
  name: string;
  age: number;
  isStudent?: boolean;  // Optional prop
};

function Greeting(props: GreetingProps) {
  return (
    <div>
      <h1>Hello, {props.name}!</h1>
      <p>Age: {props.age}</p>
      {props.isStudent && <p>Student discount available!</p>}
    </div>
  );
}

// Method 2: Interface (preferred for object types)
interface UserProfileProps {
  name: string;
  email: string;
  age: number;
  avatar?: string;
  isOnline: boolean;
}

function UserProfile(props: UserProfileProps) {
  return (
    <div className="user-profile">
      <div className="avatar">
        {props.avatar ? (
          <img src={props.avatar} alt={props.name} />
        ) : (
          <div className="default-avatar">{props.name[0]}</div>
        )}
        <span className={`status ${props.isOnline ? 'online' : 'offline'}`} />
      </div>
      <h2>{props.name}</h2>
      <p>{props.email}</p>
      <p>Age: {props.age}</p>
    </div>
  );
}
```

### Destructuring with TypeScript

```tsx
// Destructuring in function parameters
function UserCard({ name, email, age, isOnline }: UserProfileProps) {
  return (
    <div className="user-card">
      <h3>{name}</h3>
      <p>{email}</p>
      <p>Age: {age}</p>
      <span className={isOnline ? 'online' : 'offline'}>
        {isOnline ? 'üü¢ Online' : 'üî¥ Offline'}
      </span>
    </div>
  );
}

// With default values
interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onClick?: () => void;
}

function Button({ 
  children, 
  variant = 'primary', 
  size = 'medium', 
  disabled = false,
  onClick 
}: ButtonProps) {
  return (
    <button 
      className={`btn btn-${variant} btn-${size}`}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
}
```

### Advanced Prop Types

```tsx
// Union types for specific values
interface AlertProps {
  message: string;
  type: 'success' | 'warning' | 'error' | 'info';
  dismissible?: boolean;
  onDismiss?: () => void;
}

// Function prop types
interface SearchProps {
  placeholder?: string;
  onSearch: (query: string) => void;
  onFilter?: (filters: { category: string; priceRange: [number, number] }) => void;
  debounceMs?: number;
}

// Array and object prop types
interface BlogPostProps {
  post: {
    id: string;
    title: string;
    content: string;
    author: {
      name: string;
      avatar: string;
    };
    tags: string[];
    publishedAt: Date;
    stats: {
      views: number;
      likes: number;
      comments: number;
    };
  };
  onLike: (postId: string) => Promise<void>;
  onShare: (postId: string, platform: 'twitter' | 'facebook' | 'linkedin') => void;
}

function BlogPost({ post, onLike, onShare }: BlogPostProps) {
  const [isLiking, setIsLiking] = useState(false);

  const handleLike = async () => {
    setIsLiking(true);
    try {
      await onLike(post.id);
    } finally {
      setIsLiking(false);
    }
  };

  return (
    <article className="blog-post">
      <header>
        <h1>{post.title}</h1>
        <div className="author">
          <img src={post.author.avatar} alt={post.author.name} />
          <span>{post.author.name}</span>
          <time>{post.publishedAt.toLocaleDateString()}</time>
        </div>
      </header>
      
      <div className="content">
        {post.content}
      </div>
      
      <div className="tags">
        {post.tags.map(tag => (
          <span key={tag} className="tag">#{tag}</span>
        ))}
      </div>
      
      <footer className="stats">
        <span>{post.stats.views} views</span>
        <button onClick={handleLike} disabled={isLiking}>
          ‚ô• {post.stats.likes} {isLiking ? 'liking...' : 'likes'}
        </button>
        <span>{post.stats.comments} comments</span>
        
        <div className="share-buttons">
          <button onClick={() => onShare(post.id, 'twitter')}>Share on Twitter</button>
          <button onClick={() => onShare(post.id, 'facebook')}>Share on Facebook</button>
          <button onClick={() => onShare(post.id, 'linkedin')}>Share on LinkedIn</button>
        </div>
      </footer>
    </article>
  );
}
```

## Typing the children Prop

The `children` prop is special in React - it represents content passed between component tags. TypeScript provides `React.ReactNode` for typing this.

### Understanding React.ReactNode

```tsx
// React.ReactNode includes:
// - JSX elements
// - strings
// - numbers
// - arrays of the above
// - null/undefined
// - boolean (rendered as nothing)

type CardProps = {
  title?: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
};

function Card({ title, children, footer }: CardProps) {
  return (
    <div className="card">
      {title && (
        <div className="card-header">
          <h3>{title}</h3>
        </div>
      )}
      
      <div className="card-body">
        {children}
      </div>
      
      {footer && (
        <div className="card-footer">
          {footer}
        </div>
      )}
    </div>
  );
}
```

### Children Usage Examples

```tsx
// Example 1: Simple text children
<Card title="Welcome">
  <p>This is a simple card with text content.</p>
</Card>

// Example 2: Complex JSX children
<Card title="User Profile">
  <div className="profile-info">
    <img src="/avatar.jpg" alt="User" />
    <h4>John Doe</h4>
    <p>Software Engineer</p>
    <div className="skills">
      <span className="skill">React</span>
      <span className="skill">TypeScript</span>
      <span className="skill">Node.js</span>
    </div>
  </div>
</Card>

// Example 3: Multiple children elements
<Card 
  title="Product Details"
  footer={
    <div>
      <button>Add to Cart</button>
      <button>Add to Wishlist</button>
    </div>
  }
>
  <img src="/product.jpg" alt="Product" />
  <h4>Awesome Product</h4>
  <p>This is an amazing product description.</p>
  <div className="price">$99.99</div>
</Card>
```

### Advanced Children Patterns

```tsx
// 1. Children as render props
interface RenderPropCardProps {
  title: string;
  children: (data: { isExpanded: boolean; toggle: () => void }) => React.ReactNode;
}

function ExpandableCard({ title, children }: RenderPropCardProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  
  const toggle = () => setIsExpanded(!isExpanded);
  
  return (
    <div className="expandable-card">
      <div className="card-header" onClick={toggle}>
        <h3>{title}</h3>
        <span>{isExpanded ? '‚ñº' : '‚ñ∂'}</span>
      </div>
      
      {isExpanded && (
        <div className="card-body">
          {children({ isExpanded, toggle })}
        </div>
      )}
    </div>
  );
}

// Usage
<ExpandableCard title="Advanced Settings">
  {({ isExpanded, toggle }) => (
    <div>
      <p>These settings are currently {isExpanded ? 'visible' : 'hidden'}</p>
      <button onClick={toggle}>Toggle Visibility</button>
      <div className="settings">
        {/* Settings content */}
      </div>
    </div>
  )}
</ExpandableCard>

// 2. Restricting children types
interface TabsProps {
  children: React.ReactElement<TabProps> | React.ReactElement<TabProps>[];
  activeTab?: string;
  onTabChange?: (tabId: string) => void;
}

interface TabProps {
  id: string;
  label: string;
  children: React.ReactNode;
  disabled?: boolean;
}

function Tabs({ children, activeTab, onTabChange }: TabsProps) {
  const [activeTabId, setActiveTabId] = useState(activeTab || '');
  
  const tabs = React.Children.toArray(children) as React.ReactElement<TabProps>[];
  
  const handleTabClick = (tabId: string) => {
    setActiveTabId(tabId);
    onTabChange?.(tabId);
  };
  
  const activeTabContent = tabs.find(tab => tab.props.id === activeTabId);
  
  return (
    <div className="tabs">
      <div className="tab-headers">
        {tabs.map(tab => (
          <button
            key={tab.props.id}
            className={`tab-header ${tab.props.id === activeTabId ? 'active' : ''}`}
            onClick={() => handleTabClick(tab.props.id)}
            disabled={tab.props.disabled}
          >
            {tab.props.label}
          </button>
        ))}
      </div>
      
      <div className="tab-content">
        {activeTabContent?.props.children}
      </div>
    </div>
  );
}

function Tab({ children }: TabProps) {
  return <>{children}</>;
}

// Usage
<Tabs activeTab="profile" onTabChange={(tab) => console.log(`Switched to ${tab}`)}>
  <Tab id="profile" label="Profile">
    <div>Profile content here</div>
  </Tab>
  <Tab id="settings" label="Settings">
    <div>Settings content here</div>
  </Tab>
  <Tab id="billing" label="Billing" disabled>
    <div>Billing content here</div>
  </Tab>
</Tabs>
```

### Children Manipulation Utilities

```tsx
import React from 'react';

interface ListProps {
  children: React.ReactNode;
  separator?: React.ReactNode;
}

function List({ children, separator = ', ' }: ListProps) {
  const childArray = React.Children.toArray(children);
  
  return (
    <div>
      {childArray.map((child, index) => (
        <React.Fragment key={index}>
          {child}
          {index < childArray.length - 1 && separator}
        </React.Fragment>
      ))}
    </div>
  );
}

// Usage
<List separator=" | ">
  <span>Home</span>
  <span>About</span>
  <span>Contact</span>
</List>
// Renders: Home | About | Contact

// Count and filter children
interface ConditionalWrapperProps {
  condition: boolean;
  wrapper: (children: React.ReactNode) => React.ReactNode;
  children: React.ReactNode;
}

function ConditionalWrapper({ condition, wrapper, children }: ConditionalWrapperProps) {
  return condition ? <>{wrapper(children)}</> : <>{children}</>;
}

// Usage
<ConditionalWrapper
  condition={user.isAdmin}
  wrapper={(children) => <div className="admin-panel">{children}</div>}
>
  <button>Regular Content</button>
</ConditionalWrapper>
```

## Props vs State

Understanding when to use props vs state is crucial:

### Props: External Configuration

```tsx
// Props are for data that comes from parent components
interface WeatherWidgetProps {
  city: string;          // Configuration from parent
  units: 'celsius' | 'fahrenheit';  // User preference from parent
  onCityChange: (city: string) => void;  // Callback to parent
}

function WeatherWidget({ city, units, onCityChange }: WeatherWidgetProps) {
  // State is for internal component behavior
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Props tell us WHAT to do, state tracks HOW we're doing it
  useEffect(() => {
    fetchWeather(city, units);
  }, [city, units]);  // Re-fetch when props change
  
  return (
    <div className="weather-widget">
      <h3>Weather in {city}</h3>
      {loading && <p>Loading...</p>}
      {error && <p>Error: {error}</p>}
      {weather && (
        <div>
          <p>Temperature: {weather.temperature}¬∞{units === 'celsius' ? 'C' : 'F'}</p>
          <p>Condition: {weather.condition}</p>
        </div>
      )}
      <button onClick={() => onCityChange('New York')}>
        Switch to New York
      </button>
    </div>
  );
}
```

## Common Props Patterns and Best Practices

### 1. Spreading Props

```tsx
interface BaseButtonProps {
  variant?: 'primary' | 'secondary';
  size?: 'small' | medium' | 'large';
}

interface ButtonProps extends BaseButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  // Accept any additional HTML button attributes
  [key: string]: any;
}

function Button({ variant = 'primary', size = 'medium', children, ...otherProps }: ButtonProps) {
  return (
    <button 
      className={`btn btn-${variant} btn-${size}`}
      {...otherProps}  // Spread remaining props
    >
      {children}
    </button>
  );
}

// Usage - any HTML button attribute works
<Button 
  variant="primary" 
  onClick={() => alert('Clicked!')}
  disabled={true}
  title="This is a tooltip"
  data-testid="submit-button"
  style={{ marginTop: '10px' }}
>
  Submit
</Button>
```

### 2. Compound Components

```tsx
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

interface ModalHeaderProps {
  children: React.ReactNode;
}

interface ModalBodyProps {
  children: React.ReactNode;
}

interface ModalFooterProps {
  children: React.ReactNode;
}

function Modal({ isOpen, onClose, children }: ModalProps) {
  if (!isOpen) return null;
  
  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={(e) => e.stopPropagation()}>
        {children}
      </div>
    </div>
  );
}

function ModalHeader({ children }: ModalHeaderProps) {
  return <div className="modal-header">{children}</div>;
}

function ModalBody({ children }: ModalBodyProps) {
  return <div className="modal-body">{children}</div>;
}

function ModalFooter({ children }: ModalFooterProps) {
  return <div className="modal-footer">{children}</div>;
}

// Attach sub-components to main component
Modal.Header = ModalHeader;
Modal.Body = ModalBody;
Modal.Footer = ModalFooter;

// Usage
<Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}>
  <Modal.Header>
    <h2>Confirm Action</h2>
  </Modal.Header>
  
  <Modal.Body>
    <p>Are you sure you want to delete this item?</p>
  </Modal.Body>
  
  <Modal.Footer>
    <Button variant="secondary" onClick={() => setIsModalOpen(false)}>
      Cancel
    </Button>
    <Button variant="danger" onClick={handleDelete}>
      Delete
    </Button>
  </Modal.Footer>
</Modal>
```

### 3. Props Validation with Runtime Checks

```tsx
// Using runtime validation for critical props
interface CriticalComponentProps {
  userId: string;
  permissions: string[];
  onAction: (action: string) => void;
}

function CriticalComponent({ userId, permissions, onAction }: CriticalComponentProps) {
  // Runtime validation for critical business logic
  if (!userId || userId.trim() === '') {
    throw new Error('CriticalComponent: userId is required and cannot be empty');
  }
  
  if (!permissions || permissions.length === 0) {
    console.warn('CriticalComponent: No permissions provided, component may not function correctly');
  }
  
  if (typeof onAction !== 'function') {
    throw new Error('CriticalComponent: onAction must be a function');
  }
  
  return (
    <div>
      {/* Component implementation */}
    </div>
  );
}
```

## Summary

Props are fundamental to React development:

### Key Takeaways:

1. **Props are read-only**: Never mutate props directly
2. **Use TypeScript**: Always type your props for better development experience
3. **Destructure for clarity**: Makes code more readable and maintainable
4. **Children are special**: Use `React.ReactNode` for maximum flexibility
5. **Function props enable communication**: Allow child-to-parent communication
6. **Composition over inheritance**: Use props and children for flexible component design

### TypeScript Benefits:
- **Compile-time safety**: Catch prop-related errors before runtime
- **Excellent IntelliSense**: Autocomplete and documentation
- **Refactoring confidence**: Safe to rename and restructure
- **Self-documenting code**: Props interface serves as documentation

### Next Steps:
- Learn about **React Hooks** for state management
- Explore **Context API** for prop drilling solutions
- Understand **component composition patterns**
- Practice **custom hook creation** for reusable logic

Props are the foundation of component communication in React. Master them, and you'll be well on your way to building maintainable, type-safe React applications!