# JavaScript - The Programming Language of the Web

## Understanding JavaScript from First Principles

JavaScript is the **programming language** that makes websites interactive and dynamic. To understand JavaScript from the ground up:

### What JavaScript Actually Does

JavaScript is an **interpreted programming language** that runs in browsers (and now servers). It's the only programming language that browsers natively understand for client-side scripting.

**Core Capabilities:**
- **Manipulate HTML and CSS** - Change content and styles dynamically
- **Respond to user events** - Handle clicks, typing, mouse movements
- **Make network requests** - Fetch data from servers without page reloads
- **Store data locally** - Remember user preferences and data
- **Perform calculations** - Process data and business logic
- **Control program flow** - Make decisions and repeat actions

### JavaScript's Role in the Web Ecosystem

```
Traditional Web (Static):
HTML → Browser → Display

Modern Web (Dynamic):
HTML + CSS + JavaScript → Browser → Interactive Experience
                    ↓
              User Interactions → JavaScript → Update Display
                    ↓
              Network Requests → Server → Data → JavaScript → Update Display
```

### How JavaScript Executes (The Engine)

When you write JavaScript, here's what happens:

1. **Parse**: Browser reads your JavaScript code
2. **Compile**: Code is compiled to bytecode (or optimized machine code)
3. **Execute**: Code runs line by line (single-threaded)
4. **Event Loop**: Handles asynchronous operations (setTimeout, fetch, etc.)

```javascript
// Your code:
console.log("First");
setTimeout(() => console.log("Third"), 0);
console.log("Second");

// Output:
// First
// Second  
// Third (comes later due to event loop)
```

This understanding helps explain why JavaScript behaves the way it does.

## JavaScript Fundamentals - Building Blocks

### Variables - Memory Storage Containers

Variables are **named containers** that store data in memory. Understanding variable scope and lifetime is crucial.

#### Variable Declaration Types
```javascript
// var - Function-scoped, hoisted, can be redeclared (avoid in modern JS)
var oldVariable = "I'm function-scoped";

// let - Block-scoped, not hoisted, can be reassigned
let changeable = "I can be changed";
changeable = "New value"; // ✅ Works

// const - Block-scoped, not hoisted, cannot be reassigned
const permanent = "I cannot be reassigned";
// permanent = "New value"; // ❌ TypeError

// const with objects/arrays (reference is constant, not content)
const user = { name: "John", age: 25 };
user.age = 26; // ✅ Works - modifying content
user.email = "john@example.com"; // ✅ Works - adding property
// user = {}; // ❌ TypeError - cannot reassign reference

const colors = ["red", "green"];
colors.push("blue"); // ✅ Works - modifying array
// colors = []; // ❌ TypeError - cannot reassign reference
```

#### Variable Scope - Understanding Accessibility
```javascript
// Global scope - accessible everywhere
const globalVar = "I'm accessible everywhere";

function outerFunction() {
    // Function scope - accessible within this function
    const functionVar = "I'm accessible in this function";
    
    if (true) {
        // Block scope - accessible within this block
        const blockVar = "I'm only accessible in this block";
        let anotherBlockVar = "Me too!";
        
        console.log(globalVar);     // ✅ Works
        console.log(functionVar);   // ✅ Works
        console.log(blockVar);      // ✅ Works
    }
    
    console.log(globalVar);     // ✅ Works
    console.log(functionVar);   // ✅ Works
    // console.log(blockVar);   // ❌ ReferenceError
}

// console.log(functionVar);   // ❌ ReferenceError
```

### Data Types - Different Kinds of Information

JavaScript has **primitive** and **non-primitive** data types.

#### Primitive Data Types (Immutable)
```javascript
// 1. STRING - Text data
let name = "John Doe";
let message = 'Hello World';
let template = `Welcome, ${name}!`; // Template literal with interpolation

// String methods (return new strings, don't modify original)
let text = "Hello World";
console.log(text.length);              // 11
console.log(text.toUpperCase());       // "HELLO WORLD"
console.log(text.toLowerCase());       // "hello world"
console.log(text.substring(0, 5));     // "Hello"
console.log(text.split(" "));          // ["Hello", "World"]
console.log(text.includes("World"));   // true

// 2. NUMBER - All numeric values (integer and floating-point)
let age = 25;
let price = 99.99;
let negative = -10;
let infinity = Infinity;
let notANumber = NaN;

// Number methods and operations
console.log(Number.isInteger(25));     // true
console.log(Number.parseFloat("3.14")); // 3.14
console.log(Math.round(3.7));          // 4
console.log(Math.random());            // Random number 0-1
console.log(Math.max(1, 5, 3));        // 5

// 3. BOOLEAN - True or false
let isStudent = true;
let isMarried = false;
let hasPermission = Boolean("some value"); // true (truthy conversion)

// 4. UNDEFINED - Variable declared but not assigned
let someVariable;
console.log(someVariable); // undefined
console.log(typeof someVariable); // "undefined"

// 5. NULL - Intentionally empty value
let emptyValue = null;
console.log(emptyValue); // null
console.log(typeof emptyValue); // "object" (JavaScript quirk)

// 6. SYMBOL - Unique identifier (ES6+)
let uniqueId = Symbol("id");
let anotherId = Symbol("id");
console.log(uniqueId === anotherId); // false (always unique)

// 7. BIGINT - Large integers (ES2020+)
let bigNumber = 123456789012345678901234567890n;
let anotherBig = BigInt("123456789012345678901234567890");
```

#### Non-Primitive Data Types (Mutable)
```javascript
// 1. ARRAY - Ordered list of values
let numbers = [1, 2, 3, 4, 5];
let mixed = ["John", 25, true, null, [1, 2, 3]];
let empty = [];

// Array methods (some modify original, some return new arrays)
let fruits = ["apple", "banana", "orange"];

// Modifying methods (mutate original array)
fruits.push("grape");           // Add to end: ["apple", "banana", "orange", "grape"]
fruits.pop();                   // Remove from end: ["apple", "banana", "orange"]
fruits.unshift("strawberry");   // Add to beginning: ["strawberry", "apple", "banana", "orange"]
fruits.shift();                 // Remove from beginning: ["apple", "banana", "orange"]
fruits.splice(1, 1, "mango");   // Replace: ["apple", "mango", "orange"]

// Non-modifying methods (return new arrays)
let upperFruits = fruits.map(fruit => fruit.toUpperCase());
let longFruits = fruits.filter(fruit => fruit.length > 5);
let fruitString = fruits.join(", ");

// 2. OBJECT - Key-value pairs (most important data type)
let person = {
    // Properties
    name: "John Doe",
    age: 30,
    isEmployed: true,
    hobbies: ["reading", "coding", "gaming"],
    
    // Methods (functions inside objects)
    greet: function() {
        return `Hello, I'm ${this.name}`;
    },
    
    // ES6 method shorthand
    introduce() {
        return `I'm ${this.name}, ${this.age} years old`;
    },
    
    // Computed property names
    [computedKey]: "computed value"
};

// Object property access
console.log(person.name);           // "John Doe" (dot notation)
console.log(person["age"]);         // 30 (bracket notation)
console.log(person.greet());        // "Hello, I'm John Doe"

// Adding/modifying properties
person.email = "john@example.com";  // Add new property
person.age = 31;                    // Modify existing property
delete person.isEmployed;           // Remove property

// Object methods for inspection
console.log(Object.keys(person));    // Array of property names
console.log(Object.values(person));  // Array of property values
console.log(Object.entries(person)); // Array of [key, value] pairs

// 3. FUNCTION - Reusable code blocks (functions are objects in JavaScript)
function regularFunction(param1, param2) {
    return param1 + param2;
}

// Function as variable
let functionVariable = function(x) {
    return x * 2;
};

// Arrow function (ES6+)
let arrowFunction = (x, y) => x + y;
let singleParam = x => x * 3;
let noParams = () => "Hello World";
```

### Type Conversion and Comparison

#### Implicit Type Coercion (Automatic conversion)
```javascript
// String concatenation
console.log("5" + 3);      // "53" (number converted to string)
console.log("5" - 3);      // 2 (string converted to number)
console.log("5" * "2");    // 10 (both converted to numbers)

// Boolean conversion
console.log(Boolean(0));        // false
console.log(Boolean(""));       // false (empty string)
console.log(Boolean(" "));      // true (non-empty string)
console.log(Boolean(null));     // false
console.log(Boolean(undefined)); // false
console.log(Boolean([]));       // true (arrays are truthy)
console.log(Boolean({}));       // true (objects are truthy)

// Falsy values (everything else is truthy)
// false, 0, -0, 0n, "", null, undefined, NaN
```

#### Explicit Type Conversion
```javascript
// To String
let num = 123;
console.log(String(num));        // "123"
console.log(num.toString());     // "123"
console.log(num + "");           // "123" (implicit)

// To Number
let str = "123";
console.log(Number(str));        // 123
console.log(parseInt(str));      // 123 (integer)
console.log(parseFloat("3.14")); // 3.14
console.log(+"123");             // 123 (unary plus)

// To Boolean
console.log(Boolean("hello"));   // true
console.log(!!"hello");          // true (double negation)
```

#### Comparison Operators
```javascript
let a = 5;
let b = "5";

// Loose equality (type coercion)
console.log(a == b);         // true (5 == "5" → 5 == 5)
console.log(a != b);         // false

// Strict equality (no type coercion)
console.log(a === b);        // false (5 !== "5")
console.log(a !== b);        // true

// Relational operators
console.log(a > 3);          // true
console.log(a >= 5);         // true
console.log(a < 10);         // true
console.log(a <= 5);         // true

// String comparison (lexicographical)
console.log("apple" < "banana"); // true
console.log("Apple" < "apple");  // true (uppercase comes first)
```

### Operators - Performing Operations

#### Arithmetic Operators
```javascript
let a = 10;
let b = 3;

console.log(a + b);    // 13 (addition)
console.log(a - b);    // 7 (subtraction)
console.log(a * b);    // 30 (multiplication)
console.log(a / b);    // 3.333... (division)
console.log(a % b);    // 1 (modulo - remainder)
console.log(a ** b);   // 1000 (exponentiation - ES2016)

// Increment and decrement
let count = 5;
console.log(count++);  // 5 (post-increment: return then increment)
console.log(count);    // 6
console.log(++count);  // 7 (pre-increment: increment then return)
console.log(count--);  // 7 (post-decrement)
console.log(--count);  // 5 (pre-decrement)
```

#### Assignment Operators
```javascript
let x = 10;

x += 5;    // x = x + 5;  → 15
x -= 3;    // x = x - 3;  → 12
x *= 2;    // x = x * 2;  → 24
x /= 4;    // x = x / 4;  → 6
x %= 5;    // x = x % 5;  → 1
x **= 3;   // x = x ** 3; → 1

// Nullish coalescing assignment (ES2021)
let user = { name: "John" };
user.age ??= 25; // Only assign if user.age is null or undefined
```

#### Logical Operators
```javascript
let isAdult = true;
let hasLicense = false;
let hasInsurance = true;

// AND (&&) - all must be true
console.log(isAdult && hasLicense);                    // false
console.log(isAdult && hasLicense && hasInsurance);    // false

// OR (||) - at least one must be true
console.log(isAdult || hasLicense);                    // true
console.log(hasLicense || hasInsurance);               // true

// NOT (!) - reverses boolean value
console.log(!isAdult);                                 // false
console.log(!hasLicense);                             // true

// Short-circuit evaluation
console.log(false && expensiveFunction());  // expensiveFunction() never called
console.log(true || expensiveFunction());   // expensiveFunction() never called

// Practical use - default values
let username = userInput || "Guest";        // Use "Guest" if userInput is falsy
let config = userConfig || defaultConfig;   // Use default if no user config

// Nullish coalescing (??) - only null/undefined trigger default
let value1 = null ?? "default";       // "default"
let value2 = 0 ?? "default";          // 0 (not "default" because 0 is not null/undefined)
let value3 = "" ?? "default";         // "" (not "default" because "" is not null/undefined)
```

### Control Flow - Making Decisions

#### Conditional Statements
```javascript
// Simple if/else
let age = 18;

if (age >= 18) {
    console.log("You can vote!");
} else {
    console.log("You're too young to vote.");
}

// Multiple conditions with else if
let score = 85;

if (score >= 90) {
    console.log("Grade: A");
} else if (score >= 80) {
    console.log("Grade: B");
} else if (score >= 70) {
    console.log("Grade: C");
} else if (score >= 60) {
    console.log("Grade: D");
} else {
    console.log("Grade: F");
}

// Complex conditions
let weather = "sunny";
let temperature = 75;
let hasUmbrella = true;

if ((weather === "sunny" && temperature > 70) || (weather === "rainy" && hasUmbrella)) {
    console.log("Good day to go out!");
} else {
    console.log("Stay inside today.");
}

// Ternary operator (conditional expression)
let status = age >= 18 ? "adult" : "minor";
let message = isLoggedIn ? `Welcome back, ${username}!` : "Please log in";

// Nested ternary (use sparingly)
let category = age < 13 ? "child" : age < 20 ? "teenager" : age < 65 ? "adult" : "senior";
```

#### Switch Statement
```javascript
let day = "Monday";
let schedule;

switch (day) {
    case "Monday":
        schedule = "Team meeting at 9 AM";
        break;
    case "Tuesday":
    case "Wednesday":
    case "Thursday":
        schedule = "Regular work day";
        break;
    case "Friday":
        schedule = "Code review and planning";
        break;
    case "Saturday":
    case "Sunday":
        schedule = "Weekend - no work!";
        break;
    default:
        schedule = "Invalid day";
        break;
}

// Modern switch with expressions (proposal)
let result = switch (operation) {
    case "add": yield operand1 + operand2;
    case "subtract": yield operand1 - operand2;
    case "multiply": yield operand1 * operand2;
    default: yield "Unknown operation";
};
```

### Loops - Repeating Actions

#### For Loops
```javascript
// Traditional for loop
for (let i = 0; i < 5; i++) {
    console.log(`Iteration ${i}`);
}

// For...of loop (iterates over values)
let fruits = ["apple", "banana", "orange"];
for (let fruit of fruits) {
    console.log(`I like ${fruit}`);
}

// For...in loop (iterates over keys/indices)
let person = { name: "John", age: 30, city: "New York" };
for (let key in person) {
    console.log(`${key}: ${person[key]}`);
}

// Array with for...in (gets indices)
for (let index in fruits) {
    console.log(`${index}: ${fruits[index]}`);
}
```

#### While Loops
```javascript
// While loop
let count = 0;
while (count < 3) {
    console.log(`Count is ${count}`);
    count++;
}

// Do...while loop (executes at least once)
let userInput;
do {
    userInput = prompt("Enter 'quit' to exit:");
    console.log(`You entered: ${userInput}`);
} while (userInput !== "quit");
```

#### Loop Control
```javascript
// Break - exit loop early
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break; // Exit loop when i equals 5
    }
    console.log(i); // Prints 0, 1, 2, 3, 4
}

// Continue - skip current iteration
for (let i = 0; i < 10; i++) {
    if (i % 2 === 0) {
        continue; // Skip even numbers
    }
    console.log(i); // Prints 1, 3, 5, 7, 9
}

// Labeled breaks (for nested loops)
outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) {
            break outer; // Break out of both loops
        }
        console.log(`${i}, ${j}`);
    }
}
```

## Functions - Reusable Code Building Blocks

Functions are the **fundamental building blocks** of JavaScript programs. They encapsulate logic and make code reusable.

### Function Declaration Patterns

#### Traditional Function Declaration
```javascript
// Function declaration (hoisted - can be called before definition)
function calculateArea(width, height) {
    return width * height;
}

// Function can be called before its declaration
console.log(calculateArea(5, 3)); // 15

// Function with default parameters (ES6+)
function greet(name = "World", greeting = "Hello") {
    return `${greeting}, ${name}!`;
}

console.log(greet());                    // "Hello, World!"
console.log(greet("John"));              // "Hello, John!"
console.log(greet("John", "Hi"));        // "Hi, John!"

// Function with rest parameters (collect remaining arguments)
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
console.log(sum(10, 20));         // 30
```

#### Function Expressions
```javascript
// Function expression (not hoisted)
const multiply = function(a, b) {
    return a * b;
};

// Named function expression (useful for debugging)
const factorial = function fact(n) {
    return n <= 1 ? 1 : n * fact(n - 1);
};

// Immediately Invoked Function Expression (IIFE)
const result = (function(x, y) {
    return x + y;
})(5, 3); // 8

// IIFE for module pattern
const calculator = (function() {
    let memory = 0;
    
    return {
        add(x) {
            memory += x;
            return this;
        },
        subtract(x) {
            memory -= x;
            return this;
        },
        getResult() {
            return memory;
        },
        clear() {
            memory = 0;
            return this;
        }
    };
})();

calculator.add(5).subtract(2).add(10); // Chain methods
console.log(calculator.getResult()); // 13
```

#### Arrow Functions (ES6+)
```javascript
// Basic arrow function syntax
const add = (a, b) => a + b;
const square = x => x * x;           // Single parameter doesn't need parentheses
const greet = () => "Hello World!";  // No parameters need empty parentheses

// Arrow function with block body
const processUser = (user) => {
    const processed = {
        ...user,
        fullName: `${user.firstName} ${user.lastName}`,
        isAdult: user.age >= 18
    };
    
    console.log(`Processing user: ${processed.fullName}`);
    return processed;
};

// Arrow functions in array methods
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
const sum = numbers.reduce((total, n) => total + n, 0);

// Important: Arrow functions don't have their own 'this'
const obj = {
    name: "MyObject",
    regularMethod: function() {
        console.log(this.name); // "MyObject"
    },
    arrowMethod: () => {
        console.log(this.name); // undefined (in browser: window.name)
    }
};
```

### Function Scope and Closures

#### Understanding Scope
```javascript
// Global scope
const globalVar = "I'm global";

function outerFunction(x) {
    // Function scope
    const outerVar = "I'm in outer function";
    
    function innerFunction(y) {
        // Inner function scope - has access to outer scopes
        const innerVar = "I'm in inner function";
        
        console.log(globalVar); // ✅ Can access
        console.log(outerVar);  // ✅ Can access
        console.log(innerVar);  // ✅ Can access
        console.log(x, y);      // ✅ Can access parameters
    }
    
    return innerFunction;
}

const inner = outerFunction("outer param");
inner("inner param");
```

#### Closures - Functions That Remember
```javascript
// Closure: Inner function has access to outer function's variables
function createCounter() {
    let count = 0; // Private variable
    
    return function() {
        count++; // Accesses variable from outer scope
        return count;
    };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1 (separate instance)

// Practical closure example: Private methods
function createBankAccount(initialBalance) {
    let balance = initialBalance;
    
    return {
        deposit(amount) {
            if (amount > 0) {
                balance += amount;
                return balance;
            }
            throw new Error("Deposit amount must be positive");
        },
        
        withdraw(amount) {
            if (amount > 0 && amount <= balance) {
                balance -= amount;
                return balance;
            }
            throw new Error("Invalid withdrawal amount");
        },
        
        getBalance() {
            return balance;
        }
    };
}

const account = createBankAccount(100);
console.log(account.deposit(50));  // 150
console.log(account.withdraw(30)); // 120
console.log(account.getBalance()); // 120
// console.log(account.balance);   // undefined (private)
```

### Array Methods - Functional Programming

JavaScript arrays have powerful built-in methods for data manipulation:

```javascript
const users = [
    { id: 1, name: "John", age: 30, active: true },
    { id: 2, name: "Jane", age: 25, active: false },
    { id: 3, name: "Bob", age: 35, active: true },
    { id: 4, name: "Alice", age: 28, active: true }
];

// MAP - Transform each element
const names = users.map(user => user.name);
const userCards = users.map(user => ({
    title: user.name,
    subtitle: `Age: ${user.age}`,
    isActive: user.active
}));

// FILTER - Select elements that match criteria
const activeUsers = users.filter(user => user.active);
const youngUsers = users.filter(user => user.age < 30);
const activeYoungUsers = users.filter(user => user.active && user.age < 30);

// REDUCE - Combine elements into single value
const totalAge = users.reduce((sum, user) => sum + user.age, 0);
const usersByAge = users.reduce((groups, user) => {
    const ageGroup = user.age < 30 ? 'young' : 'older';
    groups[ageGroup] = groups[ageGroup] || [];
    groups[ageGroup].push(user);
    return groups;
}, {});

// FIND - Get first element that matches
const firstActiveUser = users.find(user => user.active);
const userById = users.find(user => user.id === 3);

// SOME/EVERY - Boolean checks
const hasActiveUsers = users.some(user => user.active);     // true
const allUsersActive = users.every(user => user.active);    // false

// SORT - Order elements
const sortedByAge = [...users].sort((a, b) => a.age - b.age);
const sortedByName = [...users].sort((a, b) => a.name.localeCompare(b.name));

// FOREACH - Execute function for each element (side effects)
users.forEach(user => {
    console.log(`${user.name} is ${user.age} years old`);
});

// Chaining methods
const result = users
    .filter(user => user.active)
    .map(user => ({ ...user, category: user.age < 30 ? 'young' : 'experienced' }))
    .sort((a, b) => a.age - b.age);
```

## DOM Manipulation - Interacting with Web Pages

The **Document Object Model (DOM)** is JavaScript's interface to HTML. It represents the page as a tree of objects that can be manipulated.

### Understanding the DOM Tree
```html
<!DOCTYPE html>
<html>
  <head>
    <title>My Page</title>
  </head>
  <body>
    <h1 id="title">Welcome</h1>
    <div class="container">
      <p class="text">Hello World</p>
    </div>
  </body>
</html>
```

```
DOM Tree:
document
└── html
    ├── head
    │   └── title
    │       └── "My Page"
    └── body
        ├── h1#title
        │   └── "Welcome"
        └── div.container
            └── p.text
                └── "Hello World"
```

### Selecting DOM Elements

```javascript
// Get element by ID (returns single element or null)
const title = document.getElementById("title");
const header = document.querySelector("#title"); // Alternative

// Get elements by class name (returns HTMLCollection)
const textElements = document.getElementsByClassName("text");
const textArray = Array.from(textElements); // Convert to array

// Get elements by tag name
const paragraphs = document.getElementsByTagName("p");

// Modern query selectors (preferred)
const firstText = document.querySelector(".text");     // First match
const allTexts = document.querySelectorAll(".text");   // All matches (NodeList)

// Advanced selectors
const nestedP = document.querySelector(".container p");
const directChild = document.querySelector(".container > p");
const lastItem = document.querySelector("li:last-child");
const dataElement = document.querySelector("[data-id='123']");

// Traversing the DOM
const container = document.querySelector(".container");
const parent = container.parentElement;
const children = container.children;
const firstChild = container.firstElementChild;
const lastChild = container.lastElementChild;
const nextSibling = container.nextElementSibling;
const previousSibling = container.previousElementSibling;
```

### Modifying DOM Elements

```javascript
// Changing content
const title = document.querySelector("#title");
title.textContent = "New Title";           // Plain text (safe from XSS)
title.innerHTML = "<em>Emphasized</em>";   // HTML content (be careful with user input)

// Reading content
const currentText = title.textContent;
const currentHTML = title.innerHTML;

// Changing attributes
const image = document.querySelector("img");
image.src = "new-image.jpg";
image.alt = "New image description";
image.setAttribute("data-loaded", "true");
image.removeAttribute("loading");

// Getting attributes
const imageSource = image.src;
const customData = image.getAttribute("data-id");
const hasAttribute = image.hasAttribute("alt");

// Changing styles
const box = document.querySelector(".box");
box.style.backgroundColor = "blue";
box.style.fontSize = "18px";
box.style.padding = "20px";

// Better approach: CSS classes
box.classList.add("highlighted");
box.classList.remove("hidden");
box.classList.toggle("active");
box.classList.contains("visible");

// Multiple classes
box.classList.add("class1", "class2", "class3");

// CSS custom properties
document.documentElement.style.setProperty("--main-color", "#3498db");
```

### Creating and Manipulating Elements

```javascript
// Creating new elements
const newDiv = document.createElement("div");
const newParagraph = document.createElement("p");
const newImage = document.createElement("img");

// Setting up new elements
newDiv.className = "card";
newDiv.setAttribute("data-id", "123");

newParagraph.textContent = "This is a new paragraph";
newParagraph.classList.add("description");

newImage.src = "photo.jpg";
newImage.alt = "A beautiful photo";

// Adding elements to the DOM
const container = document.querySelector(".container");
container.appendChild(newDiv);              // Add to end
container.insertBefore(newParagraph, newDiv); // Insert before newDiv
newDiv.appendChild(newImage);               // Add image to div

// Modern insertion methods
container.prepend(newParagraph);            // Add to beginning
container.append(newDiv);                   // Add to end
newDiv.before(newParagraph);               // Insert before newDiv
newDiv.after(newImage);                    // Insert after newDiv

// Creating complex structures
function createUserCard(user) {
    const card = document.createElement("div");
    card.className = "user-card";
    card.setAttribute("data-user-id", user.id);
    
    card.innerHTML = `
        <img src="${user.avatar}" alt="${user.name}" class="user-avatar">
        <h3 class="user-name">${user.name}</h3>
        <p class="user-email">${user.email}</p>
        <button class="user-contact" data-user-id="${user.id}">Contact</button>
    `;
    
    return card;
}

// Using the function
const userData = { id: 1, name: "John Doe", email: "john@example.com", avatar: "john.jpg" };
const userCard = createUserCard(userData);
document.querySelector("#users").appendChild(userCard);

// Removing elements
const elementToRemove = document.querySelector(".old-element");
elementToRemove.remove();                   // Modern way
elementToRemove.parentNode.removeChild(elementToRemove); // Legacy way

// Cloning elements
const original = document.querySelector(".template");
const clone = original.cloneNode(true);     // true = deep clone (include children)
document.body.appendChild(clone);
```

### Event Handling - Responding to User Actions

```javascript
// Basic event listener
const button = document.querySelector("#myButton");
button.addEventListener("click", function() {
    console.log("Button was clicked!");
});

// Arrow function event handler
button.addEventListener("click", () => {
    console.log("Button clicked with arrow function!");
});

// Event handler with parameters
function handleButtonClick(event) {
    console.log("Button clicked!", event);
    console.log("Button text:", event.target.textContent);
    console.log("Click coordinates:", event.clientX, event.clientY);
}

button.addEventListener("click", handleButtonClick);

// Multiple event types
const input = document.querySelector("#emailInput");

input.addEventListener("focus", () => {
    input.classList.add("focused");
});

input.addEventListener("blur", () => {
    input.classList.remove("focused");
});

input.addEventListener("input", (event) => {
    console.log("User typed:", event.target.value);
});

// Form handling
const form = document.querySelector("#contactForm");
form.addEventListener("submit", (event) => {
    event.preventDefault(); // Prevent default form submission
    
    const formData = new FormData(form);
    const data = Object.fromEntries(formData);
    
    console.log("Form data:", data);
    
    // Validate form
    if (!data.email.includes("@")) {
        alert("Please enter a valid email");
        return;
    }
    
    // Submit form data
    submitForm(data);
});

// Event delegation - handle events for dynamic content
const userList = document.querySelector("#userList");
userList.addEventListener("click", (event) => {
    if (event.target.classList.contains("delete-button")) {
        const userId = event.target.getAttribute("data-user-id");
        deleteUser(userId);
    }
    
    if (event.target.classList.contains("edit-button")) {
        const userId = event.target.getAttribute("data-user-id");
        editUser(userId);
    }
});

// Keyboard events
document.addEventListener("keydown", (event) => {
    if (event.key === "Escape") {
        closeModal();
    }
    
    if (event.ctrlKey && event.key === "s") {
        event.preventDefault(); // Prevent browser save
        saveDocument();
    }
});

// Mouse events
const draggable = document.querySelector(".draggable");
let isDragging = false;

draggable.addEventListener("mousedown", (event) => {
    isDragging = true;
    console.log("Started dragging");
});

document.addEventListener("mousemove", (event) => {
    if (isDragging) {
        draggable.style.left = event.clientX + "px";
        draggable.style.top = event.clientY + "px";
    }
});

document.addEventListener("mouseup", () => {
    isDragging = false;
    console.log("Stopped dragging");
});

// Custom events
const customEvent = new CustomEvent("userLoggedIn", {
    detail: { userId: 123, userName: "John Doe" }
});

document.addEventListener("userLoggedIn", (event) => {
    console.log("User logged in:", event.detail);
    updateUI(event.detail);
});

// Trigger custom event
document.dispatchEvent(customEvent);
```

## Asynchronous JavaScript - Handling Time and External Data

### Understanding Asynchronous Programming

JavaScript is **single-threaded** but can handle asynchronous operations through the **event loop**.

```javascript
// Synchronous (blocking)
console.log("First");
console.log("Second");
console.log("Third");
// Output: First, Second, Third (in order)

// Asynchronous (non-blocking)
console.log("First");
setTimeout(() => console.log("Second"), 0);
console.log("Third");
// Output: First, Third, Second (Third comes before Second!)
```

### Callbacks - The Original Async Pattern

```javascript
// Basic callback
function fetchUserData(userId, callback) {
    // Simulate API call with timeout
    setTimeout(() => {
        const userData = { id: userId, name: "John Doe", email: "john@example.com" };
        callback(null, userData); // Node.js convention: error first
    }, 1000);
}

// Using the callback
fetchUserData(123, (error, user) => {
    if (error) {
        console.error("Error:", error);
        return;
    }
    console.log("User data:", user);
});

// Callback hell (pyramid of doom)
fetchUserData(123, (error, user) => {
    if (error) return console.error(error);
    
    fetchUserPosts(user.id, (error, posts) => {
        if (error) return console.error(error);
        
        fetchPostComments(posts[0].id, (error, comments) => {
            if (error) return console.error(error);
            
            console.log("User, posts, and comments loaded");
            // This nesting gets unwieldy quickly!
        });
    });
});
```

### Promises - Better Async Handling

```javascript
// Creating a Promise
function fetchUserData(userId) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (userId > 0) {
                const userData = { id: userId, name: "John Doe", email: "john@example.com" };
                resolve(userData); // Success
            } else {
                reject(new Error("Invalid user ID")); // Failure
            }
        }, 1000);
    });
}

// Using Promises with .then()
fetchUserData(123)
    .then(user => {
        console.log("User data:", user);
        return fetchUserPosts(user.id); // Return another promise
    })
    .then(posts => {
        console.log("User posts:", posts);
        return fetchPostComments(posts[0].id);
    })
    .then(comments => {
        console.log("Post comments:", comments);
    })
    .catch(error => {
        console.error("Something went wrong:", error);
    })
    .finally(() => {
        console.log("Operation completed");
    });

// Promise.all - Wait for multiple promises
const userPromise = fetchUserData(123);
const postsPromise = fetchUserPosts(123);
const settingsPromise = fetchUserSettings(123);

Promise.all([userPromise, postsPromise, settingsPromise])
    .then(([user, posts, settings]) => {
        console.log("All data loaded:", { user, posts, settings });
    })
    .catch(error => {
        console.error("At least one request failed:", error);
    });

// Promise.race - First one to complete wins
Promise.race([
    fetchUserData(123),
    new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 5000))
])
    .then(user => console.log("User loaded quickly:", user))
    .catch(error => console.error("Request timed out or failed:", error));
```

### Async/Await - Modern Async Syntax

```javascript
// Async function declaration
async function loadUserProfile(userId) {
    try {
        // Wait for user data
        const user = await fetchUserData(userId);
        console.log("User loaded:", user);
        
        // Wait for user posts
        const posts = await fetchUserPosts(user.id);
        console.log("Posts loaded:", posts);
        
        // Wait for user settings
        const settings = await fetchUserSettings(user.id);
        console.log("Settings loaded:", settings);
        
        return { user, posts, settings };
    } catch (error) {
        console.error("Failed to load user profile:", error);
        throw error; // Re-throw if you want calling code to handle it
    }
}

// Using async function
loadUserProfile(123)
    .then(profile => {
        console.log("Complete profile:", profile);
        displayUserProfile(profile);
    })
    .catch(error => {
        displayError("Failed to load profile");
    });

// Async arrow function
const loadUserData = async (userId) => {
    const user = await fetchUserData(userId);
    return user;
};

// Parallel execution with async/await
async function loadUserDataParallel(userId) {
    try {
        // Start all requests simultaneously
        const userPromise = fetchUserData(userId);
        const postsPromise = fetchUserPosts(userId);
        const settingsPromise = fetchUserSettings(userId);
        
        // Wait for all to complete
        const [user, posts, settings] = await Promise.all([
            userPromise,
            postsPromise,
            settingsPromise
        ]);
        
        return { user, posts, settings };
    } catch (error) {
        console.error("Failed to load data:", error);
        throw error;
    }
}

// Error handling with async/await
async function robustDataLoader(userId) {
    try {
        const user = await fetchUserData(userId);
        
        try {
            const posts = await fetchUserPosts(user.id);
            return { user, posts };
        } catch (postsError) {
            console.warn("Failed to load posts, continuing without them");
            return { user, posts: [] };
        }
        
    } catch (userError) {
        console.error("Failed to load user, cannot continue");
        throw new Error("User loading failed");
    }
}
```

### Fetch API - Making HTTP Requests

```javascript
// Basic GET request
async function getUsers() {
    try {
        const response = await fetch("/api/users");
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const users = await response.json();
        return users;
    } catch (error) {
        console.error("Failed to fetch users:", error);
        throw error;
    }
}

// POST request with data
async function createUser(userData) {
    try {
        const response = await fetch("/api/users", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${authToken}`
            },
            body: JSON.stringify(userData)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || "Failed to create user");
        }
        
        const newUser = await response.json();
        return newUser;
    } catch (error) {
        console.error("Failed to create user:", error);
        throw error;
    }
}

// File upload
async function uploadFile(file) {
    const formData = new FormData();
    formData.append("file", file);
    formData.append("category", "profile-image");
    
    try {
        const response = await fetch("/api/upload", {
            method: "POST",
            body: formData // Don't set Content-Type header for FormData
        });
        
        if (!response.ok) {
            throw new Error("Upload failed");
        }
        
        const result = await response.json();
        return result;
    } catch (error) {
        console.error("File upload failed:", error);
        throw error;
    }
}

// Request with timeout
async function fetchWithTimeout(url, options = {}, timeout = 5000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === "AbortError") {
            throw new Error("Request timed out");
        }
        throw error;
    }
}
```

## Modern JavaScript Features (ES6+)

### Destructuring - Extracting Data Elegantly

```javascript
// Array destructuring
const colors = ["red", "green", "blue", "yellow"];
const [primary, secondary, tertiary, ...others] = colors;
console.log(primary);     // "red"
console.log(secondary);   // "green"
console.log(others);      // ["yellow"]

// Skipping elements
const [first, , third] = colors;
console.log(first, third); // "red", "blue"

// Default values
const [a, b, c, d = "default"] = ["x", "y"];
console.log(d); // "default"

// Object destructuring
const user = {
    id: 1,
    name: "John Doe",
    email: "john@example.com",
    preferences: {
        theme: "dark",
        language: "en"
    }
};

// Basic destructuring
const { name, email } = user;

// Renaming variables
const { name: userName, email: userEmail } = user;

// Nested destructuring
const { preferences: { theme, language } } = user;

// Default values
const { age = 25, country = "USA" } = user;

// Function parameter destructuring
function createUserCard({ name, email, avatar = "default.jpg" }) {
    return `
        <div class="user-card">
            <img src="${avatar}" alt="${name}">
            <h3>${name}</h3>
            <p>${email}</p>
        </div>
    `;
}

// Rest in destructuring
const { name, ...otherUserData } = user;
console.log(otherUserData); // { id: 1, email: "john@example.com", preferences: {...} }
```

### Spread Operator (...) - Expanding Collections

```javascript
// Array spreading
const fruits = ["apple", "banana"];
const vegetables = ["carrot", "broccoli"];
const food = [...fruits, ...vegetables, "cheese"];
console.log(food); // ["apple", "banana", "carrot", "broccoli", "cheese"]

// Copying arrays
const originalArray = [1, 2, 3];
const copiedArray = [...originalArray];
copiedArray.push(4); // Original array unchanged

// Finding max/min in arrays
const numbers = [5, 2, 9, 1, 7];
const maxNumber = Math.max(...numbers);
const minNumber = Math.min(...numbers);

// Object spreading
const baseUser = { name: "John", age: 30 };
const extendedUser = { ...baseUser, email: "john@example.com", age: 31 };
console.log(extendedUser); // { name: "John", age: 31, email: "john@example.com" }

// Merging objects
const defaults = { theme: "light", language: "en", notifications: true };
const userSettings = { theme: "dark", language: "es" };
const finalSettings = { ...defaults, ...userSettings };
// finalSettings: { theme: "dark", language: "es", notifications: true }

// Function arguments
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// Converting NodeList to Array
const elements = document.querySelectorAll('.item');
const elementsArray = [...elements];
```

### Template Literals - Advanced String Handling

```javascript
// Basic template literals
const name = "John";
const age = 30;
const message = `Hello, my name is ${name} and I am ${age} years old.`;

// Multi-line strings
const htmlTemplate = `
    <div class="user-profile">
        <h1>${name}</h1>
        <p>Age: ${age}</p>
        <p>Status: ${age >= 18 ? "Adult" : "Minor"}</p>
    </div>
`;

// Expression evaluation
const price = 19.99;
const tax = 0.08;
const total = `Total: $${(price * (1 + tax)).toFixed(2)}`;

// Tagged template literals
function highlight(strings, ...values) {
    return strings.reduce((result, string, i) => {
        const value = values[i] ? `<mark>${values[i]}</mark>` : '';
        return result + string + value;
    }, '');
}

const searchTerm = "JavaScript";
const text = highlight`Learning ${searchTerm} is fun and ${searchTerm} is powerful!`;
// "Learning <mark>JavaScript</mark> is fun and <mark>JavaScript</mark> is powerful!"

// SQL-like template literals
function sql(strings, ...values) {
    return {
        query: strings.join('?'),
        values: values
    };
}

const userId = 123;
const userName = "John";
const query = sql`SELECT * FROM users WHERE id = ${userId} AND name = ${userName}`;
console.log(query); // { query: "SELECT * FROM users WHERE id = ? AND name = ?", values: [123, "John"] }
```

### Classes - Object-Oriented Programming

```javascript
// Class declaration
class User {
    // Constructor method
    constructor(name, email) {
        this.name = name;
        this.email = email;
        this.createdAt = new Date();
        this._id = Math.random().toString(36).substr(2, 9); // Private-like property
    }
    
    // Instance methods
    greet() {
        return `Hello, I'm ${this.name}`;
    }
    
    getProfile() {
        return {
            name: this.name,
            email: this.email,
            memberSince: this.createdAt.getFullYear()
        };
    }
    
    // Getter
    get displayName() {
        return this.name.toUpperCase();
    }
    
    // Setter
    set displayName(value) {
        this.name = value.toLowerCase();
    }
    
    // Static method
    static createFromData(userData) {
        return new User(userData.name, userData.email);
    }
    
    // Private method (ES2022)
    #validateEmail(email) {
        return email.includes('@');
    }
}

// Class inheritance
class AdminUser extends User {
    constructor(name, email, permissions) {
        super(name, email); // Call parent constructor
        this.permissions = permissions || [];
    }
    
    // Override parent method
    greet() {
        return `Hello, I'm ${this.name} (Administrator)`;
    }
    
    // Additional methods
    hasPermission(permission) {
        return this.permissions.includes(permission);
    }
    
    addPermission(permission) {
        if (!this.hasPermission(permission)) {
            this.permissions.push(permission);
        }
    }
}

// Using classes
const user = new User("John Doe", "john@example.com");
console.log(user.greet()); // "Hello, I'm John Doe"
console.log(user.displayName); // "JOHN DOE"

const admin = new AdminUser("Jane Smith", "jane@example.com", ["read", "write"]);
console.log(admin.greet()); // "Hello, I'm Jane Smith (Administrator)"
console.log(admin.hasPermission("read")); // true

// Static method usage
const userData = { name: "Bob", email: "bob@example.com" };
const bobUser = User.createFromData(userData);
```

### Module System - Code Organization

```javascript
// utils/math.js - Named exports
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}

export class Calculator {
    constructor() {
        this.memory = 0;
    }
    
    add(value) {
        this.memory += value;
        return this;
    }
    
    getResult() {
        return this.memory;
    }
}

// utils/api.js - Default export with named exports
export default class ApiClient {
    constructor(baseURL) {
        this.baseURL = baseURL;
    }
    
    async get(endpoint) {
        const response = await fetch(`${this.baseURL}${endpoint}`);
        return response.json();
    }
    
    async post(endpoint, data) {
        const response = await fetch(`${this.baseURL}${endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        return response.json();
    }
}

export const HTTP_METHODS = {
    GET: 'GET',
    POST: 'POST',
    PUT: 'PUT',
    DELETE: 'DELETE'
};

// main.js - Importing
import ApiClient, { HTTP_METHODS } from './utils/api.js';
import { add, multiply, Calculator, PI } from './utils/math.js';
import * as MathUtils from './utils/math.js'; // Import all as namespace

// Using imports
const calc = new Calculator();
const result = calc.add(5).add(3).getResult();

const api = new ApiClient('https://api.example.com');
api.get('/users').then(users => console.log(users));

console.log(MathUtils.add(5, 3)); // 8
console.log(MathUtils.PI); // 3.14159

// Dynamic imports (for code splitting)
async function loadModule() {
    const { add, multiply } = await import('./utils/math.js');
    return add(5, multiply(2, 3));
}
```

### Promises and Async Patterns

```javascript
// Promise creation and chaining
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function fetchUserData(userId) {
    return new Promise((resolve, reject) => {
        // Simulate API call
        setTimeout(() => {
            if (userId > 0) {
                resolve({ id: userId, name: `User ${userId}`, email: `user${userId}@example.com` });
            } else {
                reject(new Error('Invalid user ID'));
            }
        }, 1000);
    });
}

// Promise chaining
fetchUserData(1)
    .then(user => {
        console.log('User loaded:', user);
        return fetchUserPosts(user.id);
    })
    .then(posts => {
        console.log('Posts loaded:', posts);
        return processUserData(posts);
    })
    .then(processedData => {
        console.log('Data processed:', processedData);
    })
    .catch(error => {
        console.error('Error in chain:', error);
    })
    .finally(() => {
        console.log('Operation completed');
    });

// Promise combinators
async function loadDashboardData(userId) {
    try {
        // Promise.all - wait for all (fails if any fails)
        const [user, posts, notifications] = await Promise.all([
            fetchUserData(userId),
            fetchUserPosts(userId),
            fetchUserNotifications(userId)
        ]);
        
        // Promise.allSettled - wait for all (doesn't fail)
        const results = await Promise.allSettled([
            fetchUserAnalytics(userId),
            fetchUserPreferences(userId),
            fetchUserSubscriptions(userId)
        ]);
        
        const successfulResults = results
            .filter(result => result.status === 'fulfilled')
            .map(result => result.value);
        
        return {
            user,
            posts,
            notifications,
            additionalData: successfulResults
        };
    } catch (error) {
        console.error('Failed to load dashboard:', error);
        throw error;
    }
}

// Promise.race - first to complete wins
async function fetchWithFallback(primaryUrl, fallbackUrl) {
    try {
        return await Promise.race([
            fetch(primaryUrl),
            delay(3000).then(() => Promise.reject(new Error('Timeout')))
        ]);
    } catch (error) {
        console.warn('Primary request failed, trying fallback');
        return fetch(fallbackUrl);
    }
}

// Advanced async patterns
class DataLoader {
    constructor() {
        this.cache = new Map();
        this.pendingRequests = new Map();
    }
    
    async loadData(key) {
        // Return cached data if available
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        // Return pending request if already in progress
        if (this.pendingRequests.has(key)) {
            return this.pendingRequests.get(key);
        }
        
        // Start new request
        const request = this.fetchData(key)
            .then(data => {
                this.cache.set(key, data);
                this.pendingRequests.delete(key);
                return data;
            })
            .catch(error => {
                this.pendingRequests.delete(key);
                throw error;
            });
        
        this.pendingRequests.set(key, request);
        return request;
    }
    
    async fetchData(key) {
        // Simulate API call
        await delay(1000);
        return { key, data: `Data for ${key}`, timestamp: Date.now() };
    }
}
```

## Real-World JavaScript Applications

### Complete Todo Application

```javascript
// todo-app.js - Complete Todo Application
class TodoApp {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.todos = JSON.parse(localStorage.getItem('todos')) || [];
        this.filter = 'all'; // all, active, completed
        this.nextId = Math.max(...this.todos.map(t => t.id), 0) + 1;
        
        this.init();
    }
    
    init() {
        this.render();
        this.bindEvents();
        this.loadFromStorage();
    }
    
    bindEvents() {
        // Add new todo
        this.container.addEventListener('submit', (e) => {
            if (e.target.classList.contains('todo-form')) {
                e.preventDefault();
                const input = e.target.querySelector('.todo-input');
                if (input.value.trim()) {
                    this.addTodo(input.value.trim());
                    input.value = '';
                }
            }
        });
        
        // Handle todo interactions
        this.container.addEventListener('click', (e) => {
            const todoId = parseInt(e.target.dataset.todoId);
            
            if (e.target.classList.contains('todo-toggle')) {
                this.toggleTodo(todoId);
            } else if (e.target.classList.contains('todo-delete')) {
                this.deleteTodo(todoId);
            } else if (e.target.classList.contains('filter-btn')) {
                this.setFilter(e.target.dataset.filter);
            } else if (e.target.classList.contains('clear-completed')) {
                this.clearCompleted();
            }
        });
        
        // Handle todo editing
        this.container.addEventListener('dblclick', (e) => {
            if (e.target.classList.contains('todo-text')) {
                this.editTodo(parseInt(e.target.dataset.todoId));
            }
        });
        
        // Save on edit
        this.container.addEventListener('blur', (e) => {
            if (e.target.classList.contains('todo-edit')) {
                this.saveEdit(parseInt(e.target.dataset.todoId), e.target.value);
            }
        }, true);
        
        // Save on Enter key
        this.container.addEventListener('keydown', (e) => {
            if (e.target.classList.contains('todo-edit') && e.key === 'Enter') {
                e.target.blur();
            }
        });
    }
    
    addTodo(text) {
        const todo = {
            id: this.nextId++,
            text: text,
            completed: false,
            createdAt: new Date().toISOString()
        };
        
        this.todos.push(todo);
        this.saveToStorage();
        this.render();
    }
    
    toggleTodo(id) {
        const todo = this.todos.find(t => t.id === id);
        if (todo) {
            todo.completed = !todo.completed;
            this.saveToStorage();
            this.render();
        }
    }
    
    deleteTodo(id) {
        this.todos = this.todos.filter(t => t.id !== id);
        this.saveToStorage();
        this.render();
    }
    
    editTodo(id) {
        const todoElement = this.container.querySelector(`[data-todo-id="${id}"]`);
        const textElement = todoElement.querySelector('.todo-text');
        const currentText = textElement.textContent;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'todo-edit';
        input.value = currentText;
        input.dataset.todoId = id;
        
        textElement.replaceWith(input);
        input.focus();
        input.select();
    }
    
    saveEdit(id, newText) {
        const todo = this.todos.find(t => t.id === id);
        if (todo && newText.trim()) {
            todo.text = newText.trim();
            this.saveToStorage();
        }
        this.render();
    }
    
    setFilter(filter) {
        this.filter = filter;
        this.render();
    }
    
    clearCompleted() {
        this.todos = this.todos.filter(t => !t.completed);
        this.saveToStorage();
        this.render();
    }
    
    getFilteredTodos() {
        switch (this.filter) {
            case 'active':
                return this.todos.filter(t => !t.completed);
            case 'completed':
                return this.todos.filter(t => t.completed);
            default:
                return this.todos;
        }
    }
    
    render() {
        const filteredTodos = this.getFilteredTodos();
        const activeCount = this.todos.filter(t => !t.completed).length;
        const completedCount = this.todos.filter(t => t.completed).length;
        
        this.container.innerHTML = `
            <div class="todo-app">
                <h1>Todo App</h1>
                
                <form class="todo-form">
                    <input type="text" class="todo-input" placeholder="What needs to be done?" autocomplete="off">
                </form>
                
                <div class="todo-list">
                    ${filteredTodos.map(todo => `
                        <div class="todo-item ${todo.completed ? 'completed' : ''}" data-todo-id="${todo.id}">
                            <input type="checkbox" class="todo-toggle" data-todo-id="${todo.id}" ${todo.completed ? 'checked' : ''}>
                            <span class="todo-text" data-todo-id="${todo.id}">${todo.text}</span>
                            <button class="todo-delete" data-todo-id="${todo.id}">×</button>
                        </div>
                    `).join('')}
                </div>
                
                <div class="todo-footer">
                    <span class="todo-count">${activeCount} item${activeCount !== 1 ? 's' : ''} left</span>
                    
                    <div class="todo-filters">
                        <button class="filter-btn ${this.filter === 'all' ? 'active' : ''}" data-filter="all">All</button>
                        <button class="filter-btn ${this.filter === 'active' ? 'active' : ''}" data-filter="active">Active</button>
                        <button class="filter-btn ${this.filter === 'completed' ? 'active' : ''}" data-filter="completed">Completed</button>
                    </div>
                    
                    ${completedCount > 0 ? '<button class="clear-completed">Clear completed</button>' : ''}
                </div>
            </div>
        `;
    }
    
    saveToStorage() {
        localStorage.setItem('todos', JSON.stringify(this.todos));
    }
    
    loadFromStorage() {
        const saved = localStorage.getItem('todos');
        if (saved) {
            this.todos = JSON.parse(saved);
            this.nextId = Math.max(...this.todos.map(t => t.id), 0) + 1;
            this.render();
        }
    }
}

// Usage
document.addEventListener('DOMContentLoaded', () => {
    new TodoApp('app');
});
```

### API Service Class

```javascript
// api-service.js - Robust API handling
class ApiService {
    constructor(baseURL, options = {}) {
        this.baseURL = baseURL;
        this.defaultOptions = {
            headers: {
                'Content-Type': 'application/json',
            },
            ...options
        };
        this.interceptors = {
            request: [],
            response: []
        };
    }
    
    // Add request interceptor
    addRequestInterceptor(interceptor) {
        this.interceptors.request.push(interceptor);
    }
    
    // Add response interceptor
    addResponseInterceptor(interceptor) {
        this.interceptors.response.push(interceptor);
    }
    
    // Apply request interceptors
    async applyRequestInterceptors(config) {
        let modifiedConfig = config;
        for (const interceptor of this.interceptors.request) {
            modifiedConfig = await interceptor(modifiedConfig);
        }
        return modifiedConfig;
    }
    
    // Apply response interceptors
    async applyResponseInterceptors(response) {
        let modifiedResponse = response;
        for (const interceptor of this.interceptors.response) {
            modifiedResponse = await interceptor(modifiedResponse);
        }
        return modifiedResponse;
    }
    
    // Main request method
    async request(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        
        // Merge options
        const config = {
            ...this.defaultOptions,
            ...options,
            headers: {
                ...this.defaultOptions.headers,
                ...options.headers
            }
        };
        
        try {
            // Apply request interceptors
            const modifiedConfig = await this.applyRequestInterceptors(config);
            
            // Make request
            const response = await fetch(url, modifiedConfig);
            
            // Apply response interceptors
            const modifiedResponse = await this.applyResponseInterceptors(response);
            
            // Handle non-OK responses
            if (!modifiedResponse.ok) {
                const errorData = await modifiedResponse.json().catch(() => ({}));
                throw new ApiError(
                    errorData.message || `HTTP ${modifiedResponse.status}`,
                    modifiedResponse.status,
                    errorData
                );
            }
            
            // Parse response
            const contentType = modifiedResponse.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                return await modifiedResponse.json();
            }
            return await modifiedResponse.text();
            
        } catch (error) {
            if (error instanceof ApiError) {
                throw error;
            }
            throw new ApiError('Network error', 0, { originalError: error });
        }
    }
    
    // Convenience methods
    get(endpoint, options = {}) {
        return this.request(endpoint, { ...options, method: 'GET' });
    }
    
    post(endpoint, data, options = {}) {
        return this.request(endpoint, {
            ...options,
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
    
    put(endpoint, data, options = {}) {
        return this.request(endpoint, {
            ...options,
            method: 'PUT',
            body: JSON.stringify(data)
        });
    }
    
    delete(endpoint, options = {}) {
        return this.request(endpoint, { ...options, method: 'DELETE' });
    }
    
    // Upload file
    async upload(endpoint, file, options = {}) {
        const formData = new FormData();
        formData.append('file', file);
        
        // Add additional form fields
        if (options.fields) {
            Object.entries(options.fields).forEach(([key, value]) => {
                formData.append(key, value);
            });
        }
        
        return this.request(endpoint, {
            ...options,
            method: 'POST',
            body: formData,
            headers: {
                // Remove Content-Type header to let browser set it with boundary
                ...options.headers,
                'Content-Type': undefined
            }
        });
    }
}

// Custom error class
class ApiError extends Error {
    constructor(message, status, data) {
        super(message);
        this.name = 'ApiError';
        this.status = status;
        this.data = data;
    }
}

// Usage example
const api = new ApiService('https://api.example.com');

// Add auth interceptor
api.addRequestInterceptor(async (config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// Add error handling interceptor
api.addResponseInterceptor(async (response) => {
    if (response.status === 401) {
        // Redirect to login
        window.location.href = '/login';
    }
    return response;
});

// Use the API
async function loadUserData(userId) {
    try {
        const user = await api.get(`/users/${userId}`);
        const posts = await api.get(`/users/${userId}/posts`);
        return { user, posts };
    } catch (error) {
        if (error instanceof ApiError) {
            console.error(`API Error ${error.status}:`, error.message);
        } else {
            console.error('Unexpected error:', error);
        }
        throw error;
    }
}
```

## JavaScript Performance and Best Practices

### Memory Management and Performance

```javascript
// Avoid memory leaks
class ComponentManager {
    constructor() {
        this.eventListeners = [];
        this.intervals = [];
        this.observers = [];
    }
    
    addEventListener(element, event, handler) {
        element.addEventListener(event, handler);
        this.eventListeners.push({ element, event, handler });
    }
    
    addInterval(callback, delay) {
        const id = setInterval(callback, delay);
        this.intervals.push(id);
        return id;
    }
    
    addObserver(observer) {
        this.observers.push(observer);
    }
    
    cleanup() {
        // Remove event listeners
        this.eventListeners.forEach(({ element, event, handler }) => {
            element.removeEventListener(event, handler);
        });
        
        // Clear intervals
        this.intervals.forEach(id => clearInterval(id));
        
        // Disconnect observers
        this.observers.forEach(observer => observer.disconnect());
        
        // Clear arrays
        this.eventListeners = [];
        this.intervals = [];
        this.observers = [];
    }
}

// Debouncing and throttling
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

function throttle(func, delay) {
    let lastCall = 0;
    return function (...args) {
        const now = Date.now();
        if (now - lastCall >= delay) {
            lastCall = now;
            func.apply(this, args);
        }
    };
}

// Usage
const expensiveSearch = debounce((query) => {
    console.log('Searching for:', query);
    // Expensive search operation
}, 300);

const handleScroll = throttle(() => {
    console.log('Scroll event');
    // Handle scroll
}, 100);

// Lazy loading implementation
class LazyLoader {
    constructor(selector = '[data-lazy]') {
        this.elements = document.querySelectorAll(selector);
        this.observer = new IntersectionObserver(
            this.handleIntersection.bind(this),
            { rootMargin: '50px' }
        );
        
        this.elements.forEach(el => this.observer.observe(el));
    }
    
    handleIntersection(entries) {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                this.loadElement(entry.target);
                this.observer.unobserve(entry.target);
            }
        });
    }
    
    loadElement(element) {
        const src = element.dataset.lazy;
        if (element.tagName === 'IMG') {
            element.src = src;
        } else {
            // Load other content
            this.loadContent(element, src);
        }
        element.classList.add('loaded');
    }
    
    async loadContent(element, url) {
        try {
            const response = await fetch(url);
            const content = await response.text();
            element.innerHTML = content;
        } catch (error) {
            console.error('Failed to load content:', error);
            element.innerHTML = '<p>Failed to load content</p>';
        }
    }
}
```

### Testing JavaScript Code

```javascript
// Simple testing framework
class SimpleTest {
    constructor() {
        this.tests = [];
        this.results = { passed: 0, failed: 0 };
    }
    
    test(description, testFunction) {
        this.tests.push({ description, testFunction });
    }
    
    expect(actual) {
        return {
            toBe: (expected) => {
                if (actual === expected) {
                    return { passed: true };
                }
                return { 
                    passed: false, 
                    message: `Expected ${expected}, but got ${actual}` 
                };
            },
            
            toEqual: (expected) => {
                if (JSON.stringify(actual) === JSON.stringify(expected)) {
                    return { passed: true };
                }
                return { 
                    passed: false, 
                    message: `Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}` 
                };
            },
            
            toBeTruthy: () => {
                if (actual) {
                    return { passed: true };
                }
                return { 
                    passed: false, 
                    message: `Expected truthy value, but got ${actual}` 
                };
            }
        };
    }
    
    run() {
        console.log('Running tests...\n');
        
        this.tests.forEach(({ description, testFunction }) => {
            try {
                testFunction.call(this);
                console.log(`✅ ${description}`);
                this.results.passed++;
            } catch (error) {
                console.log(`❌ ${description}`);
                console.log(`   ${error.message}`);
                this.results.failed++;
            }
        });
        
        console.log(`\nTests completed: ${this.results.passed} passed, ${this.results.failed} failed`);
    }
    
    assert(condition, message) {
        if (!condition) {
            throw new Error(message || 'Assertion failed');
        }
    }
}

// Example usage
const test = new SimpleTest();

// Test a calculator class
class Calculator {
    add(a, b) { return a + b; }
    subtract(a, b) { return a - b; }
    multiply(a, b) { return a * b; }
    divide(a, b) {
        if (b === 0) throw new Error('Division by zero');
        return a / b;
    }
}

const calc = new Calculator();

test.test('Calculator addition', function() {
    const result = this.expect(calc.add(2, 3)).toBe(5);
    this.assert(result.passed, result.message);
});

test.test('Calculator division by zero', function() {
    try {
        calc.divide(5, 0);
        this.assert(false, 'Should have thrown an error');
    } catch (error) {
        this.assert(error.message === 'Division by zero', 'Wrong error message');
    }
});

test.run();
```

## Conclusion: Mastering JavaScript

JavaScript is the programming language that powers the modern web. Here are the key takeaways:

### Fundamental Concepts
1. **Variables and Scope** - Understanding `let`, `const`, and lexical scope
2. **Data Types** - Primitives vs. objects, type coercion
3. **Functions** - First-class citizens, closures, arrow functions
4. **Asynchronous Programming** - Promises, async/await, event loop
5. **Objects and Classes** - Prototypes, inheritance, modern class syntax

### Modern JavaScript Features
1. **ES6+ Syntax** - Destructuring, spread operator, template literals
2. **Modules** - Import/export, code organization
3. **Array Methods** - map, filter, reduce for functional programming
4. **Async/Await** - Clean asynchronous code

### Real-World Skills
1. **DOM Manipulation** - Interactive web pages
2. **Event Handling** - User interaction
3. **API Communication** - Fetch data from servers
4. **Error Handling** - Robust applications
5. **Performance Optimization** - Fast, efficient code

### Your JavaScript Learning Path

1. **Master the Fundamentals** - Variables, functions, objects, arrays
2. **Learn DOM Manipulation** - Make pages interactive
3. **Understand Asynchronous Programming** - Handle API calls and user events
4. **Practice with Projects** - Build todo apps, calculators, games
5. **Explore Frameworks** - React, Vue, Angular build on these foundations
6. **Study Modern Patterns** - Module systems, classes, async programming

### Best Practices to Remember

1. **Use `const` by default**, `let` when reassignment needed
2. **Prefer arrow functions** for short, simple functions
3. **Use async/await** instead of callback hell
4. **Handle errors gracefully** with try/catch
5. **Write semantic, readable code** with good variable names
6. **Test your code** - even simple tests catch bugs
7. **Optimize for performance** - debounce, throttle, lazy loading

JavaScript is incredibly versatile - it runs in browsers, servers (Node.js), mobile apps, and desktop applications. Master these fundamentals, and you'll be ready for any JavaScript environment or framework.

The key to mastering JavaScript is **practice**. Build projects, solve problems, and gradually increase complexity. Every professional JavaScript developer started with these same concepts. Keep coding, keep learning, and you'll be creating amazing interactive experiences in no time!

**Remember**: JavaScript is not just a programming language - it's the language of interactivity on the web. Master it, and you master the art of bringing web pages to life.
