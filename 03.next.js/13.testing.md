# Testing in Next.js with TypeScript

## Table of Contents
1. [Understanding Testing in Next.js](#understanding-testing-in-nextjs)
2. [Jest Configuration with TypeScript](#jest-configuration-with-typescript)
3. [Vitest Configuration (Modern Alternative)](#vitest-configuration-modern-alternative)
4. [Testing React Components](#testing-react-components)
5. [Testing API Routes and Server Functions](#testing-api-routes-and-server-functions)
6. [Testing State Management](#testing-state-management)
7. [E2E Testing with Playwright](#e2e-testing-with-playwright)
8. [Testing Best Practices](#testing-best-practices)

---

## Understanding Testing in Next.js

### Testing Pyramid for Next.js Applications

Next.js applications require a comprehensive testing strategy that covers both client-side and server-side functionality with complete TypeScript support.

#### Testing Levels and TypeScript Integration

```typescript
// types/testing.ts
// Test utility types for better type safety
export interface TestUser {
  id: string
  email: string
  name: string
  role: 'USER' | 'ADMIN' | 'MODERATOR'
}

export interface MockApiResponse<T> {
  data: T
  status: number
  message?: string
}

export interface ComponentTestProps {
  user?: TestUser
  theme?: 'light' | 'dark'
  isLoading?: boolean
}

// Custom render options for testing
export interface CustomRenderOptions {
  initialState?: any
  user?: TestUser
  route?: string
  locale?: string
}

// Test environment types
export interface TestEnvironment {
  NODE_ENV: 'test'
  NEXT_PUBLIC_API_URL: string
  DATABASE_URL?: string
  JWT_SECRET: string
}

// Mock function types
export type MockedFunction<T extends (...args: any[]) => any> = jest.MockedFunction<T>
export type MockedClass<T> = jest.MockedClass<T>
```

#### Testing Architecture Overview

```typescript
// __tests__/setup/test-architecture.ts
/**
 * Testing Architecture for Next.js TypeScript Applications
 * 
 * 1. Unit Tests (70%)
 *    - Individual functions and components
 *    - TypeScript type checking
 *    - Isolated business logic
 * 
 * 2. Integration Tests (20%)
 *    - Component interactions
 *    - API route testing
 *    - Database integration
 * 
 * 3. End-to-End Tests (10%)
 *    - Full user workflows
 *    - Cross-browser testing
 *    - Performance testing
 */

export const TEST_CATEGORIES = {
  UNIT: {
    components: 'Testing individual React components',
    hooks: 'Testing custom hooks with TypeScript',
    utils: 'Testing utility functions and helpers',
    types: 'Testing TypeScript type definitions'
  },
  INTEGRATION: {
    api: 'Testing API routes and middleware',
    database: 'Testing database operations',
    auth: 'Testing authentication flows',
    state: 'Testing state management integration'
  },
  E2E: {
    flows: 'Testing complete user workflows',
    performance: 'Testing application performance',
    accessibility: 'Testing accessibility compliance',
    cross_browser: 'Testing browser compatibility'
  }
} as const
```

---

## Jest Configuration with TypeScript

### Complete Jest Setup with ts-jest

```typescript
// jest.config.js
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files
  dir: './',
})

// Add any custom config to be passed to Jest
const customJestConfig = {
  // Setup files
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  
  // Module name mapping for absolute imports
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@/components/(.*)$': '<rootDir>/src/components/$1',
    '^@/lib/(.*)$': '<rootDir>/src/lib/$1',
    '^@/hooks/(.*)$': '<rootDir>/src/hooks/$1',
    '^@/types/(.*)$': '<rootDir>/src/types/$1',
    '^@/utils/(.*)$': '<rootDir>/src/utils/$1',
    
    // Mock static assets
    '^.+\\.(svg|png|jpg|jpeg|gif|webp|avif|ico|bmp)$': '<rootDir>/__mocks__/fileMock.js',
    '^.+\\.(css|sass|scss)$': 'identity-obj-proxy',
  },
  
  // Test environment
  testEnvironment: 'jest-environment-jsdom',
  
  // TypeScript support
  preset: 'ts-jest',
  extensionsToTreatAsEsm: ['.ts', '.tsx'],
  globals: {
    'ts-jest': {
      useESM: true,
      tsconfig: {
        jsx: 'react-jsx',
      },
    },
  },
  
  // Test patterns
  testMatch: [
    '**/__tests__/**/*.(ts|tsx|js)',
    '**/*.(test|spec).(ts|tsx|js)',
  ],
  
  // Coverage configuration
  collectCoverage: true,
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{ts,tsx}',
    '!src/**/*.config.{ts,js}',
    '!src/**/index.{ts,tsx}',
  ],
  coverageReporters: ['text', 'lcov', 'html'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  
  // Transform configuration
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', {
      tsconfig: 'tsconfig.json',
    }],
  },
  
  // Module file extensions
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  
  // Test timeout
  testTimeout: 30000,
  
  // Clear mocks between tests
  clearMocks: true,
  restoreMocks: true,
}

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig)
```

#### Jest Setup File

```typescript
// jest.setup.js
import '@testing-library/jest-dom'
import { configure } from '@testing-library/react'
import { server } from './__mocks__/server'

// Configure testing library
configure({ testIdAttribute: 'data-testid' })

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  constructor() {}
  observe() { return null }
  disconnect() { return null }
  unobserve() { return null }
}

// Mock ResizeObserver
global.ResizeObserver = class ResizeObserver {
  constructor() {}
  observe() { return null }
  disconnect() { return null }
  unobserve() { return null }
}

// Mock matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(), // deprecated
    removeListener: jest.fn(), // deprecated
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
})

// Mock Next.js router
jest.mock('next/router', () => ({
  useRouter() {
    return {
      route: '/',
      pathname: '/',
      query: {},
      asPath: '/',
      push: jest.fn(),
      pop: jest.fn(),
      reload: jest.fn(),
      back: jest.fn(),
      prefetch: jest.fn().mockResolvedValue(undefined),
      beforePopState: jest.fn(),
      events: {
        on: jest.fn(),
        off: jest.fn(),
        emit: jest.fn(),
      },
      isFallback: false,
      isLocaleDomain: true,
      isReady: true,
      isPreview: false,
    }
  },
}))

// Mock Next.js navigation (App Router)
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      refresh: jest.fn(),
      back: jest.fn(),
      forward: jest.fn(),
      prefetch: jest.fn(),
    }
  },
  useSearchParams() {
    return new URLSearchParams()
  },
  usePathname() {
    return '/'
  },
}))

// Start MSW server before all tests
beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))

// Reset handlers after each test
afterEach(() => server.resetHandlers())

// Clean up after tests
afterAll(() => server.close())

// Mock environment variables
process.env = {
  ...process.env,
  NODE_ENV: 'test',
  NEXT_PUBLIC_API_URL: 'http://localhost:3000/api',
  JWT_SECRET: 'test-secret-key',
}
```

#### TypeScript Test Utilities

```typescript
// __tests__/utils/test-utils.tsx
import React, { ReactElement } from 'react'
import { render, RenderOptions, RenderResult } from '@testing-library/react'
import { ThemeProvider } from 'next-themes'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { Provider } from 'react-redux'
import { configureStore } from '@reduxjs/toolkit'
import userEvent from '@testing-library/user-event'

import { CustomRenderOptions, TestUser } from '@/types/testing'

// Mock store for testing
const createMockStore = (initialState?: any) => {
  return configureStore({
    reducer: {
      auth: (state = { user: null, isAuthenticated: false }, action) => state,
      ui: (state = { theme: 'light' }, action) => state,
      // Add other reducers as needed
    },
    preloadedState: initialState,
  })
}

// Test wrapper component
interface TestWrapperProps {
  children: React.ReactNode
  initialState?: any
  user?: TestUser
  queryClient?: QueryClient
}

const TestWrapper: React.FC<TestWrapperProps> = ({
  children,
  initialState,
  user,
  queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  }),
}) => {
  const store = createMockStore(initialState)

  return (
    <Provider store={store}>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider attribute="class" defaultTheme="light">
          {children}
        </ThemeProvider>
      </QueryClientProvider>
    </Provider>
  )
}

// Custom render function with TypeScript support
const customRender = (
  ui: ReactElement,
  options: CustomRenderOptions & Omit<RenderOptions, 'wrapper'> = {}
): RenderResult & { user: ReturnType<typeof userEvent.setup> } => {
  const { initialState, user: testUser, ...renderOptions } = options

  const Wrapper = ({ children }: { children: React.ReactNode }) => (
    <TestWrapper initialState={initialState} user={testUser}>
      {children}
    </TestWrapper>
  )

  const result = render(ui, { wrapper: Wrapper, ...renderOptions })
  
  return {
    ...result,
    user: userEvent.setup(),
  }
}

// Mock data factories with TypeScript
export const createMockUser = (overrides: Partial<TestUser> = {}): TestUser => ({
  id: 'test-user-1',
  email: 'test@example.com',
  name: 'Test User',
  role: 'USER',
  ...overrides,
})

export const createMockPost = (overrides: Partial<any> = {}) => ({
  id: 'test-post-1',
  title: 'Test Post',
  content: 'This is a test post content',
  authorId: 'test-user-1',
  published: true,
  createdAt: new Date().toISOString(),
  ...overrides,
})

// Async testing utilities
export const waitForLoadingToFinish = async () => {
  const { findByTestId } = customRender(<div data-testid="loading" />)
  await expect(findByTestId('loading')).resolves.toBeInTheDocument()
}

// Form testing utilities
export const fillForm = async (
  user: ReturnType<typeof userEvent.setup>,
  formData: Record<string, string>
) => {
  for (const [field, value] of Object.entries(formData)) {
    const input = document.querySelector(`[name="${field}"]`) as HTMLInputElement
    if (input) {
      await user.clear(input)
      await user.type(input, value)
    }
  }
}

// API response helpers
export const createMockApiResponse = <T>(
  data: T,
  status = 200,
  message?: string
) => ({
  data,
  status,
  message,
  ok: status >= 200 && status < 300,
  json: () => Promise.resolve({ data, message }),
})

// Re-export everything
export * from '@testing-library/react'
export { default as userEvent } from '@testing-library/user-event'
export { customRender as render }
```

---

## Vitest Configuration (Modern Alternative)

### Complete Vitest Setup with Native TypeScript Support

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  
  test: {
    // Test environment
    environment: 'jsdom',
    
    // Setup files
    setupFiles: ['./vitest.setup.ts'],
    
    // Global test configuration
    globals: true,
    
    // Test patterns
    include: [
      '**/__tests__/**/*.{test,spec}.{ts,tsx}',
      '**/*.{test,spec}.{ts,tsx}',
    ],
    exclude: [
      'node_modules/**',
      'dist/**',
      '.next/**',
      'e2e/**',
    ],
    
    // Coverage configuration
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        '__tests__/',
        '**/*.d.ts',
        '**/*.config.{ts,js}',
        '**/index.{ts,tsx}',
        '**/*.stories.{ts,tsx}',
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80,
        },
      },
    },
    
    // Test timeout
    testTimeout: 20000,
    
    // Mock configuration
    clearMocks: true,
    restoreMocks: true,
    
    // Parallel execution
    threads: true,
    maxThreads: 4,
  },
  
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@/components': path.resolve(__dirname, './src/components'),
      '@/lib': path.resolve(__dirname, './src/lib'),
      '@/hooks': path.resolve(__dirname, './src/hooks'),
      '@/types': path.resolve(__dirname, './src/types'),
      '@/utils': path.resolve(__dirname, './src/utils'),
    },
  },
  
  define: {
    'process.env': process.env,
  },
})
```

#### Vitest Setup File

```typescript
// vitest.setup.ts
import '@testing-library/jest-dom/vitest'
import { beforeAll, afterEach, afterAll, vi } from 'vitest'
import { cleanup } from '@testing-library/react'
import { server } from './__mocks__/server'

// Configure testing environment
beforeAll(() => {
  // Start MSW server
  server.listen({ onUnhandledRequest: 'error' })
  
  // Mock global objects
  Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: vi.fn().mockImplementation(query => ({
      matches: false,
      media: query,
      onchange: null,
      addListener: vi.fn(),
      removeListener: vi.fn(),
      addEventListener: vi.fn(),
      removeEventListener: vi.fn(),
      dispatchEvent: vi.fn(),
    })),
  })
  
  global.IntersectionObserver = vi.fn().mockImplementation(() => ({
    observe: vi.fn(),
    unobserve: vi.fn(),
    disconnect: vi.fn(),
  }))
  
  global.ResizeObserver = vi.fn().mockImplementation(() => ({
    observe: vi.fn(),
    unobserve: vi.fn(),
    disconnect: vi.fn(),
  }))
})

afterEach(() => {
  // Clean up after each test
  cleanup()
  server.resetHandlers()
  vi.clearAllMocks()
})

afterAll(() => {
  // Clean up after all tests
  server.close()
})

// Mock Next.js modules
vi.mock('next/router', () => ({
  useRouter: () => ({
    route: '/',
    pathname: '/',
    query: {},
    asPath: '/',
    push: vi.fn(),
    pop: vi.fn(),
    reload: vi.fn(),
    back: vi.fn(),
    prefetch: vi.fn().mockResolvedValue(undefined),
    beforePopState: vi.fn(),
    events: {
      on: vi.fn(),
      off: vi.fn(),
      emit: vi.fn(),
    },
    isFallback: false,
    isLocaleDomain: true,
    isReady: true,
    isPreview: false,
  }),
}))

vi.mock('next/navigation', () => ({
  useRouter: () => ({
    push: vi.fn(),
    replace: vi.fn(),
    refresh: vi.fn(),
    back: vi.fn(),
    forward: vi.fn(),
    prefetch: vi.fn(),
  }),
  useSearchParams: () => new URLSearchParams(),
  usePathname: () => '/',
}))
```

---

## Testing React Components

### Unit Testing Components with TypeScript

```typescript
// __tests__/components/UserProfile.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { UserProfile } from '@/components/UserProfile'
import { createMockUser } from '../utils/test-utils'
import type { TestUser } from '@/types/testing'

// Type-safe component props for testing
interface UserProfileProps {
  user: TestUser
  onUpdate?: (user: TestUser) => void
  onDelete?: (userId: string) => void
  isEditable?: boolean
}

describe('UserProfile Component', () => {
  const mockUser = createMockUser({
    name: 'John Doe',
    email: 'john@example.com',
    role: 'USER',
  })

  const defaultProps: UserProfileProps = {
    user: mockUser,
    isEditable: true,
  }

  const mockOnUpdate = vi.fn()
  const mockOnDelete = vi.fn()

  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('Rendering', () => {
    it('should render user information correctly', () => {
      render(<UserProfile {...defaultProps} />)

      expect(screen.getByText('John Doe')).toBeInTheDocument()
      expect(screen.getByText('john@example.com')).toBeInTheDocument()
      expect(screen.getByText('USER')).toBeInTheDocument()
    })

    it('should show edit button when editable', () => {
      render(<UserProfile {...defaultProps} />)
      
      expect(screen.getByRole('button', { name: /edit/i })).toBeInTheDocument()
    })

    it('should not show edit button when not editable', () => {
      render(<UserProfile {...defaultProps} isEditable={false} />)
      
      expect(screen.queryByRole('button', { name: /edit/i })).not.toBeInTheDocument()
    })

    it('should apply correct role-based styling', () => {
      const adminUser = createMockUser({ role: 'ADMIN' })
      render(<UserProfile user={adminUser} />)
      
      const roleElement = screen.getByTestId('user-role')
      expect(roleElement).toHaveClass('role-admin')
    })
  })

  describe('User Interactions', () => {
    it('should open edit modal when edit button is clicked', async () => {
      const user = userEvent.setup()
      render(<UserProfile {...defaultProps} />)

      const editButton = screen.getByRole('button', { name: /edit/i })
      await user.click(editButton)

      expect(screen.getByRole('dialog')).toBeInTheDocument()
      expect(screen.getByLabelText(/name/i)).toHaveValue('John Doe')
      expect(screen.getByLabelText(/email/i)).toHaveValue('john@example.com')
    })

    it('should call onUpdate when form is submitted with valid data', async () => {
      const user = userEvent.setup()
      render(<UserProfile {...defaultProps} onUpdate={mockOnUpdate} />)

      // Open edit modal
      await user.click(screen.getByRole('button', { name: /edit/i }))

      // Update name
      const nameInput = screen.getByLabelText(/name/i)
      await user.clear(nameInput)
      await user.type(nameInput, 'Jane Doe')

      // Submit form
      await user.click(screen.getByRole('button', { name: /save/i }))

      await waitFor(() => {
        expect(mockOnUpdate).toHaveBeenCalledWith({
          ...mockUser,
          name: 'Jane Doe',
        })
      })
    })

    it('should show validation errors for invalid email', async () => {
      const user = userEvent.setup()
      render(<UserProfile {...defaultProps} />)

      await user.click(screen.getByRole('button', { name: /edit/i }))

      const emailInput = screen.getByLabelText(/email/i)
      await user.clear(emailInput)
      await user.type(emailInput, 'invalid-email')

      await user.click(screen.getByRole('button', { name: /save/i }))

      expect(screen.getByText(/invalid email format/i)).toBeInTheDocument()
      expect(mockOnUpdate).not.toHaveBeenCalled()
    })

    it('should handle delete confirmation flow', async () => {
      const user = userEvent.setup()
      render(<UserProfile {...defaultProps} onDelete={mockOnDelete} />)

      // Click delete button
      await user.click(screen.getByRole('button', { name: /delete/i }))

      // Confirm deletion in modal
      expect(screen.getByText(/are you sure/i)).toBeInTheDocument()
      await user.click(screen.getByRole('button', { name: /confirm/i }))

      expect(mockOnDelete).toHaveBeenCalledWith(mockUser.id)
    })
  })

  describe('Accessibility', () => {
    it('should have proper ARIA labels', () => {
      render(<UserProfile {...defaultProps} />)

      expect(screen.getByRole('region', { name: /user profile/i })).toBeInTheDocument()
      expect(screen.getByLabelText(/user information/i)).toBeInTheDocument()
    })

    it('should support keyboard navigation', async () => {
      const user = userEvent.setup()
      render(<UserProfile {...defaultProps} />)

      const editButton = screen.getByRole('button', { name: /edit/i })
      
      // Tab to button and press Enter
      await user.tab()
      expect(editButton).toHaveFocus()
      
      await user.keyboard('{Enter}')
      expect(screen.getByRole('dialog')).toBeInTheDocument()
    })
  })

  describe('Error Handling', () => {
    it('should display error message when update fails', async () => {
      const user = userEvent.setup()
      const failingUpdate = vi.fn().mockRejectedValue(new Error('Update failed'))
      
      render(<UserProfile {...defaultProps} onUpdate={failingUpdate} />)

      await user.click(screen.getByRole('button', { name: /edit/i }))
      await user.click(screen.getByRole('button', { name: /save/i }))

      await waitFor(() => {
        expect(screen.getByText(/update failed/i)).toBeInTheDocument()
      })
    })

    it('should handle network errors gracefully', async () => {
      const user = userEvent.setup()
      const networkError = vi.fn().mockRejectedValue(new Error('Network error'))
      
      render(<UserProfile {...defaultProps} onUpdate={networkError} />)

      await user.click(screen.getByRole('button', { name: /edit/i }))
      await user.click(screen.getByRole('button', { name: /save/i }))

      await waitFor(() => {
        expect(screen.getByText(/network error/i)).toBeInTheDocument()
      })
    })
  })
})
```

### Testing Custom Hooks with TypeScript

```typescript
// __tests__/hooks/useAuth.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { renderHook, waitFor } from '@testing-library/react'
import { useAuth } from '@/hooks/useAuth'
import { createMockUser } from '../utils/test-utils'
import type { TestUser } from '@/types/testing'

// Mock the auth context
const mockAuthContext = {
  user: null as TestUser | null,
  isAuthenticated: false,
  isLoading: false,
  login: vi.fn(),
  logout: vi.fn(),
  updateProfile: vi.fn(),
}

vi.mock('@/contexts/AuthContext', () => ({
  useAuthContext: () => mockAuthContext,
}))

describe('useAuth Hook', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    mockAuthContext.user = null
    mockAuthContext.isAuthenticated = false
    mockAuthContext.isLoading = false
  })

  describe('Authentication State', () => {
    it('should return initial unauthenticated state', () => {
      const { result } = renderHook(() => useAuth())

      expect(result.current.user).toBeNull()
      expect(result.current.isAuthenticated).toBe(false)
      expect(result.current.isLoading).toBe(false)
    })

    it('should return authenticated state when user is logged in', () => {
      const mockUser = createMockUser()
      mockAuthContext.user = mockUser
      mockAuthContext.isAuthenticated = true

      const { result } = renderHook(() => useAuth())

      expect(result.current.user).toEqual(mockUser)
      expect(result.current.isAuthenticated).toBe(true)
    })

    it('should return loading state during authentication', () => {
      mockAuthContext.isLoading = true

      const { result } = renderHook(() => useAuth())

      expect(result.current.isLoading).toBe(true)
    })
  })

  describe('Authentication Actions', () => {
    it('should call login with correct parameters', async () => {
      const { result } = renderHook(() => useAuth())

      await result.current.login('test@example.com', 'password123')

      expect(mockAuthContext.login).toHaveBeenCalledWith('test@example.com', 'password123')
    })

    it('should handle login success', async () => {
      const mockUser = createMockUser()
      mockAuthContext.login.mockResolvedValue(mockUser)

      const { result } = renderHook(() => useAuth())

      const user = await result.current.login('test@example.com', 'password123')

      expect(user).toEqual(mockUser)
    })

    it('should handle login failure', async () => {
      const loginError = new Error('Invalid credentials')
      mockAuthContext.login.mockRejectedValue(loginError)

      const { result } = renderHook(() => useAuth())

      await expect(result.current.login('test@example.com', 'wrong')).rejects.toThrow(
        'Invalid credentials'
      )
    })

    it('should call logout', async () => {
      const { result } = renderHook(() => useAuth())

      await result.current.logout()

      expect(mockAuthContext.logout).toHaveBeenCalled()
    })
  })

  describe('Profile Management', () => {
    it('should update user profile', async () => {
      const mockUser = createMockUser()
      mockAuthContext.user = mockUser
      mockAuthContext.isAuthenticated = true

      const { result } = renderHook(() => useAuth())

      const updates = { name: 'Updated Name' }
      await result.current.updateProfile(updates)

      expect(mockAuthContext.updateProfile).toHaveBeenCalledWith(updates)
    })

    it('should throw error when updating profile without authentication', async () => {
      const { result } = renderHook(() => useAuth())

      await expect(result.current.updateProfile({ name: 'New Name' })).rejects.toThrow(
        'Not authenticated'
      )
    })
  })

  describe('Computed Properties', () => {
    it('should return correct user role', () => {
      const adminUser = createMockUser({ role: 'ADMIN' })
      mockAuthContext.user = adminUser
      mockAuthContext.isAuthenticated = true

      const { result } = renderHook(() => useAuth())

      expect(result.current.userRole).toBe('ADMIN')
    })

    it('should check permissions correctly', () => {
      const adminUser = createMockUser({ role: 'ADMIN' })
      mockAuthContext.user = adminUser
      mockAuthContext.isAuthenticated = true

      const { result } = renderHook(() => useAuth())

      expect(result.current.hasPermission('DELETE_USER')).toBe(true)
      expect(result.current.hasPermission('SUPER_ADMIN')).toBe(false)
    })

    it('should return false for permissions when not authenticated', () => {
      const { result } = renderHook(() => useAuth())

      expect(result.current.hasPermission('READ')).toBe(false)
    })
  })
})
```

---

## Testing API Routes and Server Functions

### Testing Next.js API Routes

```typescript
// __tests__/api/users.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { createMocks } from 'node-mocks-http'
import { NextApiRequest, NextApiResponse } from 'next'
import handler from '@/pages/api/users'
import { connectToDatabase, disconnectFromDatabase } from '@/lib/database'
import { createMockUser } from '../utils/test-utils'
import type { TestUser } from '@/types/testing'

// Type for API response
interface ApiResponse<T = any> {
  success: boolean
  data?: T
  error?: string
  message?: string
}

describe('/api/users', () => {
  beforeEach(async () => {
    await connectToDatabase()
  })

  afterEach(async () => {
    await disconnectFromDatabase()
  })

  describe('GET /api/users', () => {
    it('should return list of users for authenticated admin', async () => {
      const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
        method: 'GET',
        headers: {
          authorization: 'Bearer admin-token',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(200)
      
      const data: ApiResponse<TestUser[]> = JSON.parse(res._getData())
      expect(data.success).toBe(true)
      expect(Array.isArray(data.data)).toBe(true)
      expect(data.data?.length).toBeGreaterThan(0)
    })

    it('should return 401 for unauthenticated requests', async () => {
      const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
        method: 'GET',
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(401)
      
      const data: ApiResponse = JSON.parse(res._getData())
      expect(data.success).toBe(false)
      expect(data.error).toBe('Unauthorized')
    })

    it('should return 403 for non-admin users', async () => {
      const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
        method: 'GET',
        headers: {
          authorization: 'Bearer user-token',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(403)
      
      const data: ApiResponse = JSON.parse(res._getData())
      expect(data.success).toBe(false)
      expect(data.error).toBe('Insufficient permissions')
    })

    it('should handle pagination parameters', async () => {
      const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
        method: 'GET',
        query: {
          page: '2',
          limit: '5',
        },
        headers: {
          authorization: 'Bearer admin-token',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(200)
      
      const data = JSON.parse(res._getData())
      expect(data.pagination).toBeDefined()
      expect(data.pagination.page).toBe(2)
      expect(data.pagination.limit).toBe(5)
    })
  })

  describe('POST /api/users', () => {
    it('should create new user with valid data', async () => {
      const newUser = {
        name: 'New User',
        email: 'new@example.com',
        role: 'USER',
      }

      const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
        method: 'POST',
        body: newUser,
        headers: {
          authorization: 'Bearer admin-token',
          'content-type': 'application/json',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(201)
      
      const data: ApiResponse<TestUser> = JSON.parse(res._getData())
      expect(data.success).toBe(true)
      expect(data.data?.name).toBe(newUser.name)
      expect(data.data?.email).toBe(newUser.email)
      expect(data.data?.id).toBeDefined()
    })

    it('should validate required fields', async () => {
      const invalidUser = {
        name: 'User without email',
      }

      const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
        method: 'POST',
        body: invalidUser,
        headers: {
          authorization: 'Bearer admin-token',
          'content-type': 'application/json',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(400)
      
      const data: ApiResponse = JSON.parse(res._getData())
      expect(data.success).toBe(false)
      expect(data.error).toContain('email is required')
    })

    it('should prevent duplicate email addresses', async () => {
      const duplicateUser = {
        name: 'Duplicate User',
        email: 'existing@example.com', // Assuming this exists
        role: 'USER',
      }

      const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
        method: 'POST',
        body: duplicateUser,
        headers: {
          authorization: 'Bearer admin-token',
          'content-type': 'application/json',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(409)
      
      const data: ApiResponse = JSON.parse(res._getData())
      expect(data.success).toBe(false)
      expect(data.error).toContain('Email already exists')
    })
  })

  describe('Method Not Allowed', () => {
    it('should return 405 for unsupported methods', async () => {
      const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
        method: 'DELETE',
        headers: {
          authorization: 'Bearer admin-token',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(405)
      
      const data: ApiResponse = JSON.parse(res._getData())
      expect(data.success).toBe(false)
      expect(data.error).toBe('Method not allowed')
    })
  })

  describe('Error Handling', () => {
    it('should handle database connection errors', async () => {
      // Mock database connection failure
      vi.mocked(connectToDatabase).mockRejectedValue(new Error('Database connection failed'))

      const { req, res } = createMocks<NextApiRequest, NextApiResponse>({
        method: 'GET',
        headers: {
          authorization: 'Bearer admin-token',
        },
      })

      await handler(req, res)

      expect(res._getStatusCode()).toBe(500)
      
      const data: ApiResponse = JSON.parse(res._getData())
      expect(data.success).toBe(false)
      expect(data.error).toContain('Internal server error')
    })
  })
})
```

### Testing Server Actions (App Router)

```typescript
// __tests__/actions/user-actions.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { createUser, updateUser, deleteUser } from '@/app/actions/user-actions'
import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'
import { createMockUser } from '../utils/test-utils'

// Mock Next.js functions
vi.mock('next/navigation', () => ({
  redirect: vi.fn(),
}))

vi.mock('next/cache', () => ({
  revalidatePath: vi.fn(),
}))

// Mock database
vi.mock('@/lib/database', () => ({
  prisma: {
    user: {
      create: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
      findUnique: vi.fn(),
    },
  },
}))

import { prisma } from '@/lib/database'

describe('User Actions', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('createUser', () => {
    it('should create user and redirect on success', async () => {
      const mockUser = createMockUser()
      vi.mocked(prisma.user.create).mockResolvedValue(mockUser)

      const formData = new FormData()
      formData.append('name', 'John Doe')
      formData.append('email', 'john@example.com')
      formData.append('role', 'USER')

      await createUser(formData)

      expect(prisma.user.create).toHaveBeenCalledWith({
        data: {
          name: 'John Doe',
          email: 'john@example.com',
          role: 'USER',
        },
      })

      expect(revalidatePath).toHaveBeenCalledWith('/users')
      expect(redirect).toHaveBeenCalledWith('/users')
    })

    it('should handle validation errors', async () => {
      const formData = new FormData()
      formData.append('name', '') // Invalid: empty name
      formData.append('email', 'invalid-email') // Invalid: malformed email

      const result = await createUser(formData)

      expect(result).toEqual({
        success: false,
        errors: {
          name: ['Name is required'],
          email: ['Invalid email format'],
        },
      })

      expect(prisma.user.create).not.toHaveBeenCalled()
      expect(redirect).not.toHaveBeenCalled()
    })

    it('should handle database errors', async () => {
      vi.mocked(prisma.user.create).mockRejectedValue(new Error('Database error'))

      const formData = new FormData()
      formData.append('name', 'John Doe')
      formData.append('email', 'john@example.com')
      formData.append('role', 'USER')

      const result = await createUser(formData)

      expect(result).toEqual({
        success: false,
        error: 'Failed to create user',
      })
    })
  })

  describe('updateUser', () => {
    it('should update user successfully', async () => {
      const mockUser = createMockUser({ name: 'Updated Name' })
      vi.mocked(prisma.user.update).mockResolvedValue(mockUser)

      const formData = new FormData()
      formData.append('id', 'user-1')
      formData.append('name', 'Updated Name')
      formData.append('email', 'updated@example.com')

      const result = await updateUser(formData)

      expect(prisma.user.update).toHaveBeenCalledWith({
        where: { id: 'user-1' },
        data: {
          name: 'Updated Name',
          email: 'updated@example.com',
        },
      })

      expect(result).toEqual({
        success: true,
        data: mockUser,
      })

      expect(revalidatePath).toHaveBeenCalledWith('/users')
    })

    it('should handle user not found', async () => {
      vi.mocked(prisma.user.update).mockRejectedValue(
        new Error('Record to update not found')
      )

      const formData = new FormData()
      formData.append('id', 'nonexistent-id')
      formData.append('name', 'Updated Name')

      const result = await updateUser(formData)

      expect(result).toEqual({
        success: false,
        error: 'User not found',
      })
    })
  })

  describe('deleteUser', () => {
    it('should delete user successfully', async () => {
      vi.mocked(prisma.user.delete).mockResolvedValue(createMockUser())

      const result = await deleteUser('user-1')

      expect(prisma.user.delete).toHaveBeenCalledWith({
        where: { id: 'user-1' },
      })

      expect(result).toEqual({
        success: true,
      })

      expect(revalidatePath).toHaveBeenCalledWith('/users')
    })

    it('should handle delete errors', async () => {
      vi.mocked(prisma.user.delete).mockRejectedValue(
        new Error('Record to delete does not exist')
      )

      const result = await deleteUser('nonexistent-id')

      expect(result).toEqual({
        success: false,
        error: 'User not found',
      })
    })
  })
})
```

---

## Testing State Management

### Testing Zustand Stores

```typescript
// __tests__/stores/auth-store.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { renderHook, act } from '@testing-library/react'
import { useAuthStore } from '@/stores/auth-store'
import { createMockUser } from '../utils/test-utils'

// Mock fetch
global.fetch = vi.fn()

describe('Auth Store', () => {
  beforeEach(() => {
    // Reset store before each test
    useAuthStore.getState().logout()
    vi.clearAllMocks()
  })

  describe('Initial State', () => {
    it('should have correct initial state', () => {
      const { result } = renderHook(() => useAuthStore())

      expect(result.current.user).toBeNull()
      expect(result.current.isAuthenticated).toBe(false)
      expect(result.current.isLoading).toBe(false)
      expect(result.current.error).toBeNull()
    })
  })

  describe('Login', () => {
    it('should handle successful login', async () => {
      const mockUser = createMockUser()
      vi.mocked(fetch).mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockUser),
      } as Response)

      const { result } = renderHook(() => useAuthStore())

      await act(async () => {
        await result.current.login('test@example.com', 'password123')
      })

      expect(result.current.user).toEqual(mockUser)
      expect(result.current.isAuthenticated).toBe(true)
      expect(result.current.isLoading).toBe(false)
      expect(result.current.error).toBeNull()
    })

    it('should handle login failure', async () => {
      vi.mocked(fetch).mockResolvedValueOnce({
        ok: false,
        status: 401,
      } as Response)

      const { result } = renderHook(() => useAuthStore())

      await act(async () => {
        await result.current.login('test@example.com', 'wrongpassword')
      })

      expect(result.current.user).toBeNull()
      expect(result.current.isAuthenticated).toBe(false)
      expect(result.current.isLoading).toBe(false)
      expect(result.current.error).toBe('Login failed')
    })

    it('should set loading state during login', async () => {
      // Create a promise that we can control
      let resolveLogin: (value: any) => void
      const loginPromise = new Promise((resolve) => {
        resolveLogin = resolve
      })

      vi.mocked(fetch).mockReturnValueOnce(loginPromise as any)

      const { result } = renderHook(() => useAuthStore())

      // Start login
      act(() => {
        result.current.login('test@example.com', 'password123')
      })

      // Check loading state
      expect(result.current.isLoading).toBe(true)

      // Resolve login
      await act(async () => {
        resolveLogin!({
          ok: true,
          json: () => Promise.resolve(createMockUser()),
        })
        await loginPromise
      })

      expect(result.current.isLoading).toBe(false)
    })
  })

  describe('Logout', () => {
    it('should clear user data on logout', async () => {
      const { result } = renderHook(() => useAuthStore())

      // First login
      const mockUser = createMockUser()
      act(() => {
        useAuthStore.setState({
          user: mockUser,
          isAuthenticated: true,
        })
      })

      // Then logout
      act(() => {
        result.current.logout()
      })

      expect(result.current.user).toBeNull()
      expect(result.current.isAuthenticated).toBe(false)
      expect(result.current.error).toBeNull()
    })
  })

  describe('Computed Values', () => {
    it('should return correct user role', () => {
      const { result } = renderHook(() => useAuthStore())

      // Set admin user
      act(() => {
        useAuthStore.setState({
          user: createMockUser({ role: 'ADMIN' }),
          isAuthenticated: true,
        })
      })

      expect(result.current.getUserRole()).toBe('ADMIN')
    })

    it('should check permissions correctly', () => {
      const { result } = renderHook(() => useAuthStore())

      // Set admin user
      act(() => {
        useAuthStore.setState({
          user: createMockUser({ role: 'ADMIN' }),
          isAuthenticated: true,
        })
      })

      expect(result.current.hasPermission('delete')).toBe(true)

      // Set regular user
      act(() => {
        useAuthStore.setState({
          user: createMockUser({ role: 'USER' }),
          isAuthenticated: true,
        })
      })

      expect(result.current.hasPermission('delete')).toBe(false)
    })
  })

  describe('Store Subscriptions', () => {
    it('should notify subscribers on state changes', () => {
      let subscriberCallCount = 0
      
      const unsubscribe = useAuthStore.subscribe(
        (state) => state.isAuthenticated,
        (isAuthenticated) => {
          subscriberCallCount++
        }
      )

      // Change authentication state
      act(() => {
        useAuthStore.setState({ isAuthenticated: true })
      })

      expect(subscriberCallCount).toBe(1)

      unsubscribe()
    })
  })
})
```

---

## E2E Testing with Playwright

### Playwright Configuration for Next.js

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }],
  ],
  
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
  ],

  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
})
```

#### End-to-End Test Examples

```typescript
// e2e/auth.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Authentication Flow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/')
  })

  test('should login with valid credentials', async ({ page }) => {
    // Navigate to login page
    await page.click('[data-testid="login-button"]')
    await expect(page).toHaveURL('/login')

    // Fill login form
    await page.fill('[data-testid="email-input"]', 'test@example.com')
    await page.fill('[data-testid="password-input"]', 'password123')
    
    // Submit form
    await page.click('[data-testid="submit-button"]')

    // Check successful login
    await expect(page).toHaveURL('/dashboard')
    await expect(page.locator('[data-testid="user-menu"]')).toBeVisible()
    await expect(page.locator('text=Welcome back')).toBeVisible()
  })

  test('should show error for invalid credentials', async ({ page }) => {
    await page.click('[data-testid="login-button"]')
    
    await page.fill('[data-testid="email-input"]', 'test@example.com')
    await page.fill('[data-testid="password-input"]', 'wrongpassword')
    
    await page.click('[data-testid="submit-button"]')

    // Check error message
    await expect(page.locator('[data-testid="error-message"]')).toContainText(
      'Invalid credentials'
    )
    await expect(page).toHaveURL('/login')
  })

  test('should logout successfully', async ({ page }) => {
    // Login first
    await page.goto('/login')
    await page.fill('[data-testid="email-input"]', 'test@example.com')
    await page.fill('[data-testid="password-input"]', 'password123')
    await page.click('[data-testid="submit-button"]')
    
    await expect(page).toHaveURL('/dashboard')

    // Logout
    await page.click('[data-testid="user-menu"]')
    await page.click('[data-testid="logout-button"]')

    // Check redirect to home
    await expect(page).toHaveURL('/')
    await expect(page.locator('[data-testid="login-button"]')).toBeVisible()
  })

  test('should protect authenticated routes', async ({ page }) => {
    // Try to access protected route without authentication
    await page.goto('/dashboard')

    // Should redirect to login
    await expect(page).toHaveURL('/login')
    await expect(page.locator('text=Please log in to continue')).toBeVisible()
  })
})

test.describe('User Profile Management', () => {
  test.beforeEach(async ({ page }) => {
    // Login before each test
    await page.goto('/login')
    await page.fill('[data-testid="email-input"]', 'test@example.com')
    await page.fill('[data-testid="password-input"]', 'password123')
    await page.click('[data-testid="submit-button"]')
    await expect(page).toHaveURL('/dashboard')
  })

  test('should update user profile', async ({ page }) => {
    // Navigate to profile page
    await page.click('[data-testid="user-menu"]')
    await page.click('[data-testid="profile-link"]')
    await expect(page).toHaveURL('/profile')

    // Update profile information
    await page.click('[data-testid="edit-profile-button"]')
    await page.fill('[data-testid="name-input"]', 'Updated Name')
    await page.selectOption('[data-testid="theme-select"]', 'dark')
    
    // Save changes
    await page.click('[data-testid="save-button"]')

    // Check success message
    await expect(page.locator('[data-testid="success-message"]')).toContainText(
      'Profile updated successfully'
    )
    
    // Verify changes
    await expect(page.locator('[data-testid="user-name"]')).toContainText('Updated Name')
  })
})
```

---

## Testing Best Practices

### Comprehensive Testing Strategy

```typescript
// __tests__/strategies/testing-strategy.ts
/**
 * Testing Strategy for Next.js TypeScript Applications
 * 
 * This document outlines the comprehensive testing approach for Next.js
 * applications with complete TypeScript support.
 */

export const TESTING_PRINCIPLES = {
  // Type Safety First
  TYPE_SAFETY: {
    description: 'All tests should be written with strict TypeScript',
    practices: [
      'Use typed test utilities and mocks',
      'Ensure component props are properly typed in tests',
      'Test TypeScript compilation as part of CI/CD',
      'Use generic types for reusable test utilities',
    ],
  },

  // Test Isolation
  ISOLATION: {
    description: 'Each test should be independent and isolated',
    practices: [
      'Clear mocks and state between tests',
      'Use fresh instances for each test',
      'Avoid shared state between test files',
      'Mock external dependencies consistently',
    ],
  },

  // Real User Behavior
  USER_BEHAVIOR: {
    description: 'Tests should simulate real user interactions',
    practices: [
      'Use accessible queries (getByRole, getByLabelText)',
      'Test keyboard navigation and screen readers',
      'Simulate real user events (click, type, focus)',
      'Test error states and edge cases',
    ],
  },

  // Performance Aware
  PERFORMANCE: {
    description: 'Tests should run quickly and efficiently',
    practices: [
      'Use selective rendering for component tests',
      'Mock heavy dependencies and API calls',
      'Run tests in parallel when possible',
      'Use MSW for API mocking instead of real servers',
    ],
  },

  // Maintainability
  MAINTAINABILITY: {
    description: 'Tests should be easy to understand and maintain',
    practices: [
      'Use descriptive test names and descriptions',
      'Group related tests logically',
      'Extract common test utilities and factories',
      'Document complex testing scenarios',
    ],
  },
} as const

// Test Categories and Coverage Targets
export const COVERAGE_TARGETS = {
  UNIT_TESTS: {
    target: 90,
    includes: [
      'Individual component rendering',
      'Custom hook behavior',
      'Utility function logic',
      'Type definitions and interfaces',
    ],
  },
  
  INTEGRATION_TESTS: {
    target: 80,
    includes: [
      'Component interaction flows',
      'API route functionality',
      'Database operations',
      'State management integration',
    ],
  },
  
  E2E_TESTS: {
    target: 70,
    includes: [
      'Critical user workflows',
      'Authentication flows',
      'Payment processing',
      'Data submission and retrieval',
    ],
  },
} as const

// Testing Checklist
export const TESTING_CHECKLIST = {
  BEFORE_IMPLEMENTING: [
    '✓ Define clear test cases and scenarios',
    '✓ Identify required mocks and test data',
    '✓ Consider edge cases and error conditions',
    '✓ Plan for accessibility testing',
  ],
  
  DURING_IMPLEMENTATION: [
    '✓ Write tests alongside feature development',
    '✓ Ensure TypeScript strict mode compliance',
    '✓ Test both happy path and error scenarios',
    '✓ Verify proper cleanup and resource management',
  ],
  
  AFTER_IMPLEMENTATION: [
    '✓ Review test coverage reports',
    '✓ Verify tests pass in CI/CD environment',
    '✓ Validate performance impact of tests',
    '✓ Update documentation and test guides',
  ],
} as const

// Common Testing Anti-Patterns to Avoid
export const ANTI_PATTERNS = {
  IMPLEMENTATION_DETAILS: {
    problem: 'Testing implementation details instead of behavior',
    solution: 'Focus on user-visible behavior and outcomes',
    example: {
      bad: 'expect(component.state.isLoading).toBe(true)',
      good: 'expect(screen.getByText("Loading...")).toBeInTheDocument()',
    },
  },
  
  FRAGILE_SELECTORS: {
    problem: 'Using fragile CSS selectors or implementation details',
    solution: 'Use semantic queries and test IDs',
    example: {
      bad: 'page.click(".btn-primary:nth-child(2)")',
      good: 'page.click("[data-testid=\'submit-button\']")',
    },
  },
  
  TESTING_MOCKS: {
    problem: 'Testing the mock implementation instead of real behavior',
    solution: 'Verify integration with properly configured mocks',
    example: {
      bad: 'expect(mockFn).toHaveBeenCalled()',
      good: 'expect(screen.getByText("Data loaded")).toBeInTheDocument()',
    },
  },
  
  SLOW_TESTS: {
    problem: 'Tests that take too long to run',
    solution: 'Mock external dependencies and use efficient queries',
    example: {
      bad: 'await page.waitForTimeout(5000)',
      good: 'await page.waitForSelector("[data-testid=\'content\']")',
    },
  },
} as const
```

This comprehensive testing guide provides a complete foundation for testing Next.js applications with TypeScript, covering everything from unit tests to end-to-end testing with proper type safety, performance considerations, and best practices for maintainable test suites.