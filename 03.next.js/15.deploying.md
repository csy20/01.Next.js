# Building & Deploying Next.js TypeScript Applications

## Table of Contents
1. [Build Process and Optimization](#build-process-and-optimization)
2. [Production Configuration](#production-configuration)
3. [Deployment Platforms](#deployment-platforms)
4. [CI/CD Pipeline Setup](#cicd-pipeline-setup)
5. [Environment Management](#environment-management)
6. [Performance Optimization](#performance-optimization)
7. [Monitoring and Analytics](#monitoring-and-analytics)
8. [Production Best Practices](#production-best-practices)

---

## Build Process and Optimization

### Understanding Next.js Build Process

Next.js provides a comprehensive build process that optimizes your TypeScript application for production, including type checking, code splitting, and performance optimizations.

#### Build Configuration and TypeScript Integration

```typescript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  // TypeScript configuration
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // ignoreBuildErrors: false, // Keep false for type safety
  },

  // ESLint configuration  
  eslint: {
    // Warning: This allows production builds to successfully complete even if
    // your project has ESLint errors.
    // ignoreDuringBuilds: false, // Keep false for code quality
    dirs: ['pages', 'utils', 'components', 'lib', 'app'], // Specify directories to lint
  },

  // Experimental features
  experimental: {
    // App Router (stable in Next.js 13.4+)
    appDir: true,
    
    // Server Components logging
    logging: {
      level: 'verbose',
    },
    
    // TypeScript plugin for better performance
    typedRoutes: true,
    
    // Edge Runtime
    runtime: 'nodejs', // or 'edge'
  },

  // Compiler options
  compiler: {
    // Remove console logs in production
    removeConsole: process.env.NODE_ENV === 'production' ? {
      exclude: ['error', 'warn'],
    } : false,
    
    // React strict mode
    reactStrictMode: true,
    
    // Styled-components support
    styledComponents: true,
  },

  // Bundle analyzer
  bundleAnalyzer: {
    enabled: process.env.ANALYZE === 'true',
  },

  // Output configuration
  output: 'standalone', // For Docker deployments
  
  // Redirects and rewrites
  async redirects() {
    return [
      {
        source: '/old-blog/:path*',
        destination: '/blog/:path*',
        permanent: true,
      },
    ]
  },

  async rewrites() {
    return [
      {
        source: '/api/v1/:path*',
        destination: '/api/:path*',
      },
    ]
  },

  // Headers for security and performance
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'Referrer-Policy',
            value: 'origin-when-cross-origin',
          },
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=()',
          },
        ],
      },
    ]
  },

  // Image optimization
  images: {
    domains: ['example.com', 'images.unsplash.com'],
    formats: ['image/webp', 'image/avif'],
    dangerouslyAllowSVG: true,
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },

  // Environment variables
  env: {
    CUSTOM_KEY: process.env.CUSTOM_KEY,
  },

  // Webpack customization
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    // Custom webpack configuration
    if (!dev && !isServer) {
      // Client-side production optimizations
      config.resolve.alias = {
        ...config.resolve.alias,
        '@/components': path.resolve(__dirname, 'components'),
        '@/lib': path.resolve(__dirname, 'lib'),
      }
    }

    return config
  },
}

module.exports = nextConfig
```

#### TypeScript Build Configuration

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "es2022"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "@/components/*": ["./components/*"],
      "@/lib/*": ["./lib/*"],
      "@/utils/*": ["./utils/*"],
      "@/types/*": ["./types/*"],
      "@/hooks/*": ["./hooks/*"],
      "@/app/*": ["./app/*"]
    },
    "forceConsistentCasingInFileNames": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    ".next",
    "out",
    "dist"
  ]
}
```

#### Build Scripts and Optimization

```json
// package.json
{
  "name": "nextjs-typescript-app",
  "version": "1.0.0",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "type-check": "tsc --noEmit",
    "build:analyze": "ANALYZE=true npm run build",
    "build:production": "npm run type-check && npm run lint && npm run build",
    "test": "vitest",
    "test:coverage": "vitest --coverage",
    "test:e2e": "playwright test",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate deploy",
    "db:seed": "tsx prisma/seed.ts",
    "postinstall": "prisma generate"
  },
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "@prisma/client": "^5.7.0",
    "@trpc/client": "^10.45.0",
    "@trpc/server": "^10.45.0",
    "@trpc/react-query": "^10.45.0",
    "@tanstack/react-query": "^5.17.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "typescript": "^5.3.0",
    "eslint": "^8.56.0",
    "eslint-config-next": "^14.0.0",
    "@typescript-eslint/eslint-plugin": "^6.15.0",
    "@typescript-eslint/parser": "^6.15.0",
    "prisma": "^5.7.0",
    "vitest": "^1.1.0",
    "@vitejs/plugin-react": "^4.2.0",
    "playwright": "^1.40.0"
  }
}
```

#### Custom Build Pipeline

```typescript
// scripts/build.ts
import { execSync } from 'child_process'
import { promises as fs } from 'fs'
import path from 'path'

interface BuildConfig {
  environment: 'development' | 'staging' | 'production'
  skipTypeCheck?: boolean
  skipLinting?: boolean
  generateSitemap?: boolean
  optimizeImages?: boolean
}

class BuildPipeline {
  constructor(private config: BuildConfig) {}

  async runBuild() {
    console.log(`üöÄ Starting build for ${this.config.environment}...`)
    
    try {
      // 1. Clean previous build
      await this.cleanBuild()
      
      // 2. Type checking
      if (!this.config.skipTypeCheck) {
        await this.typeCheck()
      }
      
      // 3. Linting
      if (!this.config.skipLinting) {
        await this.lint()
      }
      
      // 4. Generate Prisma client
      await this.generatePrismaClient()
      
      // 5. Run tests
      await this.runTests()
      
      // 6. Build application
      await this.buildApp()
      
      // 7. Post-build optimizations
      await this.postBuildOptimizations()
      
      console.log('‚úÖ Build completed successfully!')
      
    } catch (error) {
      console.error('‚ùå Build failed:', error)
      process.exit(1)
    }
  }

  private async cleanBuild() {
    console.log('üßπ Cleaning previous build...')
    
    const dirsToClean = ['.next', 'out', 'dist', 'coverage']
    
    for (const dir of dirsToClean) {
      try {
        await fs.rm(dir, { recursive: true, force: true })
      } catch (error) {
        // Directory might not exist
      }
    }
  }

  private async typeCheck() {
    console.log('üîç Running TypeScript type checking...')
    
    try {
      execSync('tsc --noEmit', { stdio: 'inherit' })
      console.log('‚úÖ Type checking passed')
    } catch (error) {
      throw new Error('TypeScript type checking failed')
    }
  }

  private async lint() {
    console.log('üîç Running ESLint...')
    
    try {
      execSync('next lint', { stdio: 'inherit' })
      console.log('‚úÖ Linting passed')
    } catch (error) {
      throw new Error('ESLint check failed')
    }
  }

  private async generatePrismaClient() {
    console.log('üîß Generating Prisma client...')
    
    try {
      execSync('prisma generate', { stdio: 'inherit' })
      console.log('‚úÖ Prisma client generated')
    } catch (error) {
      throw new Error('Prisma client generation failed')
    }
  }

  private async runTests() {
    console.log('üß™ Running tests...')
    
    try {
      execSync('npm run test -- --run', { stdio: 'inherit' })
      console.log('‚úÖ Tests passed')
    } catch (error) {
      throw new Error('Tests failed')
    }
  }

  private async buildApp() {
    console.log('üèóÔ∏è Building Next.js application...')
    
    const buildCommand = this.config.environment === 'production' 
      ? 'NODE_ENV=production next build'
      : 'next build'
    
    try {
      execSync(buildCommand, { stdio: 'inherit' })
      console.log('‚úÖ Application built successfully')
    } catch (error) {
      throw new Error('Next.js build failed')
    }
  }

  private async postBuildOptimizations() {
    console.log('‚ö° Running post-build optimizations...')
    
    if (this.config.generateSitemap) {
      await this.generateSitemap()
    }
    
    if (this.config.optimizeImages) {
      await this.optimizeImages()
    }
    
    await this.generateBuildInfo()
  }

  private async generateSitemap() {
    console.log('üó∫Ô∏è Generating sitemap...')
    
    // Generate sitemap based on your routes
    const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://yoursite.com</loc>
    <lastmod>${new Date().toISOString()}</lastmod>
    <changefreq>daily</changefreq>
    <priority>1.0</priority>
  </url>
</urlset>`

    await fs.writeFile(path.join('public', 'sitemap.xml'), sitemap)
    console.log('‚úÖ Sitemap generated')
  }

  private async optimizeImages() {
    console.log('üñºÔ∏è Optimizing images...')
    // Custom image optimization logic
    console.log('‚úÖ Images optimized')
  }

  private async generateBuildInfo() {
    const buildInfo = {
      buildTime: new Date().toISOString(),
      environment: this.config.environment,
      gitCommit: process.env.VERCEL_GIT_COMMIT_SHA || 'unknown',
      version: process.env.npm_package_version || '1.0.0',
    }

    await fs.writeFile(
      path.join('public', 'build-info.json'),
      JSON.stringify(buildInfo, null, 2)
    )
    
    console.log('‚úÖ Build info generated')
  }
}

// Usage
const config: BuildConfig = {
  environment: (process.env.NODE_ENV as any) || 'development',
  skipTypeCheck: process.env.SKIP_TYPE_CHECK === 'true',
  skipLinting: process.env.SKIP_LINT === 'true',
  generateSitemap: true,
  optimizeImages: true,
}

new BuildPipeline(config).runBuild()
```

---

## Production Configuration

### Environment Variables and Configuration

```typescript
// lib/env.ts
import { z } from 'zod'

// Server-side environment schema
const serverEnvSchema = z.object({
  NODE_ENV: z.enum(['development', 'staging', 'production']),
  DATABASE_URL: z.string().url(),
  DATABASE_DIRECT_URL: z.string().url().optional(),
  NEXTAUTH_SECRET: z.string().min(32),
  NEXTAUTH_URL: z.string().url(),
  REDIS_URL: z.string().url().optional(),
  SMTP_HOST: z.string().optional(),
  SMTP_PORT: z.coerce.number().optional(),
  SMTP_USER: z.string().optional(),
  SMTP_PASSWORD: z.string().optional(),
  UPLOADTHING_SECRET: z.string().optional(),
  UPLOADTHING_APP_ID: z.string().optional(),
  STRIPE_SECRET_KEY: z.string().optional(),
  STRIPE_WEBHOOK_SECRET: z.string().optional(),
})

// Client-side environment schema (must be prefixed with NEXT_PUBLIC_)
const clientEnvSchema = z.object({
  NEXT_PUBLIC_APP_URL: z.string().url(),
  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: z.string().optional(),
  NEXT_PUBLIC_POSTHOG_KEY: z.string().optional(),
  NEXT_PUBLIC_POSTHOG_HOST: z.string().url().optional(),
  NEXT_PUBLIC_SENTRY_DSN: z.string().optional(),
})

// Validate environment variables
function validateEnv() {
  const serverEnv = serverEnvSchema.safeParse(process.env)
  const clientEnv = clientEnvSchema.safeParse(process.env)

  if (!serverEnv.success) {
    console.error('‚ùå Invalid server environment variables:')
    console.error(serverEnv.error.flatten().fieldErrors)
    throw new Error('Invalid server environment variables')
  }

  if (!clientEnv.success) {
    console.error('‚ùå Invalid client environment variables:')
    console.error(clientEnv.error.flatten().fieldErrors)
    throw new Error('Invalid client environment variables')
  }

  return {
    ...serverEnv.data,
    ...clientEnv.data,
  }
}

export const env = validateEnv()

// Type-safe environment access
export type Env = typeof env
```

#### Production Environment Files

```bash
# .env.production
NODE_ENV=production
DATABASE_URL="postgresql://user:password@localhost:5432/myapp_prod"
DATABASE_DIRECT_URL="postgresql://user:password@localhost:5432/myapp_prod"

# Authentication
NEXTAUTH_SECRET="your-super-secret-jwt-secret-32-chars-min"
NEXTAUTH_URL="https://yourapp.com"

# External APIs
STRIPE_SECRET_KEY="sk_live_..."
STRIPE_WEBHOOK_SECRET="whsec_..."

# Public variables
NEXT_PUBLIC_APP_URL="https://yourapp.com"
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="pk_live_..."

# Monitoring
NEXT_PUBLIC_SENTRY_DSN="https://your-sentry-dsn"
NEXT_PUBLIC_POSTHOG_KEY="your-posthog-key"
NEXT_PUBLIC_POSTHOG_HOST="https://app.posthog.com"

# .env.staging
NODE_ENV=staging
DATABASE_URL="postgresql://user:password@localhost:5432/myapp_staging"
NEXTAUTH_URL="https://staging.yourapp.com"
NEXT_PUBLIC_APP_URL="https://staging.yourapp.com"

# .env.local (for local development overrides)
DATABASE_URL="postgresql://user:password@localhost:5432/myapp_dev"
NEXTAUTH_URL="http://localhost:3000"
NEXT_PUBLIC_APP_URL="http://localhost:3000"
```

### Security Configuration

```typescript
// lib/security.ts
import { headers } from 'next/headers'
import { NextRequest, NextResponse } from 'next/server'

// Content Security Policy
export const cspHeader = `
  default-src 'self';
  script-src 'self' 'unsafe-eval' 'unsafe-inline' https://js.stripe.com;
  style-src 'self' 'unsafe-inline';
  img-src 'self' blob: data: https:;
  font-src 'self';
  object-src 'none';
  base-uri 'self';
  form-action 'self';
  frame-ancestors 'none';
  upgrade-insecure-requests;
`

// Security headers middleware
export function securityHeaders(request: NextRequest) {
  const response = NextResponse.next()

  // Remove sensitive headers
  response.headers.delete('x-powered-by')
  
  // Set security headers
  response.headers.set('X-DNS-Prefetch-Control', 'on')
  response.headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')
  response.headers.set('X-Frame-Options', 'DENY')
  response.headers.set('X-Content-Type-Options', 'nosniff')
  response.headers.set('Referrer-Policy', 'origin-when-cross-origin')
  response.headers.set('Content-Security-Policy', cspHeader.replace(/\s{2,}/g, ' ').trim())

  return response
}

// Rate limiting
interface RateLimitConfig {
  interval: number // in milliseconds
  uniqueTokenPerInterval: number
}

const rateLimitMap = new Map()

export function rateLimit(config: RateLimitConfig) {
  return {
    check: (request: NextRequest, limit: number, token: string) => {
      const tokenCount = rateLimitMap.get(token) || [0, Date.now()]
      const [count, resetTime] = tokenCount
      const now = Date.now()
      
      if (now > resetTime) {
        rateLimitMap.set(token, [1, now + config.interval])
        return { success: true }
      }
      
      if (count >= limit) {
        return {
          success: false,
          error: 'Rate limit exceeded',
          resetTime: new Date(resetTime)
        }
      }
      
      rateLimitMap.set(token, [count + 1, resetTime])
      return { success: true }
    }
  }
}

// API protection middleware
export async function protectApi(request: NextRequest) {
  const ip = request.ip || request.headers.get('x-forwarded-for') || 'unknown'
  const limiter = rateLimit({
    interval: 60 * 1000, // 1 minute
    uniqueTokenPerInterval: 500,
  })

  const result = limiter.check(request, 10, ip) // 10 requests per minute
  
  if (!result.success) {
    return new NextResponse('Rate limit exceeded', { 
      status: 429,
      headers: {
        'Retry-After': '60',
      }
    })
  }

  return null
}
```

---

## Deployment Platforms

### Vercel Deployment (Recommended for Next.js)

```typescript
// vercel.json
{
  "buildCommand": "npm run build:production",
  "outputDirectory": ".next",
  "installCommand": "npm ci",
  "devCommand": "npm run dev",
  "framework": "nextjs",
  "regions": ["iad1", "sfo1"], // Edge regions
  "functions": {
    "app/api/**": {
      "maxDuration": 30
    }
  },
  "crons": [
    {
      "path": "/api/cron/cleanup",
      "schedule": "0 2 * * *"
    }
  ],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-Content-Type-Options", 
          "value": "nosniff"
        }
      ]
    }
  ],
  "redirects": [
    {
      "source": "/old-page",
      "destination": "/new-page",
      "permanent": true
    }
  ],
  "rewrites": [
    {
      "source": "/docs/:path*",
      "destination": "https://docs.example.com/:path*"
    }
  ]
}
```

#### Vercel Environment Configuration

```typescript
// scripts/deploy-vercel.ts
import { execSync } from 'child_process'

interface DeploymentConfig {
  environment: 'preview' | 'production'
  project: string
  team?: string
}

class VercelDeployment {
  constructor(private config: DeploymentConfig) {}

  async deploy() {
    console.log(`üöÄ Deploying to Vercel (${this.config.environment})...`)

    try {
      // Install Vercel CLI if not present
      await this.ensureVercelCLI()
      
      // Set environment variables
      await this.setEnvironmentVariables()
      
      // Deploy
      await this.runDeployment()
      
      // Post-deployment tasks
      await this.postDeployment()
      
      console.log('‚úÖ Deployment completed successfully!')
      
    } catch (error) {
      console.error('‚ùå Deployment failed:', error)
      process.exit(1)
    }
  }

  private async ensureVercelCLI() {
    try {
      execSync('vercel --version', { stdio: 'pipe' })
    } catch {
      console.log('üì¶ Installing Vercel CLI...')
      execSync('npm install -g vercel', { stdio: 'inherit' })
    }
  }

  private async setEnvironmentVariables() {
    console.log('üîß Setting environment variables...')
    
    const envVars = [
      'DATABASE_URL',
      'NEXTAUTH_SECRET', 
      'NEXTAUTH_URL',
      'STRIPE_SECRET_KEY',
      'STRIPE_WEBHOOK_SECRET',
    ]

    for (const envVar of envVars) {
      const value = process.env[envVar]
      if (value) {
        const target = this.config.environment === 'production' ? 'production' : 'preview'
        
        try {
          execSync(
            `vercel env add ${envVar} ${target} --force`,
            { 
              input: value,
              stdio: ['pipe', 'inherit', 'inherit']
            }
          )
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to set ${envVar}:`, error)
        }
      }
    }
  }

  private async runDeployment() {
    console.log('üèóÔ∏è Running deployment...')
    
    const deployCommand = this.config.environment === 'production'
      ? 'vercel --prod'
      : 'vercel'
    
    execSync(deployCommand, { stdio: 'inherit' })
  }

  private async postDeployment() {
    console.log('üîÑ Running database migrations...')
    
    // Run database migrations on production database
    if (this.config.environment === 'production') {
      execSync('npx prisma migrate deploy', { stdio: 'inherit' })
    }
  }
}

// Usage
const deployment = new VercelDeployment({
  environment: process.env.VERCEL_ENV as 'preview' | 'production' || 'preview',
  project: 'my-nextjs-app',
  team: 'my-team',
})

deployment.deploy()
```

### Docker Deployment

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
# Check https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine to understand why libc6-compat might be needed.
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then yarn global add pnpm && pnpm i --frozen-lockfile; \
  else echo "Lockfile not found." && exit 1; \
  fi

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Next.js collects completely anonymous telemetry data about general usage.
# Learn more here: https://nextjs.org/telemetry
# Uncomment the following line in case you want to disable telemetry during the build.
# ENV NEXT_TELEMETRY_DISABLED 1

# Build the application
RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
# Uncomment the following line in case you want to disable telemetry during runtime.
# ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
# https://nextjs.org/docs/advanced-features/output-file-tracing
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
# set hostname to localhost
ENV HOSTNAME "0.0.0.0"

# server.js is created by next build from the standalone output
# https://nextjs.org/docs/pages/api-reference/next-config-js/output
CMD ["node", "server.js"]
```

#### Docker Compose for Development

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp
      - NEXTAUTH_SECRET=your-secret-key
      - NEXTAUTH_URL=http://localhost:3000
    depends_on:
      - db
      - redis
    volumes:
      - ./public:/app/public

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

---

## CI/CD Pipeline Setup

### GitHub Actions Workflow

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '18'
  PNPM_VERSION: '8'

jobs:
  # Quality checks
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma client
        run: pnpm db:generate

      - name: Run TypeScript check
        run: pnpm type-check

      - name: Run ESLint
        run: pnpm lint

      - name: Run tests
        run: pnpm test:coverage

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/coverage-final.json

  # Security scanning
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # Build and test
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [quality, security]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma client
        run: pnpm db:generate

      - name: Build application
        run: pnpm build
        env:
          NEXT_TELEMETRY_DISABLED: 1

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-files
          path: |
            .next/
            public/
          retention-days: 1

  # E2E tests
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: build
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: build-files

      - name: Setup test database
        run: |
          pnpm db:migrate
          pnpm db:seed
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db

      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps

      - name: Run E2E tests
        run: pnpm test:e2e
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          NEXTAUTH_SECRET: test-secret
          NEXTAUTH_URL: http://localhost:3000

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, e2e]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          scope: ${{ secrets.VERCEL_ORG_ID }}

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, e2e]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          scope: ${{ secrets.VERCEL_ORG_ID }}

      - name: Run database migrations
        run: |
          pnpm db:migrate
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        if: always()
```

### Automated Database Migrations

```typescript
// scripts/migrate-production.ts
import { PrismaClient } from '@prisma/client'
import { execSync } from 'child_process'

interface MigrationConfig {
  environment: 'staging' | 'production'
  dryRun?: boolean
  backupFirst?: boolean
}

class DatabaseMigration {
  private prisma: PrismaClient

  constructor(private config: MigrationConfig) {
    this.prisma = new PrismaClient({
      datasources: {
        db: {
          url: process.env.DATABASE_URL,
        },
      },
    })
  }

  async migrate() {
    console.log(`üóÑÔ∏è Starting database migration for ${this.config.environment}...`)

    try {
      if (this.config.backupFirst) {
        await this.createBackup()
      }

      if (this.config.dryRun) {
        await this.dryRunMigration()
      } else {
        await this.runMigration()
      }

      await this.verifyMigration()
      
      console.log('‚úÖ Database migration completed successfully!')

    } catch (error) {
      console.error('‚ùå Migration failed:', error)
      
      if (this.config.backupFirst && !this.config.dryRun) {
        console.log('üîÑ Attempting to restore from backup...')
        await this.restoreBackup()
      }
      
      throw error
    } finally {
      await this.prisma.$disconnect()
    }
  }

  private async createBackup() {
    console.log('üíæ Creating database backup...')
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const backupFile = `backup-${this.config.environment}-${timestamp}.sql`
    
    try {
      execSync(`pg_dump "${process.env.DATABASE_URL}" > ${backupFile}`, {
        stdio: 'inherit'
      })
      console.log(`‚úÖ Backup created: ${backupFile}`)
    } catch (error) {
      throw new Error(`Failed to create backup: ${error}`)
    }
  }

  private async dryRunMigration() {
    console.log('üß™ Running dry run migration...')
    
    try {
      // Check what migrations would be applied
      const output = execSync('npx prisma migrate diff --from-schema-datasource prisma/schema.prisma --to-schema-datamodel prisma/schema.prisma', {
        encoding: 'utf8'
      })
      
      console.log('üìã Migration preview:')
      console.log(output)
    } catch (error) {
      throw new Error(`Dry run failed: ${error}`)
    }
  }

  private async runMigration() {
    console.log('üöÄ Applying database migrations...')
    
    try {
      execSync('npx prisma migrate deploy', {
        stdio: 'inherit',
        env: {
          ...process.env,
          DATABASE_URL: process.env.DATABASE_URL,
        }
      })
    } catch (error) {
      throw new Error(`Migration failed: ${error}`)
    }
  }

  private async verifyMigration() {
    console.log('üîç Verifying migration...')
    
    try {
      // Test database connection and basic queries
      await this.prisma.$queryRaw`SELECT 1`
      
      // You can add more specific verification queries here
      console.log('‚úÖ Migration verification passed')
    } catch (error) {
      throw new Error(`Migration verification failed: ${error}`)
    }
  }

  private async restoreBackup() {
    // Implementation depends on your backup strategy
    console.log('üîÑ Backup restoration would be implemented here')
  }
}

// Usage
const migration = new DatabaseMigration({
  environment: (process.env.NODE_ENV as 'staging' | 'production') || 'staging',
  dryRun: process.env.DRY_RUN === 'true',
  backupFirst: process.env.BACKUP_FIRST === 'true',
})

migration.migrate().catch(console.error)
```

---

## Environment Management

### Multi-Environment Configuration

```typescript
// lib/config.ts
interface AppConfig {
  app: {
    name: string
    version: string
    url: string
    environment: 'development' | 'staging' | 'production'
  }
  database: {
    url: string
    maxConnections: number
    ssl: boolean
  }
  auth: {
    secret: string
    tokenExpiry: number
    providers: string[]
  }
  features: {
    analytics: boolean
    monitoring: boolean
    rateLimit: boolean
    caching: boolean
  }
  external: {
    stripe: {
      publishableKey: string
      secretKey: string
      webhookSecret: string
    }
    email: {
      host: string
      port: number
      secure: boolean
    }
  }
}

function createConfig(): AppConfig {
  const environment = process.env.NODE_ENV || 'development'
  
  const baseConfig: AppConfig = {
    app: {
      name: 'My Next.js App',
      version: process.env.npm_package_version || '1.0.0',
      url: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',
      environment: environment as any,
    },
    database: {
      url: process.env.DATABASE_URL || '',
      maxConnections: parseInt(process.env.DB_MAX_CONNECTIONS || '10'),
      ssl: process.env.DB_SSL === 'true',
    },
    auth: {
      secret: process.env.NEXTAUTH_SECRET || 'dev-secret',
      tokenExpiry: parseInt(process.env.TOKEN_EXPIRY || '3600'),
      providers: (process.env.AUTH_PROVIDERS || 'credentials').split(','),
    },
    features: {
      analytics: process.env.ENABLE_ANALYTICS === 'true',
      monitoring: process.env.ENABLE_MONITORING === 'true',
      rateLimit: process.env.ENABLE_RATE_LIMIT === 'true',
      caching: process.env.ENABLE_CACHING === 'true',
    },
    external: {
      stripe: {
        publishableKey: process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY || '',
        secretKey: process.env.STRIPE_SECRET_KEY || '',
        webhookSecret: process.env.STRIPE_WEBHOOK_SECRET || '',
      },
      email: {
        host: process.env.SMTP_HOST || 'localhost',
        port: parseInt(process.env.SMTP_PORT || '587'),
        secure: process.env.SMTP_SECURE === 'true',
      },
    },
  }

  // Environment-specific overrides
  switch (environment) {
    case 'production':
      return {
        ...baseConfig,
        features: {
          ...baseConfig.features,
          analytics: true,
          monitoring: true,
          rateLimit: true,
          caching: true,
        },
      }
    
    case 'staging':
      return {
        ...baseConfig,
        features: {
          ...baseConfig.features,
          analytics: true,
          monitoring: true,
          rateLimit: false,
          caching: true,
        },
      }
    
    default: // development
      return {
        ...baseConfig,
        features: {
          ...baseConfig.features,
          analytics: false,
          monitoring: false,
          rateLimit: false,
          caching: false,
        },
      }
  }
}

export const config = createConfig()
```

---

## Performance Optimization

### Build-Time Optimizations

```typescript
// next.config.js - Performance optimizations
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Compiler optimizations
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
    reactStrictMode: true,
  },

  // Experimental optimizations
  experimental: {
    optimizeCss: true,
    optimizePackageImports: ['@mantine/core', '@mantine/hooks'],
    bundlePagesRouterDependencies: true,
  },

  // Image optimization
  images: {
    formats: ['image/webp', 'image/avif'],
    minimumCacheTTL: 60 * 60 * 24 * 30, // 30 days
    dangerouslyAllowSVG: true,
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },

  // Webpack optimizations
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    // Bundle analyzer
    if (process.env.ANALYZE === 'true') {
      const BundleAnalyzerPlugin = require('@next/bundle-analyzer')({
        enabled: true,
      })
      config.plugins.push(new BundleAnalyzerPlugin())
    }

    // Production optimizations
    if (!dev && !isServer) {
      config.optimization = {
        ...config.optimization,
        sideEffects: false,
        usedExports: true,
        providedExports: true,
      }
    }

    return config
  },

  // Output configuration for standalone deployment
  output: 'standalone',
}

module.exports = nextConfig
```

### Runtime Performance Monitoring

```typescript
// lib/performance.ts
interface PerformanceMetrics {
  pageLoad: number
  firstContentfulPaint: number
  largestContentfulPaint: number
  cumulativeLayoutShift: number
  firstInputDelay: number
}

class PerformanceMonitor {
  private metrics: Partial<PerformanceMetrics> = {}

  constructor() {
    if (typeof window !== 'undefined') {
      this.initializeMetrics()
    }
  }

  private initializeMetrics() {
    // Web Vitals
    this.measureWebVitals()
    
    // Custom metrics
    this.measurePageLoad()
    
    // Report metrics
    this.reportMetrics()
  }

  private measureWebVitals() {
    // This would typically use web-vitals library
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS((metric) => {
        this.metrics.cumulativeLayoutShift = metric.value
      })

      getFID((metric) => {
        this.metrics.firstInputDelay = metric.value
      })

      getFCP((metric) => {
        this.metrics.firstContentfulPaint = metric.value
      })

      getLCP((metric) => {
        this.metrics.largestContentfulPaint = metric.value
      })

      getTTFB((metric) => {
        console.log('TTFB:', metric.value)
      })
    })
  }

  private measurePageLoad() {
    window.addEventListener('load', () => {
      const navigationTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
      this.metrics.pageLoad = navigationTiming.loadEventEnd - navigationTiming.fetchStart
    })
  }

  private reportMetrics() {
    // Send metrics to analytics service
    window.addEventListener('beforeunload', () => {
      if (Object.keys(this.metrics).length > 0) {
        navigator.sendBeacon('/api/analytics/performance', JSON.stringify(this.metrics))
      }
    })
  }

  public trackCustomMetric(name: string, value: number, tags?: Record<string, string>) {
    // Track custom performance metrics
    console.log(`Custom metric: ${name} = ${value}`, tags)
    
    // Send to monitoring service
    fetch('/api/analytics/custom', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, value, tags, timestamp: Date.now() })
    }).catch(console.error)
  }
}

export const performanceMonitor = new PerformanceMonitor()
```

---

## Monitoring and Analytics

### Comprehensive Monitoring Setup

```typescript
// lib/monitoring.ts
import * as Sentry from '@sentry/nextjs'

// Initialize Sentry for error tracking
export function initializeMonitoring() {
  if (process.env.NEXT_PUBLIC_SENTRY_DSN) {
    Sentry.init({
      dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
      environment: process.env.NODE_ENV,
      tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
      beforeSend(event) {
        // Filter out noise
        if (event.exception) {
          const error = event.exception.values?.[0]
          if (error?.value?.includes('Non-Error promise rejection')) {
            return null
          }
        }
        return event
      },
    })
  }
}

// Custom logging with structured data
interface LogContext {
  userId?: string
  sessionId?: string
  requestId?: string
  [key: string]: any
}

class Logger {
  private context: LogContext = {}

  setContext(context: LogContext) {
    this.context = { ...this.context, ...context }
  }

  info(message: string, data?: any) {
    console.log(JSON.stringify({
      level: 'info',
      message,
      data,
      context: this.context,
      timestamp: new Date().toISOString(),
    }))
  }

  error(message: string, error?: Error, data?: any) {
    const errorInfo = {
      level: 'error',
      message,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack,
      } : undefined,
      data,
      context: this.context,
      timestamp: new Date().toISOString(),
    }

    console.error(JSON.stringify(errorInfo))
    
    // Send to Sentry
    if (error) {
      Sentry.captureException(error, {
        contexts: { custom: this.context },
        extra: data,
      })
    }
  }

  warn(message: string, data?: any) {
    console.warn(JSON.stringify({
      level: 'warn',
      message,
      data,
      context: this.context,
      timestamp: new Date().toISOString(),
    }))
  }
}

export const logger = new Logger()

// Analytics tracking
interface AnalyticsEvent {
  name: string
  properties?: Record<string, any>
  userId?: string
}

class Analytics {
  track(event: AnalyticsEvent) {
    // PostHog integration
    if (typeof window !== 'undefined' && window.posthog) {
      window.posthog.capture(event.name, {
        ...event.properties,
        $user_id: event.userId,
      })
    }

    // Custom analytics endpoint
    fetch('/api/analytics/track', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...event,
        timestamp: Date.now(),
        url: window.location.href,
        userAgent: navigator.userAgent,
      }),
    }).catch(console.error)
  }

  page(path: string, properties?: Record<string, any>) {
    this.track({
      name: 'Page View',
      properties: {
        path,
        ...properties,
      },
    })
  }

  identify(userId: string, traits?: Record<string, any>) {
    if (typeof window !== 'undefined' && window.posthog) {
      window.posthog.identify(userId, traits)
    }
  }
}

export const analytics = new Analytics()
```

This comprehensive deployment guide covers everything needed to build and deploy production-ready Next.js TypeScript applications with proper monitoring, security, and performance optimizations across multiple platforms and environments.
