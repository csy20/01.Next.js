# Type-Safe State Management in Next.js

## Table of Contents
1. [Understanding State Management in Next.js](#understanding-state-management-in-nextjs)
2. [Zustand: Lightweight Type-Safe State](#zustand-lightweight-type-safe-state)
3. [Redux Toolkit: Enterprise State Management](#redux-toolkit-enterprise-state-management)
4. [Advanced State Patterns](#advanced-state-patterns)
5. [Server-Client State Synchronization](#server-client-state-synchronization)
6. [Real-World Implementation](#real-world-implementation)

---

## Understanding State Management in Next.js

### State Management Architecture in Next.js

Next.js applications have unique state management considerations due to their hybrid nature (SSR/SSG + Client-side). Understanding when and how to use different state management solutions is crucial for building scalable applications.

#### State Categories in Next.js

```typescript
// types/state.ts
// Server State - Data fetched from APIs
interface ServerState<T> {
  data: T | null
  loading: boolean
  error: string | null
  lastFetched: Date | null
}

// Client State - UI-specific state
interface ClientState {
  theme: 'light' | 'dark' | 'system'
  sidebarOpen: boolean
  modals: Record<string, boolean>
  notifications: Notification[]
}

// Global Application State
interface AppState {
  user: User | null
  preferences: UserPreferences
  cache: Record<string, any>
  metadata: AppMetadata
}

// Local Component State
interface ComponentState {
  formData: Record<string, any>
  validation: Record<string, string[]>
  ui: {
    loading: boolean
    focused: string | null
    expanded: string[]
  }
}

// Shared State Between Components
interface SharedState {
  selectedItems: string[]
  filters: FilterOptions
  searchQuery: string
  pagination: PaginationState
}
```

---

## Zustand: Lightweight Type-Safe State

### Understanding Zustand Architecture

Zustand is a small, fast, and scalable state management solution that provides excellent TypeScript support out of the box. It uses a simplified flux-like pattern without boilerplate.

#### Basic Zustand Store with TypeScript

```typescript
// stores/auth-store.ts
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

interface User {
  id: string
  email: string
  name: string
  role: 'USER' | 'ADMIN' | 'MODERATOR'
  avatar?: string
  preferences: UserPreferences
}

interface UserPreferences {
  theme: 'light' | 'dark' | 'system'
  language: string
  notifications: {
    email: boolean
    push: boolean
    marketing: boolean
  }
}

interface AuthState {
  // State
  user: User | null
  isAuthenticated: boolean
  isLoading: boolean
  error: string | null
  
  // Actions
  login: (email: string, password: string) => Promise<void>
  logout: () => void
  updateProfile: (updates: Partial<User>) => Promise<void>
  updatePreferences: (preferences: Partial<UserPreferences>) => void
  clearError: () => void
  
  // Computed values
  getUserRole: () => string | null
  hasPermission: (permission: string) => boolean
}

export const useAuthStore = create<AuthState>()(
  devtools(
    persist(
      immer((set, get) => ({
        // Initial state
        user: null,
        isAuthenticated: false,
        isLoading: false,
        error: null,

        // Actions
        login: async (email: string, password: string) => {
          set((state) => {
            state.isLoading = true
            state.error = null
          })

          try {
            const response = await fetch('/api/auth/login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ email, password })
            })

            if (!response.ok) {
              throw new Error('Login failed')
            }

            const user = await response.json()

            set((state) => {
              state.user = user
              state.isAuthenticated = true
              state.isLoading = false
              state.error = null
            })
          } catch (error) {
            set((state) => {
              state.isLoading = false
              state.error = error instanceof Error ? error.message : 'Login failed'
            })
          }
        },

        logout: () => {
          set((state) => {
            state.user = null
            state.isAuthenticated = false
            state.error = null
          })
          
          // Clear any auth tokens
          document.cookie = 'auth-token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'
        },

        updateProfile: async (updates: Partial<User>) => {
          const currentUser = get().user
          if (!currentUser) return

          try {
            const response = await fetch(`/api/users/${currentUser.id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(updates)
            })

            if (!response.ok) {
              throw new Error('Profile update failed')
            }

            const updatedUser = await response.json()

            set((state) => {
              state.user = updatedUser
            })
          } catch (error) {
            set((state) => {
              state.error = error instanceof Error ? error.message : 'Update failed'
            })
          }
        },

        updatePreferences: (preferences: Partial<UserPreferences>) => {
          set((state) => {
            if (state.user) {
              state.user.preferences = {
                ...state.user.preferences,
                ...preferences
              }
            }
          })
        },

        clearError: () => {
          set((state) => {
            state.error = null
          })
        },

        // Computed values
        getUserRole: () => {
          const { user } = get()
          return user?.role || null
        },

        hasPermission: (permission: string) => {
          const { user } = get()
          if (!user) return false

          const rolePermissions = {
            ADMIN: ['*'],
            MODERATOR: ['read', 'write', 'moderate'],
            USER: ['read', 'write']
          }

          const userPermissions = rolePermissions[user.role] || []
          return userPermissions.includes('*') || userPermissions.includes(permission)
        }
      })),
      {
        name: 'auth-storage',
        partialize: (state) => ({
          user: state.user,
          isAuthenticated: state.isAuthenticated
        })
      }
    ),
    { name: 'auth-store' }
  )
)

// Selectors for better performance
export const useAuth = () => useAuthStore((state) => ({
  user: state.user,
  isAuthenticated: state.isAuthenticated,
  isLoading: state.isLoading
}))

export const useAuthActions = () => useAuthStore((state) => ({
  login: state.login,
  logout: state.logout,
  updateProfile: state.updateProfile,
  updatePreferences: state.updatePreferences
}))
```

#### Advanced Zustand Patterns

```typescript
// stores/ui-store.ts
import { create } from 'zustand'
import { subscribeWithSelector } from 'zustand/middleware'

interface Modal {
  id: string
  component: string
  props?: Record<string, any>
  persistent?: boolean
}

interface Notification {
  id: string
  type: 'info' | 'success' | 'warning' | 'error'
  title: string
  message: string
  duration?: number
  actions?: Array<{
    label: string
    action: () => void
    variant: 'primary' | 'secondary'
  }>
}

interface UIState {
  // Theme
  theme: 'light' | 'dark' | 'system'
  
  // Layout
  sidebarOpen: boolean
  sidebarWidth: number
  
  // Modals
  modals: Modal[]
  
  // Notifications
  notifications: Notification[]
  
  // Loading states
  globalLoading: boolean
  loadingStates: Record<string, boolean>
  
  // Actions
  setTheme: (theme: 'light' | 'dark' | 'system') => void
  toggleSidebar: () => void
  setSidebarWidth: (width: number) => void
  
  openModal: (modal: Omit<Modal, 'id'>) => string
  closeModal: (id: string) => void
  closeAllModals: () => void
  
  addNotification: (notification: Omit<Notification, 'id'>) => string
  removeNotification: (id: string) => void
  clearNotifications: () => void
  
  setLoading: (key: string, loading: boolean) => void
  setGlobalLoading: (loading: boolean) => void
}

export const useUIStore = create<UIState>()(
  subscribeWithSelector(
    devtools(
      (set, get) => ({
        // Initial state
        theme: 'system',
        sidebarOpen: true,
        sidebarWidth: 240,
        modals: [],
        notifications: [],
        globalLoading: false,
        loadingStates: {},

        // Theme actions
        setTheme: (theme) => {
          set({ theme })
          
          // Apply theme to document
          if (typeof window !== 'undefined') {
            const root = document.documentElement
            root.setAttribute('data-theme', theme)
            
            if (theme === 'system') {
              const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
              root.classList.toggle('dark', prefersDark)
            } else {
              root.classList.toggle('dark', theme === 'dark')
            }
          }
        },

        // Sidebar actions
        toggleSidebar: () => {
          set((state) => ({ sidebarOpen: !state.sidebarOpen }))
        },

        setSidebarWidth: (width) => {
          set({ sidebarWidth: Math.max(200, Math.min(400, width)) })
        },

        // Modal actions
        openModal: (modal) => {
          const id = crypto.randomUUID()
          const newModal = { ...modal, id }
          
          set((state) => ({
            modals: [...state.modals, newModal]
          }))
          
          return id
        },

        closeModal: (id) => {
          set((state) => ({
            modals: state.modals.filter(modal => modal.id !== id)
          }))
        },

        closeAllModals: () => {
          set({ modals: [] })
        },

        // Notification actions
        addNotification: (notification) => {
          const id = crypto.randomUUID()
          const newNotification = { ...notification, id }
          
          set((state) => ({
            notifications: [...state.notifications, newNotification]
          }))

          // Auto-remove notification if duration is set
          if (notification.duration) {
            setTimeout(() => {
              get().removeNotification(id)
            }, notification.duration)
          }
          
          return id
        },

        removeNotification: (id) => {
          set((state) => ({
            notifications: state.notifications.filter(n => n.id !== id)
          }))
        },

        clearNotifications: () => {
          set({ notifications: [] })
        },

        // Loading actions
        setLoading: (key, loading) => {
          set((state) => ({
            loadingStates: {
              ...state.loadingStates,
              [key]: loading
            }
          }))
        },

        setGlobalLoading: (globalLoading) => {
          set({ globalLoading })
        }
      }),
      { name: 'ui-store' }
    )
  )
)

// Selectors
export const useTheme = () => useUIStore((state) => state.theme)
export const useSidebar = () => useUIStore((state) => ({
  isOpen: state.sidebarOpen,
  width: state.sidebarWidth,
  toggle: state.toggleSidebar,
  setWidth: state.setSidebarWidth
}))

export const useModals = () => useUIStore((state) => ({
  modals: state.modals,
  openModal: state.openModal,
  closeModal: state.closeModal,
  closeAllModals: state.closeAllModals
}))

export const useNotifications = () => useUIStore((state) => ({
  notifications: state.notifications,
  addNotification: state.addNotification,
  removeNotification: state.removeNotification,
  clearNotifications: state.clearNotifications
}))
```

#### Zustand with TypeScript Slices

```typescript
// stores/slices/todo-slice.ts
interface Todo {
  id: string
  title: string
  description?: string
  completed: boolean
  priority: 'low' | 'medium' | 'high'
  dueDate?: Date
  tags: string[]
  createdAt: Date
  updatedAt: Date
}

interface TodoSlice {
  todos: Todo[]
  filter: 'all' | 'active' | 'completed'
  sortBy: 'created' | 'due' | 'priority' | 'title'
  searchQuery: string
  
  // Actions
  addTodo: (todo: Omit<Todo, 'id' | 'createdAt' | 'updatedAt'>) => void
  updateTodo: (id: string, updates: Partial<Todo>) => void
  deleteTodo: (id: string) => void
  toggleTodo: (id: string) => void
  
  setFilter: (filter: 'all' | 'active' | 'completed') => void
  setSortBy: (sortBy: 'created' | 'due' | 'priority' | 'title') => void
  setSearchQuery: (query: string) => void
  
  // Computed
  getFilteredTodos: () => Todo[]
  getTodoStats: () => { total: number; completed: number; active: number }
}

export const createTodoSlice = (set: any, get: any): TodoSlice => ({
  todos: [],
  filter: 'all',
  sortBy: 'created',
  searchQuery: '',

  addTodo: (todoData) => {
    const todo: Todo = {
      ...todoData,
      id: crypto.randomUUID(),
      createdAt: new Date(),
      updatedAt: new Date()
    }
    
    set((state: any) => ({
      todos: [...state.todos, todo]
    }))
  },

  updateTodo: (id, updates) => {
    set((state: any) => ({
      todos: state.todos.map((todo: Todo) =>
        todo.id === id
          ? { ...todo, ...updates, updatedAt: new Date() }
          : todo
      )
    }))
  },

  deleteTodo: (id) => {
    set((state: any) => ({
      todos: state.todos.filter((todo: Todo) => todo.id !== id)
    }))
  },

  toggleTodo: (id) => {
    set((state: any) => ({
      todos: state.todos.map((todo: Todo) =>
        todo.id === id
          ? { ...todo, completed: !todo.completed, updatedAt: new Date() }
          : todo
      )
    }))
  },

  setFilter: (filter) => set({ filter }),
  setSortBy: (sortBy) => set({ sortBy }),
  setSearchQuery: (searchQuery) => set({ searchQuery }),

  getFilteredTodos: () => {
    const { todos, filter, sortBy, searchQuery } = get()
    
    let filtered = todos.filter((todo: Todo) => {
      // Filter by completion status
      if (filter === 'active' && todo.completed) return false
      if (filter === 'completed' && !todo.completed) return false
      
      // Filter by search query
      if (searchQuery) {
        const query = searchQuery.toLowerCase()
        return (
          todo.title.toLowerCase().includes(query) ||
          todo.description?.toLowerCase().includes(query) ||
          todo.tags.some(tag => tag.toLowerCase().includes(query))
        )
      }
      
      return true
    })

    // Sort todos
    filtered.sort((a: Todo, b: Todo) => {
      switch (sortBy) {
        case 'due':
          if (!a.dueDate && !b.dueDate) return 0
          if (!a.dueDate) return 1
          if (!b.dueDate) return -1
          return a.dueDate.getTime() - b.dueDate.getTime()
        
        case 'priority':
          const priorityOrder = { high: 3, medium: 2, low: 1 }
          return priorityOrder[b.priority] - priorityOrder[a.priority]
        
        case 'title':
          return a.title.localeCompare(b.title)
        
        default: // created
          return b.createdAt.getTime() - a.createdAt.getTime()
      }
    })

    return filtered
  },

  getTodoStats: () => {
    const { todos } = get()
    return {
      total: todos.length,
      completed: todos.filter((todo: Todo) => todo.completed).length,
      active: todos.filter((todo: Todo) => !todo.completed).length
    }
  }
})

// Combined store using slices
interface AppStore extends TodoSlice {
  // Add other slices here
}

export const useAppStore = create<AppStore>()(
  devtools(
    persist(
      (set, get) => ({
        ...createTodoSlice(set, get),
        // ...other slices
      }),
      {
        name: 'app-storage',
        partialize: (state) => ({
          todos: state.todos,
          // Include only the state you want to persist
        })
      }
    ),
    { name: 'app-store' }
  )
)
```

---

## Redux Toolkit: Enterprise State Management

### Understanding Redux Toolkit with TypeScript

Redux Toolkit (RTK) provides a modern, TypeScript-first approach to Redux with excellent developer experience and built-in best practices.

#### Basic Redux Toolkit Setup

```typescript
// store/index.ts
import { configureStore } from '@reduxjs/toolkit'
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'
import authSlice from './slices/auth-slice'
import uiSlice from './slices/ui-slice'
import todosSlice from './slices/todos-slice'
import { api } from './api/api-slice'

export const store = configureStore({
  reducer: {
    auth: authSlice,
    ui: uiSlice,
    todos: todosSlice,
    api: api.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],
      },
    }).concat(api.middleware),
  devTools: process.env.NODE_ENV !== 'production',
})

export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch

// Typed hooks
export const useAppDispatch = () => useDispatch<AppDispatch>()
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector
```

#### Redux Toolkit Slice with TypeScript

```typescript
// store/slices/auth-slice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit'

interface User {
  id: string
  email: string
  name: string
  role: 'USER' | 'ADMIN' | 'MODERATOR'
  avatar?: string
}

interface AuthState {
  user: User | null
  isAuthenticated: boolean
  isLoading: boolean
  error: string | null
  loginAttempts: number
  lastLoginAttempt: number | null
}

const initialState: AuthState = {
  user: null,
  isAuthenticated: false,
  isLoading: false,
  error: null,
  loginAttempts: 0,
  lastLoginAttempt: null,
}

// Async thunks with proper typing
export const loginUser = createAsyncThunk(
  'auth/loginUser',
  async (
    credentials: { email: string; password: string },
    { rejectWithValue }
  ) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials),
      })

      if (!response.ok) {
        const error = await response.json()
        return rejectWithValue(error.message || 'Login failed')
      }

      const user = await response.json()
      return user as User
    } catch (error) {
      return rejectWithValue('Network error occurred')
    }
  }
)

export const updateUserProfile = createAsyncThunk(
  'auth/updateUserProfile',
  async (
    updates: Partial<Omit<User, 'id'>>,
    { getState, rejectWithValue }
  ) => {
    try {
      const state = getState() as { auth: AuthState }
      const userId = state.auth.user?.id

      if (!userId) {
        return rejectWithValue('User not authenticated')
      }

      const response = await fetch(`/api/users/${userId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      })

      if (!response.ok) {
        const error = await response.json()
        return rejectWithValue(error.message || 'Update failed')
      }

      const updatedUser = await response.json()
      return updatedUser as User
    } catch (error) {
      return rejectWithValue('Network error occurred')
    }
  }
)

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null
      state.isAuthenticated = false
      state.error = null
      state.loginAttempts = 0
      state.lastLoginAttempt = null
    },
    
    clearError: (state) => {
      state.error = null
    },
    
    updateUserLocally: (state, action: PayloadAction<Partial<User>>) => {
      if (state.user) {
        state.user = { ...state.user, ...action.payload }
      }
    },
    
    incrementLoginAttempts: (state) => {
      state.loginAttempts += 1
      state.lastLoginAttempt = Date.now()
    },
    
    resetLoginAttempts: (state) => {
      state.loginAttempts = 0
      state.lastLoginAttempt = null
    },
  },
  
  extraReducers: (builder) => {
    // Login user
    builder
      .addCase(loginUser.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.isLoading = false
        state.user = action.payload
        state.isAuthenticated = true
        state.error = null
        state.loginAttempts = 0
        state.lastLoginAttempt = null
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
        state.loginAttempts += 1
        state.lastLoginAttempt = Date.now()
      })

    // Update user profile
    builder
      .addCase(updateUserProfile.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(updateUserProfile.fulfilled, (state, action) => {
        state.isLoading = false
        state.user = action.payload
        state.error = null
      })
      .addCase(updateUserProfile.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
      })
  },
})

export const {
  logout,
  clearError,
  updateUserLocally,
  incrementLoginAttempts,
  resetLoginAttempts,
} = authSlice.actions

export default authSlice.reducer

// Selectors
export const selectAuth = (state: { auth: AuthState }) => state.auth
export const selectUser = (state: { auth: AuthState }) => state.auth.user
export const selectIsAuthenticated = (state: { auth: AuthState }) => state.auth.isAuthenticated
export const selectAuthLoading = (state: { auth: AuthState }) => state.auth.isLoading
export const selectAuthError = (state: { auth: AuthState }) => state.auth.error

// Complex selectors
export const selectUserPermissions = (state: { auth: AuthState }) => {
  const user = state.auth.user
  if (!user) return []

  const rolePermissions = {
    ADMIN: ['*'],
    MODERATOR: ['read', 'write', 'moderate'],
    USER: ['read', 'write'],
  }

  return rolePermissions[user.role] || []
}

export const selectCanLogin = (state: { auth: AuthState }) => {
  const { loginAttempts, lastLoginAttempt } = state.auth
  
  if (loginAttempts < 3) return true
  
  if (lastLoginAttempt) {
    const timeSinceLastAttempt = Date.now() - lastLoginAttempt
    const lockoutDuration = 15 * 60 * 1000 // 15 minutes
    return timeSinceLastAttempt > lockoutDuration
  }
  
  return false
}
```

#### RTK Query for Server State

```typescript
// store/api/api-slice.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
import type { RootState } from '../index'

interface User {
  id: string
  email: string
  name: string
  role: string
  avatar?: string
}

interface Post {
  id: string
  title: string
  content: string
  authorId: string
  published: boolean
  createdAt: string
  updatedAt: string
  tags: string[]
}

interface PaginatedResponse<T> {
  data: T[]
  totalCount: number
  page: number
  pageSize: number
  hasNextPage: boolean
}

export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api',
    prepareHeaders: (headers, { getState }) => {
      // Add auth token to requests
      const token = (getState() as RootState).auth.user?.id
      if (token) {
        headers.set('authorization', `Bearer ${token}`)
      }
      return headers
    },
  }),
  tagTypes: ['User', 'Post', 'Comment'],
  endpoints: (builder) => ({
    // Users
    getUsers: builder.query<PaginatedResponse<User>, { page?: number; limit?: number }>({
      query: ({ page = 1, limit = 10 } = {}) => `users?page=${page}&limit=${limit}`,
      providesTags: ['User'],
    }),
    
    getUserById: builder.query<User, string>({
      query: (id) => `users/${id}`,
      providesTags: (result, error, id) => [{ type: 'User', id }],
    }),
    
    updateUser: builder.mutation<User, { id: string; updates: Partial<User> }>({
      query: ({ id, updates }) => ({
        url: `users/${id}`,
        method: 'PATCH',
        body: updates,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'User', id }],
    }),
    
    deleteUser: builder.mutation<void, string>({
      query: (id) => ({
        url: `users/${id}`,
        method: 'DELETE',
      }),
      invalidatesTags: (result, error, id) => [{ type: 'User', id }, 'User'],
    }),

    // Posts
    getPosts: builder.query<
      PaginatedResponse<Post>,
      { page?: number; limit?: number; authorId?: string; published?: boolean }
    >({
      query: ({ page = 1, limit = 10, authorId, published } = {}) => {
        const params = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
        })
        
        if (authorId) params.append('authorId', authorId)
        if (published !== undefined) params.append('published', published.toString())
        
        return `posts?${params}`
      },
      providesTags: (result) =>
        result
          ? [
              ...result.data.map(({ id }) => ({ type: 'Post' as const, id })),
              { type: 'Post', id: 'LIST' },
            ]
          : [{ type: 'Post', id: 'LIST' }],
    }),
    
    getPostById: builder.query<Post, string>({
      query: (id) => `posts/${id}`,
      providesTags: (result, error, id) => [{ type: 'Post', id }],
    }),
    
    createPost: builder.mutation<Post, Omit<Post, 'id' | 'createdAt' | 'updatedAt'>>({
      query: (newPost) => ({
        url: 'posts',
        method: 'POST',
        body: newPost,
      }),
      invalidatesTags: [{ type: 'Post', id: 'LIST' }],
    }),
    
    updatePost: builder.mutation<Post, { id: string; updates: Partial<Post> }>({
      query: ({ id, updates }) => ({
        url: `posts/${id}`,
        method: 'PATCH',
        body: updates,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Post', id }],
    }),
    
    deletePost: builder.mutation<void, string>({
      query: (id) => ({
        url: `posts/${id}`,
        method: 'DELETE',
      }),
      invalidatesTags: (result, error, id) => [
        { type: 'Post', id },
        { type: 'Post', id: 'LIST' },
      ],
    }),
  }),
})

export const {
  useGetUsersQuery,
  useGetUserByIdQuery,
  useUpdateUserMutation,
  useDeleteUserMutation,
  useGetPostsQuery,
  useGetPostByIdQuery,
  useCreatePostMutation,
  useUpdatePostMutation,
  useDeletePostMutation,
} = api

// Enhanced hooks with optimistic updates
export const useOptimisticUpdatePost = () => {
  const [updatePost] = useUpdatePostMutation()
  
  return async (id: string, updates: Partial<Post>) => {
    try {
      await updatePost({ id, updates }).unwrap()
    } catch (error) {
      // Handle error - the cache will automatically revert
      console.error('Failed to update post:', error)
      throw error
    }
  }
}

// Custom hooks for complex queries
export const useUserPosts = (userId: string, options?: { published?: boolean }) => {
  return useGetPostsQuery(
    { authorId: userId, published: options?.published },
    { skip: !userId }
  )
}

export const usePostWithAuthor = (postId: string) => {
  const postQuery = useGetPostByIdQuery(postId)
  const userQuery = useGetUserByIdQuery(postQuery.data?.authorId || '', {
    skip: !postQuery.data?.authorId,
  })
  
  return {
    post: postQuery.data,
    author: userQuery.data,
    isLoading: postQuery.isLoading || userQuery.isLoading,
    error: postQuery.error || userQuery.error,
  }
}
```

---

## Advanced State Patterns

### State Normalization and Entity Management

```typescript
// store/slices/entities-slice.ts
import { createSlice, createEntityAdapter, PayloadAction } from '@reduxjs/toolkit'
import type { RootState } from '../index'

interface User {
  id: string
  name: string
  email: string
}

interface Post {
  id: string
  title: string
  content: string
  authorId: string
  categoryIds: string[]
}

interface Category {
  id: string
  name: string
  slug: string
}

// Entity adapters for normalized state
const usersAdapter = createEntityAdapter<User>()
const postsAdapter = createEntityAdapter<Post>({
  sortComparer: (a, b) => b.id.localeCompare(a.id), // Sort by ID descending
})
const categoriesAdapter = createEntityAdapter<Category>({
  selectId: (category) => category.slug, // Use slug as ID
})

interface EntitiesState {
  users: ReturnType<typeof usersAdapter.getInitialState>
  posts: ReturnType<typeof postsAdapter.getInitialState>
  categories: ReturnType<typeof categoriesAdapter.getInitialState>
}

const initialState: EntitiesState = {
  users: usersAdapter.getInitialState(),
  posts: postsAdapter.getInitialState(),
  categories: categoriesAdapter.getInitialState(),
}

const entitiesSlice = createSlice({
  name: 'entities',
  initialState,
  reducers: {
    // Users
    addUser: (state, action: PayloadAction<User>) => {
      usersAdapter.addOne(state.users, action.payload)
    },
    addUsers: (state, action: PayloadAction<User[]>) => {
      usersAdapter.addMany(state.users, action.payload)
    },
    updateUser: (state, action: PayloadAction<{ id: string; changes: Partial<User> }>) => {
      usersAdapter.updateOne(state.users, action.payload)
    },
    removeUser: (state, action: PayloadAction<string>) => {
      usersAdapter.removeOne(state.users, action.payload)
    },
    
    // Posts
    addPost: (state, action: PayloadAction<Post>) => {
      postsAdapter.addOne(state.posts, action.payload)
    },
    addPosts: (state, action: PayloadAction<Post[]>) => {
      postsAdapter.addMany(state.posts, action.payload)
    },
    updatePost: (state, action: PayloadAction<{ id: string; changes: Partial<Post> }>) => {
      postsAdapter.updateOne(state.posts, action.payload)
    },
    removePost: (state, action: PayloadAction<string>) => {
      postsAdapter.removeOne(state.posts, action.payload)
    },
    
    // Categories
    addCategory: (state, action: PayloadAction<Category>) => {
      categoriesAdapter.addOne(state.categories, action.payload)
    },
    addCategories: (state, action: PayloadAction<Category[]>) => {
      categoriesAdapter.addMany(state.categories, action.payload)
    },
    updateCategory: (state, action: PayloadAction<{ id: string; changes: Partial<Category> }>) => {
      categoriesAdapter.updateOne(state.categories, action.payload)
    },
    removeCategory: (state, action: PayloadAction<string>) => {
      categoriesAdapter.removeOne(state.categories, action.payload)
    },
  },
})

export const {
  addUser, addUsers, updateUser, removeUser,
  addPost, addPosts, updatePost, removePost,
  addCategory, addCategories, updateCategory, removeCategory,
} = entitiesSlice.actions

export default entitiesSlice.reducer

// Entity selectors
export const {
  selectAll: selectAllUsers,
  selectById: selectUserById,
  selectIds: selectUserIds,
} = usersAdapter.getSelectors((state: RootState) => state.entities.users)

export const {
  selectAll: selectAllPosts,
  selectById: selectPostById,
  selectIds: selectPostIds,
} = postsAdapter.getSelectors((state: RootState) => state.entities.posts)

export const {
  selectAll: selectAllCategories,
  selectById: selectCategoryById,
  selectIds: selectCategoryIds,
} = categoriesAdapter.getSelectors((state: RootState) => state.entities.categories)

// Complex selectors with relationships
export const selectPostWithAuthor = (state: RootState, postId: string) => {
  const post = selectPostById(state, postId)
  const author = post ? selectUserById(state, post.authorId) : undefined
  
  return post ? { ...post, author } : undefined
}

export const selectPostsByCategory = (state: RootState, categorySlug: string) => {
  const posts = selectAllPosts(state)
  return posts.filter(post => post.categoryIds.includes(categorySlug))
}

export const selectUserPosts = (state: RootState, userId: string) => {
  const posts = selectAllPosts(state)
  return posts.filter(post => post.authorId === userId)
}
```

### Real-Time State Synchronization

```typescript
// lib/websocket-middleware.ts
import { Middleware } from '@reduxjs/toolkit'
import { RootState } from '../store'

interface WebSocketMessage {
  type: string
  payload: any
  timestamp: number
}

export const websocketMiddleware: Middleware<{}, RootState> =
  (store) => (next) => (action) => {
    const result = next(action)
    
    // Send certain actions to WebSocket
    if (action.type.startsWith('entities/') && action.type.includes('add')) {
      const ws = getWebSocket()
      if (ws && ws.readyState === WebSocket.OPEN) {
        const message: WebSocketMessage = {
          type: 'STATE_UPDATE',
          payload: action,
          timestamp: Date.now()
        }
        ws.send(JSON.stringify(message))
      }
    }
    
    return result
  }

let ws: WebSocket | null = null

function getWebSocket(): WebSocket | null {
  if (!ws || ws.readyState === WebSocket.CLOSED) {
    ws = new WebSocket(process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001')
    
    ws.onmessage = (event) => {
      try {
        const message: WebSocketMessage = JSON.parse(event.data)
        // Dispatch incoming actions to Redux store
        if (message.type === 'STATE_UPDATE') {
          store.dispatch(message.payload)
        }
      } catch (error) {
        console.error('WebSocket message parsing error:', error)
      }
    }
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error)
    }
    
    ws.onclose = () => {
      console.log('WebSocket connection closed')
      // Attempt to reconnect after delay
      setTimeout(() => {
        getWebSocket()
      }, 5000)
    }
  }
  
  return ws
}

// Hook for real-time features
export function useRealTimeSync() {
  useEffect(() => {
    getWebSocket()
    
    return () => {
      if (ws) {
        ws.close()
        ws = null
      }
    }
  }, [])
}
```

---

## Server-Client State Synchronization

### Hydration and SSR State Management

```typescript
// lib/store-provider.tsx
'use client'

import { useRef } from 'react'
import { Provider } from 'react-redux'
import { PersistGate } from 'redux-persist/integration/react'
import { persistStore } from 'redux-persist'
import { store } from '../store'

interface StoreProviderProps {
  children: React.ReactNode
  initialState?: any
}

export function StoreProvider({ children, initialState }: StoreProviderProps) {
  const persistor = useRef(persistStore(store))
  
  // Hydrate store with server-side state
  useEffect(() => {
    if (initialState) {
      store.dispatch({ type: 'HYDRATE', payload: initialState })
    }
  }, [initialState])

  return (
    <Provider store={store}>
      <PersistGate loading={<div>Loading...</div>} persistor={persistor.current}>
        {children}
      </PersistGate>
    </Provider>
  )
}

// Server-side state preparation
export async function getServerSideProps(context: GetServerSidePropsContext) {
  // Fetch initial data on server
  const initialData = await fetchInitialData(context)
  
  return {
    props: {
      initialState: {
        entities: {
          users: initialData.users,
          posts: initialData.posts,
        },
      },
    },
  }
}
```

### State Persistence and Rehydration

```typescript
// store/persistence-config.ts
import { persistReducer, PersistConfig } from 'redux-persist'
import storage from 'redux-persist/lib/storage'
import { RootState } from './index'

// Configure what gets persisted
const persistConfig: PersistConfig<RootState> = {
  key: 'root',
  storage,
  whitelist: ['auth', 'ui'], // Only persist auth and UI state
  blacklist: ['api'], // Don't persist API cache
  transforms: [
    // Transform to exclude sensitive data
    {
      in: (inboundState: any, key: string) => {
        if (key === 'auth') {
          // Don't persist tokens or sensitive data
          const { tokens, ...safeState } = inboundState
          return safeState
        }
        return inboundState
      },
      out: (outboundState: any, key: string) => {
        return outboundState
      },
    },
  ],
}

// Nested persist config for specific slices
const authPersistConfig: PersistConfig<any> = {
  key: 'auth',
  storage,
  whitelist: ['user', 'isAuthenticated'], // Only persist user and auth status
}

export { persistConfig, authPersistConfig }
```

---

## Real-World Implementation

### Complete E-commerce Store Implementation

```typescript
// store/ecommerce-store.ts
import { create } from 'zustand'
import { devtools, persist, subscribeWithSelector } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

interface Product {
  id: string
  name: string
  price: number
  description: string
  imageUrl: string
  category: string
  inStock: boolean
  variants: ProductVariant[]
}

interface ProductVariant {
  id: string
  name: string
  price: number
  attributes: Record<string, string>
}

interface CartItem {
  productId: string
  variantId?: string
  quantity: number
  price: number
}

interface CartState {
  items: CartItem[]
  total: number
  itemCount: number
  discounts: Discount[]
  shippingCost: number
}

interface Discount {
  id: string
  code: string
  type: 'percentage' | 'fixed'
  value: number
  minOrder?: number
}

interface EcommerceState {
  // Products
  products: Product[]
  categories: string[]
  searchQuery: string
  filters: ProductFilters
  
  // Cart
  cart: CartState
  
  // User preferences
  favorites: string[]
  recentlyViewed: string[]
  
  // UI state
  cartOpen: boolean
  checkoutStep: number
  
  // Actions
  setProducts: (products: Product[]) => void
  addToCart: (productId: string, variantId?: string, quantity?: number) => void
  removeFromCart: (productId: string, variantId?: string) => void
  updateCartQuantity: (productId: string, variantId: string | undefined, quantity: number) => void
  clearCart: () => void
  
  addToFavorites: (productId: string) => void
  removeFromFavorites: (productId: string) => void
  
  addToRecentlyViewed: (productId: string) => void
  
  setSearchQuery: (query: string) => void
  setFilters: (filters: ProductFilters) => void
  
  openCart: () => void
  closeCart: () => void
  setCheckoutStep: (step: number) => void
  
  // Computed
  getCartTotal: () => number
  getFilteredProducts: () => Product[]
  getFavoriteProducts: () => Product[]
}

interface ProductFilters {
  category?: string
  priceRange?: [number, number]
  inStock?: boolean
  sortBy?: 'name' | 'price' | 'popularity'
  sortOrder?: 'asc' | 'desc'
}

export const useEcommerceStore = create<EcommerceState>()(
  devtools(
    persist(
      subscribeWithSelector(
        immer((set, get) => ({
          // Initial state
          products: [],
          categories: [],
          searchQuery: '',
          filters: {},
          
          cart: {
            items: [],
            total: 0,
            itemCount: 0,
            discounts: [],
            shippingCost: 0,
          },
          
          favorites: [],
          recentlyViewed: [],
          
          cartOpen: false,
          checkoutStep: 1,

          // Actions
          setProducts: (products) => {
            set((state) => {
              state.products = products
              state.categories = [...new Set(products.map(p => p.category))]
            })
          },

          addToCart: (productId, variantId, quantity = 1) => {
            set((state) => {
              const product = state.products.find(p => p.id === productId)
              if (!product) return

              const variant = variantId 
                ? product.variants.find(v => v.id === variantId)
                : null
              
              const price = variant?.price || product.price
              const existingItem = state.cart.items.find(
                item => item.productId === productId && item.variantId === variantId
              )

              if (existingItem) {
                existingItem.quantity += quantity
              } else {
                state.cart.items.push({
                  productId,
                  variantId,
                  quantity,
                  price,
                })
              }

              // Recalculate totals
              state.cart.itemCount = state.cart.items.reduce((sum, item) => sum + item.quantity, 0)
              state.cart.total = state.cart.items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
            })
          },

          removeFromCart: (productId, variantId) => {
            set((state) => {
              state.cart.items = state.cart.items.filter(
                item => !(item.productId === productId && item.variantId === variantId)
              )
              
              // Recalculate totals
              state.cart.itemCount = state.cart.items.reduce((sum, item) => sum + item.quantity, 0)
              state.cart.total = state.cart.items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
            })
          },

          updateCartQuantity: (productId, variantId, quantity) => {
            set((state) => {
              const item = state.cart.items.find(
                item => item.productId === productId && item.variantId === variantId
              )
              
              if (item) {
                if (quantity <= 0) {
                  state.cart.items = state.cart.items.filter(i => i !== item)
                } else {
                  item.quantity = quantity
                }
                
                // Recalculate totals
                state.cart.itemCount = state.cart.items.reduce((sum, item) => sum + item.quantity, 0)
                state.cart.total = state.cart.items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
              }
            })
          },

          clearCart: () => {
            set((state) => {
              state.cart.items = []
              state.cart.total = 0
              state.cart.itemCount = 0
              state.cart.discounts = []
            })
          },

          addToFavorites: (productId) => {
            set((state) => {
              if (!state.favorites.includes(productId)) {
                state.favorites.push(productId)
              }
            })
          },

          removeFromFavorites: (productId) => {
            set((state) => {
              state.favorites = state.favorites.filter(id => id !== productId)
            })
          },

          addToRecentlyViewed: (productId) => {
            set((state) => {
              state.recentlyViewed = [
                productId,
                ...state.recentlyViewed.filter(id => id !== productId)
              ].slice(0, 20) // Keep only last 20 items
            })
          },

          setSearchQuery: (query) => {
            set((state) => {
              state.searchQuery = query
            })
          },

          setFilters: (filters) => {
            set((state) => {
              state.filters = { ...state.filters, ...filters }
            })
          },

          openCart: () => set((state) => { state.cartOpen = true }),
          closeCart: () => set((state) => { state.cartOpen = false }),
          
          setCheckoutStep: (step) => {
            set((state) => {
              state.checkoutStep = step
            })
          },

          // Computed getters
          getCartTotal: () => {
            const { cart } = get()
            const subtotal = cart.items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
            const discountAmount = cart.discounts.reduce((sum, discount) => {
              return sum + (discount.type === 'percentage' 
                ? subtotal * (discount.value / 100)
                : discount.value)
            }, 0)
            return subtotal - discountAmount + cart.shippingCost
          },

          getFilteredProducts: () => {
            const { products, searchQuery, filters } = get()
            
            let filtered = products.filter(product => {
              // Search query filter
              if (searchQuery) {
                const query = searchQuery.toLowerCase()
                if (!product.name.toLowerCase().includes(query) &&
                    !product.description.toLowerCase().includes(query)) {
                  return false
                }
              }
              
              // Category filter
              if (filters.category && product.category !== filters.category) {
                return false
              }
              
              // Price range filter
              if (filters.priceRange) {
                const [min, max] = filters.priceRange
                if (product.price < min || product.price > max) {
                  return false
                }
              }
              
              // Stock filter
              if (filters.inStock !== undefined && product.inStock !== filters.inStock) {
                return false
              }
              
              return true
            })

            // Sorting
            if (filters.sortBy) {
              filtered.sort((a, b) => {
                let comparison = 0
                
                switch (filters.sortBy) {
                  case 'name':
                    comparison = a.name.localeCompare(b.name)
                    break
                  case 'price':
                    comparison = a.price - b.price
                    break
                  default:
                    comparison = 0
                }
                
                return filters.sortOrder === 'desc' ? -comparison : comparison
              })
            }

            return filtered
          },

          getFavoriteProducts: () => {
            const { products, favorites } = get()
            return products.filter(product => favorites.includes(product.id))
          },
        }))
      ),
      {
        name: 'ecommerce-storage',
        partialize: (state) => ({
          cart: state.cart,
          favorites: state.favorites,
          recentlyViewed: state.recentlyViewed,
        }),
      }
    ),
    { name: 'ecommerce-store' }
  )
)

// Selectors for specific use cases
export const useCart = () => useEcommerceStore((state) => ({
  items: state.cart.items,
  total: state.getCartTotal(),
  itemCount: state.cart.itemCount,
  isOpen: state.cartOpen,
}))

export const useCartActions = () => useEcommerceStore((state) => ({
  addToCart: state.addToCart,
  removeFromCart: state.removeFromCart,
  updateQuantity: state.updateCartQuantity,
  clearCart: state.clearCart,
  openCart: state.openCart,
  closeCart: state.closeCart,
}))

export const useProducts = () => useEcommerceStore((state) => ({
  products: state.getFilteredProducts(),
  categories: state.categories,
  searchQuery: state.searchQuery,
  filters: state.filters,
}))

export const useProductActions = () => useEcommerceStore((state) => ({
  setProducts: state.setProducts,
  setSearchQuery: state.setSearchQuery,
  setFilters: state.setFilters,
  addToFavorites: state.addToFavorites,
  removeFromFavorites: state.removeFromFavorites,
  addToRecentlyViewed: state.addToRecentlyViewed,
}))

// Subscribe to cart changes for analytics
useEcommerceStore.subscribe(
  (state) => state.cart.items,
  (items, previousItems) => {
    // Track cart changes for analytics
    if (items.length > previousItems.length) {
      // Item added to cart
      const newItem = items.find(item => 
        !previousItems.some(prevItem => 
          prevItem.productId === item.productId && 
          prevItem.variantId === item.variantId
        )
      )
      
      if (newItem) {
        console.log('Item added to cart:', newItem)
        // Send to analytics service
      }
    }
  }
)
```

This comprehensive guide demonstrates how to implement type-safe state management in Next.js applications using both Zustand and Redux Toolkit, providing patterns that scale from simple applications to complex enterprise systems with complete TypeScript support throughout.