# Basic Data Fetching in Next.js - Complete Guide

## Table of Contents
1. [Data Fetching Fundamentals](#data-fetching-fundamentals)
2. [Server Components and Fetch](#server-components-fetch)
3. [Typing API Responses](#typing-api-responses)
4. [Error Handling Patterns](#error-handling)
5. [Caching and Revalidation](#caching-revalidation)
6. [Advanced Data Fetching Patterns](#advanced-patterns)
7. [Performance Optimization](#performance-optimization)
8. [Real-World Examples](#real-world-examples)

---

## Data Fetching Fundamentals {#data-fetching-fundamentals}

### How Data Fetching Works in Next.js 13+

Next.js 13+ with App Router revolutionizes data fetching by allowing **Server Components** to fetch data directly during rendering. This eliminates the need for `getServerSideProps`, `getStaticProps`, and `useEffect` for initial data loading.

### First Principles: Server vs Client Data Fetching

```
Traditional Client-Side Fetching:
1. Browser requests page ‚Üí 2. Server sends HTML ‚Üí 3. Browser loads JS ‚Üí 4. JS fetches data ‚Üí 5. Component re-renders

Next.js Server Component Fetching:
1. Browser requests page ‚Üí 2. Server fetches data ‚Üí 3. Server renders HTML with data ‚Üí 4. Browser receives complete page
```

### The Fetch API in Different Environments

```tsx
// Server Component (runs on server)
const ServerComponent = async () => {
  // This fetch happens on the server during rendering
  const data = await fetch('https://api.example.com/data');
  // Server has access to environment variables, databases, file systems
};

// Client Component (runs in browser)
'use client';
const ClientComponent = () => {
  useEffect(() => {
    // This fetch happens in the browser after hydration
    fetch('https://api.example.com/data');
    // Browser has access to DOM, localStorage, user interactions
  }, []);
};
```

---

## Server Components and Fetch {#server-components-fetch}

### Basic Server Component Data Fetching

```tsx
// app/users/page.tsx
// This is a Server Component by default (no "use client" directive)

// First, let's define our data types
interface User {
  id: number;
  name: string;
  username: string;
  email: string;
  address: {
    street: string;
    suite: string;
    city: string;
    zipcode: string;
    geo: {
      lat: string;
      lng: string;
    };
  };
  phone: string;
  website: string;
  company: {
    name: string;
    catchPhrase: string;
    bs: string;
  };
}

// Server Component can be async!
const UsersPage = async () => {
  // This fetch happens on the server during rendering
  const response = await fetch('https://jsonplaceholder.typicode.com/users');
  
  // Always check if the response is ok
  if (!response.ok) {
    throw new Error('Failed to fetch users');
  }
  
  // Parse JSON and type it
  const users: User[] = await response.json();
  
  // Return JSX that's pre-rendered on the server
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Users</h1>
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {users.map(user => (
          <UserCard key={user.id} user={user} />
        ))}
      </div>
    </div>
  );
};

// Separate component for each user card
const UserCard: React.FC<{ user: User }> = ({ user }) => {
  return (
    <div className="bg-white rounded-lg shadow-md p-6 border">
      <h2 className="text-xl font-semibold mb-2">{user.name}</h2>
      <p className="text-gray-600 mb-1">@{user.username}</p>
      <p className="text-gray-600 mb-2">{user.email}</p>
      
      <div className="text-sm text-gray-500">
        <p>{user.address.city}, {user.address.zipcode}</p>
        <p>{user.phone}</p>
        <p className="font-medium mt-2">{user.company.name}</p>
        <p className="italic">{user.company.catchPhrase}</p>
      </div>
    </div>
  );
};

export default UsersPage;
```

### Advanced Server Component Patterns

```tsx
// app/dashboard/page.tsx
// Multiple data sources with parallel fetching

interface DashboardData {
  users: User[];
  posts: Post[];
  analytics: Analytics;
}

interface Post {
  id: number;
  userId: number;
  title: string;
  body: string;
}

interface Analytics {
  totalUsers: number;
  totalPosts: number;
  activeUsers: number;
  recentActivity: ActivityItem[];
}

interface ActivityItem {
  id: string;
  type: 'user_joined' | 'post_created' | 'comment_added';
  timestamp: string;
  userId: number;
  description: string;
}

const DashboardPage = async () => {
  // Parallel data fetching for better performance
  const [usersResponse, postsResponse, analyticsResponse] = await Promise.all([
    fetch('https://jsonplaceholder.typicode.com/users'),
    fetch('https://jsonplaceholder.typicode.com/posts?_limit=10'),
    fetch('https://api.internal.com/analytics', {
      headers: {
        'Authorization': `Bearer ${process.env.API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    })
  ]);

  // Check all responses
  if (!usersResponse.ok) throw new Error('Failed to fetch users');
  if (!postsResponse.ok) throw new Error('Failed to fetch posts');
  if (!analyticsResponse.ok) throw new Error('Failed to fetch analytics');

  // Parse all data with proper typing
  const [users, posts, analytics]: [User[], Post[], Analytics] = await Promise.all([
    usersResponse.json(),
    postsResponse.json(),
    analyticsResponse.json()
  ]);

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-8">Dashboard</h1>
        
        {/* Analytics Overview */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
          <StatCard
            title="Total Users"
            value={analytics.totalUsers}
            icon="üë•"
          />
          <StatCard
            title="Total Posts"
            value={analytics.totalPosts}
            icon="üìù"
          />
          <StatCard
            title="Active Users"
            value={analytics.activeUsers}
            icon="üü¢"
          />
          <StatCard
            title="Engagement Rate"
            value={`${Math.round((analytics.activeUsers / analytics.totalUsers) * 100)}%`}
            icon="üìä"
          />
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          {/* Recent Users */}
          <div className="lg:col-span-1">
            <h2 className="text-xl font-semibold mb-4">Recent Users</h2>
            <div className="space-y-3">
              {users.slice(0, 5).map(user => (
                <div key={user.id} className="bg-white p-4 rounded-lg shadow">
                  <h3 className="font-medium">{user.name}</h3>
                  <p className="text-sm text-gray-600">{user.email}</p>
                </div>
              ))}
            </div>
          </div>

          {/* Recent Posts */}
          <div className="lg:col-span-2">
            <h2 className="text-xl font-semibold mb-4">Recent Posts</h2>
            <div className="space-y-4">
              {posts.map(post => (
                <div key={post.id} className="bg-white p-6 rounded-lg shadow">
                  <h3 className="font-semibold mb-2">{post.title}</h3>
                  <p className="text-gray-600 text-sm line-clamp-2">{post.body}</p>
                  <div className="mt-3 text-xs text-gray-500">
                    By User {post.userId}
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

const StatCard: React.FC<{
  title: string;
  value: string | number;
  icon: string;
}> = ({ title, value, icon }) => (
  <div className="bg-white p-6 rounded-lg shadow">
    <div className="flex items-center justify-between">
      <div>
        <p className="text-sm text-gray-600">{title}</p>
        <p className="text-2xl font-bold">{value}</p>
      </div>
      <span className="text-2xl">{icon}</span>
    </div>
  </div>
);

export default DashboardPage;
```

### Dynamic Data Fetching with Parameters

```tsx
// app/users/[id]/page.tsx
// Server Component with dynamic routing

interface UserPageProps {
  params: {
    id: string;
  };
}

interface UserDetail extends User {
  posts: Post[];
  todos: Todo[];
}

interface Todo {
  id: number;
  userId: number;
  title: string;
  completed: boolean;
}

const UserDetailPage = async ({ params }: UserPageProps) => {
  const userId = params.id;
  
  // Validate the ID
  if (!userId || isNaN(Number(userId))) {
    throw new Error('Invalid user ID');
  }

  try {
    // Fetch user details and related data in parallel
    const [userResponse, postsResponse, todosResponse] = await Promise.all([
      fetch(`https://jsonplaceholder.typicode.com/users/${userId}`),
      fetch(`https://jsonplaceholder.typicode.com/posts?userId=${userId}`),
      fetch(`https://jsonplaceholder.typicode.com/todos?userId=${userId}`)
    ]);

    // Check if user exists
    if (userResponse.status === 404) {
      throw new Error('User not found');
    }

    if (!userResponse.ok) throw new Error('Failed to fetch user');
    if (!postsResponse.ok) throw new Error('Failed to fetch posts');
    if (!todosResponse.ok) throw new Error('Failed to fetch todos');

    // Parse responses with proper typing
    const [user, posts, todos]: [User, Post[], Todo[]] = await Promise.all([
      userResponse.json(),
      postsResponse.json(),
      todosResponse.json()
    ]);

    return (
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-4xl mx-auto">
          {/* User Profile Header */}
          <div className="bg-white rounded-lg shadow-lg p-8 mb-8">
            <div className="flex flex-col md:flex-row md:items-center md:justify-between">
              <div>
                <h1 className="text-3xl font-bold text-gray-900 mb-2">
                  {user.name}
                </h1>
                <p className="text-gray-600 mb-1">@{user.username}</p>
                <p className="text-gray-600 mb-4">{user.email}</p>
                
                <div className="space-y-1 text-sm text-gray-500">
                  <p>üìç {user.address.city}, {user.address.zipcode}</p>
                  <p>üìû {user.phone}</p>
                  <p>üåê {user.website}</p>
                  <p>üè¢ {user.company.name}</p>
                </div>
              </div>
              
              <div className="mt-6 md:mt-0">
                <div className="flex space-x-4">
                  <div className="text-center">
                    <div className="text-2xl font-bold text-blue-600">
                      {posts.length}
                    </div>
                    <div className="text-sm text-gray-500">Posts</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-green-600">
                      {todos.filter(todo => todo.completed).length}
                    </div>
                    <div className="text-sm text-gray-500">Completed</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-orange-600">
                      {todos.filter(todo => !todo.completed).length}
                    </div>
                    <div className="text-sm text-gray-500">Pending</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            {/* Posts Section */}
            <div>
              <h2 className="text-xl font-semibold mb-4">Recent Posts</h2>
              <div className="space-y-4">
                {posts.slice(0, 5).map(post => (
                  <div key={post.id} className="bg-white p-6 rounded-lg shadow">
                    <h3 className="font-semibold mb-2 text-gray-900">
                      {post.title}
                    </h3>
                    <p className="text-gray-600 text-sm leading-relaxed">
                      {post.body}
                    </p>
                  </div>
                ))}
              </div>
            </div>

            {/* Todos Section */}
            <div>
              <h2 className="text-xl font-semibold mb-4">Tasks</h2>
              <div className="space-y-2">
                {todos.map(todo => (
                  <div
                    key={todo.id}
                    className={`p-4 rounded-lg border-l-4 ${
                      todo.completed
                        ? 'bg-green-50 border-green-400'
                        : 'bg-yellow-50 border-yellow-400'
                    }`}
                  >
                    <div className="flex items-center">
                      <span className={`mr-3 ${
                        todo.completed ? 'text-green-600' : 'text-yellow-600'
                      }`}>
                        {todo.completed ? '‚úÖ' : '‚è≥'}
                      </span>
                      <span className={`text-sm ${
                        todo.completed ? 'line-through text-gray-500' : 'text-gray-900'
                      }`}>
                        {todo.title}
                      </span>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  } catch (error) {
    // Error handling will be covered in detail later
    throw new Error(`Failed to load user data: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

export default UserDetailPage;
```

---

## Typing API Responses {#typing-api-responses}

### Creating Strong Type Definitions

```tsx
// types/api.ts
// Base API response wrapper
interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// Error response type
interface ApiError {
  success: false;
  error: {
    code: string;
    message: string;
    details?: Record<string, any>;
  };
  timestamp: string;
}

// User-related types
interface User {
  readonly id: number;
  name: string;
  username: string;
  email: string;
  avatar?: string;
  status: 'active' | 'inactive' | 'suspended';
  roles: Role[];
  profile: UserProfile;
  createdAt: string; // ISO date string
  updatedAt: string; // ISO date string
}

interface Role {
  id: number;
  name: string;
  permissions: Permission[];
}

interface Permission {
  id: number;
  name: string;
  resource: string;
  action: 'create' | 'read' | 'update' | 'delete';
}

interface UserProfile {
  firstName: string;
  lastName: string;
  bio?: string;
  location?: string;
  website?: string;
  birthDate?: string;
  preferences: UserPreferences;
}

interface UserPreferences {
  theme: 'light' | 'dark' | 'auto';
  language: string;
  timezone: string;
  notifications: {
    email: boolean;
    push: boolean;
    sms: boolean;
  };
}

// Product-related types
interface Product {
  readonly id: string;
  name: string;
  description: string;
  price: number;
  currency: 'USD' | 'EUR' | 'GBP';
  images: ProductImage[];
  categories: Category[];
  variants: ProductVariant[];
  inventory: {
    inStock: boolean;
    quantity: number;
    reservedQuantity: number;
  };
  metadata: {
    weight?: number;
    dimensions?: {
      length: number;
      width: number;
      height: number;
      unit: 'cm' | 'in';
    };
    tags: string[];
  };
  createdAt: string;
  updatedAt: string;
}

interface ProductImage {
  id: string;
  url: string;
  alt: string;
  isPrimary: boolean;
  order: number;
}

interface Category {
  id: string;
  name: string;
  slug: string;
  parentId?: string;
  level: number;
}

interface ProductVariant {
  id: string;
  name: string;
  sku: string;
  price: number;
  attributes: {
    color?: string;
    size?: string;
    material?: string;
    [key: string]: string | undefined;
  };
  inventory: {
    quantity: number;
    reservedQuantity: number;
  };
}

// Order-related types
interface Order {
  readonly id: string;
  userId: number;
  status: 'pending' | 'confirmed' | 'shipped' | 'delivered' | 'cancelled';
  items: OrderItem[];
  shipping: ShippingInfo;
  billing: BillingInfo;
  totals: OrderTotals;
  createdAt: string;
  updatedAt: string;
}

interface OrderItem {
  id: string;
  productId: string;
  variantId?: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  product: Pick<Product, 'id' | 'name' | 'images'>;
}

interface ShippingInfo {
  address: Address;
  method: 'standard' | 'express' | 'overnight';
  cost: number;
  estimatedDelivery: string;
  trackingNumber?: string;
}

interface BillingInfo {
  address: Address;
  paymentMethod: {
    type: 'credit_card' | 'paypal' | 'bank_transfer';
    last4?: string;
    brand?: string;
  };
}

interface Address {
  firstName: string;
  lastName: string;
  company?: string;
  streetAddress1: string;
  streetAddress2?: string;
  city: string;
  state: string;
  postalCode: string;
  country: string;
  phone?: string;
}

interface OrderTotals {
  subtotal: number;
  shipping: number;
  tax: number;
  discount: number;
  total: number;
  currency: string;
}

export type {
  ApiResponse,
  ApiError,
  User,
  Role,
  Permission,
  UserProfile,
  UserPreferences,
  Product,
  ProductImage,
  Category,
  ProductVariant,
  Order,
  OrderItem,
  ShippingInfo,
  BillingInfo,
  Address,
  OrderTotals
};
```

### API Service Layer with Types

```tsx
// lib/api.ts
// Centralized API service with proper typing

import { ApiResponse, ApiError, User, Product, Order } from '@/types/api';

// Base configuration
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'https://api.example.com';
const API_VERSION = 'v1';

// Custom fetch wrapper with error handling and typing
async function apiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const url = `${API_BASE_URL}/${API_VERSION}${endpoint}`;
  
  const defaultHeaders: HeadersInit = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  };

  // Add authentication headers if needed
  const authToken = process.env.API_SECRET || process.env.NEXT_PUBLIC_API_TOKEN;
  if (authToken) {
    defaultHeaders['Authorization'] = `Bearer ${authToken}`;
  }

  const config: RequestInit = {
    ...options,
    headers: {
      ...defaultHeaders,
      ...options.headers,
    },
  };

  try {
    const response = await fetch(url, config);
    
    // Parse response as JSON
    const data = await response.json();
    
    if (!response.ok) {
      // Handle API errors
      const error: ApiError = data;
      throw new Error(`API Error ${response.status}: ${error.error?.message || 'Unknown error'}`);
    }
    
    // Return typed data
    return data;
  } catch (error) {
    if (error instanceof Error) {
      throw error;
    }
    throw new Error('Network error occurred');
  }
}

// User API methods
export const userApi = {
  // Get all users with pagination
  async getUsers(params: {
    page?: number;
    limit?: number;
    search?: string;
    role?: string;
  } = {}): Promise<ApiResponse<User[]>> {
    const searchParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        searchParams.append(key, value.toString());
      }
    });
    
    return apiRequest<ApiResponse<User[]>>(`/users?${searchParams.toString()}`);
  },

  // Get single user by ID
  async getUserById(id: number): Promise<User> {
    const response = await apiRequest<ApiResponse<User>>(`/users/${id}`);
    return response.data;
  },

  // Create new user
  async createUser(userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>): Promise<User> {
    const response = await apiRequest<ApiResponse<User>>('/users', {
      method: 'POST',
      body: JSON.stringify(userData),
    });
    return response.data;
  },

  // Update user
  async updateUser(id: number, userData: Partial<User>): Promise<User> {
    const response = await apiRequest<ApiResponse<User>>(`/users/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(userData),
    });
    return response.data;
  },

  // Delete user
  async deleteUser(id: number): Promise<void> {
    await apiRequest<ApiResponse<null>>(`/users/${id}`, {
      method: 'DELETE',
    });
  }
};

// Product API methods
export const productApi = {
  async getProducts(params: {
    page?: number;
    limit?: number;
    category?: string;
    search?: string;
    sortBy?: 'name' | 'price' | 'createdAt';
    sortOrder?: 'asc' | 'desc';
  } = {}): Promise<ApiResponse<Product[]>> {
    const searchParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        searchParams.append(key, value.toString());
      }
    });
    
    return apiRequest<ApiResponse<Product[]>>(`/products?${searchParams.toString()}`);
  },

  async getProductById(id: string): Promise<Product> {
    const response = await apiRequest<ApiResponse<Product>>(`/products/${id}`);
    return response.data;
  },

  async getFeaturedProducts(limit: number = 10): Promise<Product[]> {
    const response = await apiRequest<ApiResponse<Product[]>>(`/products/featured?limit=${limit}`);
    return response.data;
  }
};

// Order API methods
export const orderApi = {
  async getOrders(userId?: number, params: {
    page?: number;
    limit?: number;
    status?: string;
  } = {}): Promise<ApiResponse<Order[]>> {
    const searchParams = new URLSearchParams();
    if (userId) searchParams.append('userId', userId.toString());
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        searchParams.append(key, value.toString());
      }
    });
    
    return apiRequest<ApiResponse<Order[]>>(`/orders?${searchParams.toString()}`);
  },

  async getOrderById(id: string): Promise<Order> {
    const response = await apiRequest<ApiResponse<Order>>(`/orders/${id}`);
    return response.data;
  },

  async createOrder(orderData: Omit<Order, 'id' | 'createdAt' | 'updatedAt'>): Promise<Order> {
    const response = await apiRequest<ApiResponse<Order>>('/orders', {
      method: 'POST',
      body: JSON.stringify(orderData),
    });
    return response.data;
  }
};

// Analytics API methods
export const analyticsApi = {
  async getDashboardStats(): Promise<{
    totalUsers: number;
    totalProducts: number;
    totalOrders: number;
    revenue: number;
  }> {
    const response = await apiRequest<ApiResponse<any>>('/analytics/dashboard');
    return response.data;
  },

  async getUserGrowth(period: '7d' | '30d' | '90d' | '1y'): Promise<{
    date: string;
    count: number;
  }[]> {
    const response = await apiRequest<ApiResponse<any>>(`/analytics/users/growth?period=${period}`);
    return response.data;
  }
};
```

### Using Typed APIs in Server Components

```tsx
// app/admin/users/page.tsx
import { userApi } from '@/lib/api';
import { User } from '@/types/api';
import UserTable from '@/components/UserTable';
import Pagination from '@/components/Pagination';

interface UsersPageProps {
  searchParams: {
    page?: string;
    search?: string;
    role?: string;
  };
}

const AdminUsersPage = async ({ searchParams }: UsersPageProps) => {
  const page = parseInt(searchParams.page || '1', 10);
  const search = searchParams.search;
  const role = searchParams.role;

  try {
    // Fetch users with type safety
    const response = await userApi.getUsers({
      page,
      limit: 20,
      search,
      role
    });

    const { data: users, pagination } = response;

    return (
      <div className="container mx-auto px-4 py-8">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">User Management</h1>
          <button className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
            Add New User
          </button>
        </div>

        {/* Search and Filters */}
        <div className="mb-6 flex flex-col sm:flex-row gap-4">
          <div className="flex-1">
            <input
              type="text"
              placeholder="Search users..."
              defaultValue={search}
              className="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
            />
          </div>
          <select
            defaultValue={role}
            className="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Roles</option>
            <option value="admin">Admin</option>
            <option value="user">User</option>
            <option value="moderator">Moderator</option>
          </select>
        </div>

        {/* Users Table */}
        <div className="bg-white rounded-lg shadow overflow-hidden">
          <UserTable users={users} />
        </div>

        {/* Pagination */}
        {pagination && (
          <div className="mt-6">
            <Pagination
              currentPage={pagination.page}
              totalPages={pagination.totalPages}
              totalItems={pagination.total}
            />
          </div>
        )}
      </div>
    );
  } catch (error) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-red-50 border border-red-200 rounded-lg p-6">
          <h2 className="text-lg font-semibold text-red-800 mb-2">
            Error Loading Users
          </h2>
          <p className="text-red-600">
            {error instanceof Error ? error.message : 'An unexpected error occurred'}
          </p>
        </div>
      </div>
    );
  }
};

export default AdminUsersPage;
```

---

## Error Handling Patterns {#error-handling}

### Error Boundaries and Error Pages

```tsx
// app/error.tsx
// Global error boundary for the app
'use client';

import { useEffect } from 'react';

interface ErrorPageProps {
  error: Error & { digest?: string };
  reset: () => void;
}

const ErrorPage: React.FC<ErrorPageProps> = ({ error, reset }) => {
  useEffect(() => {
    // Log error to monitoring service
    console.error('Application error:', error);
    
    // Send to error tracking service
    if (process.env.NODE_ENV === 'production') {
      // Example: Sentry, LogRocket, etc.
      // errorTracker.captureException(error);
    }
  }, [error]);

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-6">
        <div className="flex items-center justify-center w-12 h-12 mx-auto bg-red-100 rounded-full mb-4">
          <svg className="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
          </svg>
        </div>
        
        <h1 className="text-xl font-semibold text-center text-gray-900 mb-2">
          Something went wrong!
        </h1>
        
        <p className="text-gray-600 text-center mb-6">
          We're sorry, but something unexpected happened. Please try again.
        </p>
        
        {process.env.NODE_ENV === 'development' && (
          <details className="mb-4 p-3 bg-gray-100 rounded text-sm">
            <summary className="cursor-pointer font-medium">Error Details</summary>
            <pre className="mt-2 whitespace-pre-wrap text-xs text-red-600">
              {error.message}
              {error.stack && `\n\n${error.stack}`}
            </pre>
          </details>
        )}
        
        <div className="flex space-x-3">
          <button
            onClick={reset}
            className="flex-1 bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600 transition-colors"
          >
            Try Again
          </button>
          <button
            onClick={() => window.location.href = '/'}
            className="flex-1 bg-gray-500 text-white py-2 px-4 rounded hover:bg-gray-600 transition-colors"
          >
            Go Home
          </button>
        </div>
      </div>
    </div>
  );
};

export default ErrorPage;
```

### Custom Error Types and Handling

```tsx
// lib/errors.ts
// Custom error classes for better error handling

export class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public code?: string,
    public details?: Record<string, any>
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    public value?: any
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class NotFoundError extends Error {
  constructor(resource: string, id: string | number) {
    super(`${resource} with ID ${id} not found`);
    this.name = 'NotFoundError';
  }
}

export class UnauthorizedError extends Error {
  constructor(message = 'Unauthorized access') {
    super(message);
    this.name = 'UnauthorizedError';
  }
}

// Error handler utility
export function handleApiError(error: unknown): {
  message: string;
  statusCode: number;
  type: string;
} {
  if (error instanceof ApiError) {
    return {
      message: error.message,
      statusCode: error.statusCode,
      type: 'api_error'
    };
  }
  
  if (error instanceof ValidationError) {
    return {
      message: error.message,
      statusCode: 400,
      type: 'validation_error'
    };
  }
  
  if (error instanceof NotFoundError) {
    return {
      message: error.message,
      statusCode: 404,
      type: 'not_found'
    };
  }
  
  if (error instanceof UnauthorizedError) {
    return {
      message: error.message,
      statusCode: 401,
      type: 'unauthorized'
    };
  }
  
  // Network or unknown errors
  return {
    message: error instanceof Error ? error.message : 'An unexpected error occurred',
    statusCode: 500,
    type: 'unknown_error'
  };
}

// Enhanced API request with better error handling
export async function safeApiRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<{ data: T | null; error: string | null }> {
  try {
    const response = await apiRequest<T>(endpoint, options);
    return { data: response, error: null };
  } catch (error) {
    const errorInfo = handleApiError(error);
    return { data: null, error: errorInfo.message };
  }
}
```

### Error Handling in Server Components

```tsx
// app/products/[id]/page.tsx
// Server Component with comprehensive error handling

import { notFound } from 'next/navigation';
import { productApi } from '@/lib/api';
import { ApiError, NotFoundError, handleApiError } from '@/lib/errors';

interface ProductPageProps {
  params: {
    id: string;
  };
}

const ProductPage = async ({ params }: ProductPageProps) => {
  const { id } = params;

  // Validate product ID format
  if (!id || id.length < 1) {
    throw new Error('Invalid product ID');
  }

  try {
    // Fetch product data
    const product = await productApi.getProductById(id);
    
    // Additional validation
    if (!product) {
      notFound(); // This will render the not-found.tsx page
    }

    return (
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-6xl mx-auto">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            {/* Product Images */}
            <div className="space-y-4">
              {product.images.map((image, index) => (
                <div key={image.id} className="aspect-square relative">
                  <img
                    src={image.url}
                    alt={image.alt}
                    className="w-full h-full object-cover rounded-lg"
                  />
                </div>
              ))}
            </div>

            {/* Product Details */}
            <div className="space-y-6">
              <div>
                <h1 className="text-3xl font-bold text-gray-900 mb-2">
                  {product.name}
                </h1>
                <p className="text-2xl font-semibold text-blue-600">
                  {product.price} {product.currency}
                </p>
              </div>

              <div>
                <h3 className="text-lg font-semibold mb-2">Description</h3>
                <p className="text-gray-600 leading-relaxed">
                  {product.description}
                </p>
              </div>

              {/* Inventory Status */}
              <div className="flex items-center space-x-2">
                <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                  product.inventory.inStock
                    ? 'bg-green-100 text-green-800'
                    : 'bg-red-100 text-red-800'
                }`}>
                  {product.inventory.inStock ? 'In Stock' : 'Out of Stock'}
                </span>
                {product.inventory.inStock && (
                  <span className="text-sm text-gray-500">
                    {product.inventory.quantity} available
                  </span>
                )}
              </div>

              {/* Categories */}
              <div>
                <h3 className="text-lg font-semibold mb-2">Categories</h3>
                <div className="flex flex-wrap gap-2">
                  {product.categories.map(category => (
                    <span
                      key={category.id}
                      className="bg-gray-100 text-gray-800 px-3 py-1 rounded-full text-sm"
                    >
                      {category.name}
                    </span>
                  ))}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  } catch (error) {
    // Handle specific error types
    if (error instanceof Error && error.message.includes('404')) {
      notFound();
    }
    
    // Log error for monitoring
    console.error('Product page error:', error);
    
    // Re-throw to trigger error boundary
    throw new Error(`Failed to load product: ${
      error instanceof Error ? error.message : 'Unknown error'
    }`);
  }
};

export default ProductPage;
```

---

## Caching and Revalidation {#caching-revalidation}

### Built-in Fetch Caching

```tsx
// app/posts/page.tsx
// Demonstrating different caching strategies

interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
  publishedAt: string;
  tags: string[];
}

const PostsPage = async () => {
  // Static data that rarely changes - cache indefinitely
  const staticPosts = await fetch('https://api.example.com/posts/featured', {
    cache: 'force-cache' // Default behavior, cache indefinitely
  });

  // Dynamic data that changes frequently - no cache
  const livePosts = await fetch('https://api.example.com/posts/live', {
    cache: 'no-store' // Never cache, always fetch fresh
  });

  // Data that changes periodically - revalidate every hour
  const regularPosts = await fetch('https://api.example.com/posts', {
    next: { revalidate: 3600 } // Revalidate every 3600 seconds (1 hour)
  });

  // Data with tags for on-demand revalidation
  const trendingPosts = await fetch('https://api.example.com/posts/trending', {
    next: { 
      revalidate: 1800, // 30 minutes
      tags: ['trending-posts'] // Can be revalidated on-demand
    }
  });

  const [staticData, liveData, regularData, trendingData] = await Promise.all([
    staticPosts.json(),
    livePosts.json(),
    regularPosts.json(),
    trendingPosts.json()
  ]);

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Posts</h1>
      
      {/* Featured Posts (Static) */}
      <section className="mb-12">
        <h2 className="text-2xl font-semibold mb-4">Featured Posts</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {staticData.map((post: Post) => (
            <PostCard key={post.id} post={post} />
          ))}
        </div>
      </section>

      {/* Trending Posts (Periodic Revalidation) */}
      <section className="mb-12">
        <h2 className="text-2xl font-semibold mb-4">Trending Now</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {trendingData.map((post: Post) => (
            <PostCard key={post.id} post={post} variant="trending" />
          ))}
        </div>
      </section>

      {/* Regular Posts (Hourly Revalidation) */}
      <section className="mb-12">
        <h2 className="text-2xl font-semibold mb-4">Latest Posts</h2>
        <div className="space-y-4">
          {regularData.map((post: Post) => (
            <PostCard key={post.id} post={post} variant="list" />
          ))}
        </div>
      </section>

      {/* Live Posts (No Cache) */}
      <section>
        <h2 className="text-2xl font-semibold mb-4">Live Updates</h2>
        <div className="space-y-2">
          {liveData.map((post: Post) => (
            <PostCard key={post.id} post={post} variant="compact" />
          ))}
        </div>
      </section>
    </div>
  );
};

const PostCard: React.FC<{
  post: Post;
  variant?: 'default' | 'trending' | 'list' | 'compact';
}> = ({ post, variant = 'default' }) => {
  const baseClasses = "bg-white rounded-lg shadow border";
  
  const variantClasses = {
    default: "p-6",
    trending: "p-6 border-l-4 border-orange-400",
    list: "p-4 flex items-center space-x-4",
    compact: "p-3 text-sm"
  };

  return (
    <div className={`${baseClasses} ${variantClasses[variant]}`}>
      {variant === 'list' ? (
        <>
          <div className="flex-1">
            <h3 className="font-semibold">{post.title}</h3>
            <p className="text-gray-600 text-sm mt-1 line-clamp-2">{post.body}</p>
          </div>
          <div className="text-xs text-gray-500">
            {new Date(post.publishedAt).toLocaleDateString()}
          </div>
        </>
      ) : (
        <>
          <h3 className={`font-semibold mb-2 ${
            variant === 'compact' ? 'text-sm' : 'text-lg'
          }`}>
            {post.title}
          </h3>
          <p className={`text-gray-600 mb-3 ${
            variant === 'compact' ? 'text-xs line-clamp-1' : 'line-clamp-3'
          }`}>
            {post.body}
          </p>
          <div className="flex justify-between items-center text-xs text-gray-500">
            <span>{new Date(post.publishedAt).toLocaleDateString()}</span>
            <div className="flex space-x-1">
              {post.tags.slice(0, 2).map(tag => (
                <span key={tag} className="bg-gray-100 px-2 py-1 rounded">
                  {tag}
                </span>
              ))}
            </div>
          </div>
        </>
      )}
    </div>
  );
};

export default PostsPage;
```

### On-Demand Revalidation

```tsx
// app/api/revalidate/route.ts
// API route for on-demand revalidation

import { revalidateTag, revalidatePath } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { type, target, secret } = body;

    // Verify secret to prevent unauthorized revalidation
    if (secret !== process.env.REVALIDATION_SECRET) {
      return NextResponse.json(
        { message: 'Unauthorized' },
        { status: 401 }
      );
    }

    switch (type) {
      case 'tag':
        // Revalidate all cached data with specific tag
        revalidateTag(target);
        return NextResponse.json({
          message: `Tag ${target} revalidated successfully`,
          timestamp: new Date().toISOString()
        });

      case 'path':
        // Revalidate specific page
        revalidatePath(target);
        return NextResponse.json({
          message: `Path ${target} revalidated successfully`,
          timestamp: new Date().toISOString()
        });

      default:
        return NextResponse.json(
          { message: 'Invalid revalidation type' },
          { status: 400 }
        );
    }
  } catch (error) {
    console.error('Revalidation error:', error);
    return NextResponse.json(
      { message: 'Revalidation failed' },
      { status: 500 }
    );
  }
}

// Usage examples:
// 
// Revalidate by tag:
// POST /api/revalidate
// {
//   "type": "tag",
//   "target": "trending-posts",
//   "secret": "your-secret"
// }
//
// Revalidate by path:
// POST /api/revalidate
// {
//   "type": "path", 
//   "target": "/posts",
//   "secret": "your-secret"
// }
```

---

## Real-World Examples {#real-world-examples}

### E-commerce Dashboard with Multiple Data Sources

```tsx
// app/admin/dashboard/page.tsx
// Complex dashboard with multiple API calls and error handling

import { Suspense } from 'react';
import { userApi, productApi, orderApi, analyticsApi } from '@/lib/api';
import DashboardStats from '@/components/DashboardStats';
import RecentOrders from '@/components/RecentOrders';
import TopProducts from '@/components/TopProducts';
import UserGrowthChart from '@/components/UserGrowthChart';

const AdminDashboard = async () => {
  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold text-gray-900 mb-8">
          Admin Dashboard
        </h1>

        {/* Stats Overview */}
        <Suspense fallback={<StatsSkeletonLoader />}>
          <DashboardStatsWrapper />
        </Suspense>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mt-8">
          {/* Recent Orders */}
          <Suspense fallback={<TableSkeletonLoader />}>
            <RecentOrdersWrapper />
          </Suspense>

          {/* Top Products */}
          <Suspense fallback={<TableSkeletonLoader />}>
            <TopProductsWrapper />
          </Suspense>
        </div>

        {/* User Growth Chart */}
        <div className="mt-8">
          <Suspense fallback={<ChartSkeletonLoader />}>
            <UserGrowthChartWrapper />
          </Suspense>
        </div>
      </div>
    </div>
  );
};

// Separate components for different data sources
const DashboardStatsWrapper = async () => {
  try {
    const stats = await analyticsApi.getDashboardStats();
    
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <StatCard
          title="Total Users"
          value={stats.totalUsers.toLocaleString()}
          icon="üë•"
          trend={{ value: 12, isPositive: true }}
        />
        <StatCard
          title="Total Products"
          value={stats.totalProducts.toLocaleString()}
          icon="üì¶"
          trend={{ value: 5, isPositive: true }}
        />
        <StatCard
          title="Total Orders"
          value={stats.totalOrders.toLocaleString()}
          icon="üõí"
          trend={{ value: 8, isPositive: true }}
        />
        <StatCard
          title="Revenue"
          value={`$${stats.revenue.toLocaleString()}`}
          icon="üí∞"
          trend={{ value: 15, isPositive: true }}
        />
      </div>
    );
  } catch (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <p className="text-red-600">Failed to load dashboard statistics</p>
      </div>
    );
  }
};

const RecentOrdersWrapper = async () => {
  try {
    const ordersResponse = await orderApi.getOrders(undefined, { 
      limit: 10,
      page: 1 
    });
    
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">Recent Orders</h2>
        <div className="space-y-4">
          {ordersResponse.data.map(order => (
            <div key={order.id} className="flex justify-between items-center py-2 border-b last:border-b-0">
              <div>
                <p className="font-medium">Order #{order.id.slice(-8)}</p>
                <p className="text-sm text-gray-600">
                  {order.items.length} items ‚Ä¢ {order.status}
                </p>
              </div>
              <div className="text-right">
                <p className="font-medium">${order.totals.total}</p>
                <p className="text-sm text-gray-600">
                  {new Date(order.createdAt).toLocaleDateString()}
                </p>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  } catch (error) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">Recent Orders</h2>
        <div className="bg-red-50 border border-red-200 rounded p-4">
          <p className="text-red-600">Failed to load recent orders</p>
        </div>
      </div>
    );
  }
};

const TopProductsWrapper = async () => {
  try {
    const productsResponse = await productApi.getProducts({
      limit: 5,
      sortBy: 'createdAt',
      sortOrder: 'desc'
    });
    
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">Top Products</h2>
        <div className="space-y-4">
          {productsResponse.data.map(product => (
            <div key={product.id} className="flex items-center space-x-4">
              <img
                src={product.images[0]?.url}
                alt={product.name}
                className="w-12 h-12 object-cover rounded"
              />
              <div className="flex-1">
                <p className="font-medium">{product.name}</p>
                <p className="text-sm text-gray-600">
                  ${product.price} ‚Ä¢ Stock: {product.inventory.quantity}
                </p>
              </div>
              <div className={`px-2 py-1 rounded text-xs ${
                product.inventory.inStock
                  ? 'bg-green-100 text-green-800'
                  : 'bg-red-100 text-red-800'
              }`}>
                {product.inventory.inStock ? 'In Stock' : 'Out of Stock'}
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  } catch (error) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">Top Products</h2>
        <div className="bg-red-50 border border-red-200 rounded p-4">
          <p className="text-red-600">Failed to load top products</p>
        </div>
      </div>
    );
  }
};

const UserGrowthChartWrapper = async () => {
  try {
    const growthData = await analyticsApi.getUserGrowth('30d');
    
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">User Growth (30 Days)</h2>
        <div className="h-64 flex items-end space-x-2">
          {growthData.map((point, index) => (
            <div
              key={point.date}
              className="bg-blue-500 flex-1 rounded-t"
              style={{
                height: `${(point.count / Math.max(...growthData.map(p => p.count))) * 100}%`
              }}
              title={`${point.date}: ${point.count} users`}
            />
          ))}
        </div>
      </div>
    );
  } catch (error) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">User Growth</h2>
        <div className="bg-red-50 border border-red-200 rounded p-4">
          <p className="text-red-600">Failed to load user growth data</p>
        </div>
      </div>
    );
  }
};

// Utility components
const StatCard: React.FC<{
  title: string;
  value: string;
  icon: string;
  trend?: { value: number; isPositive: boolean };
}> = ({ title, value, icon, trend }) => (
  <div className="bg-white rounded-lg shadow p-6">
    <div className="flex items-center justify-between">
      <div>
        <p className="text-sm text-gray-600">{title}</p>
        <p className="text-2xl font-bold">{value}</p>
        {trend && (
          <p className={`text-sm ${trend.isPositive ? 'text-green-600' : 'text-red-600'}`}>
            {trend.isPositive ? '‚Üó' : '‚Üò'} {trend.value}%
          </p>
        )}
      </div>
      <span className="text-2xl">{icon}</span>
    </div>
  </div>
);

// Skeleton loaders
const StatsSkeletonLoader = () => (
  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
    {[...Array(4)].map((_, i) => (
      <div key={i} className="bg-white rounded-lg shadow p-6 animate-pulse">
        <div className="h-4 bg-gray-200 rounded mb-2"></div>
        <div className="h-8 bg-gray-200 rounded mb-2"></div>
        <div className="h-3 bg-gray-200 rounded w-16"></div>
      </div>
    ))}
  </div>
);

const TableSkeletonLoader = () => (
  <div className="bg-white rounded-lg shadow p-6">
    <div className="h-6 bg-gray-200 rounded mb-4"></div>
    {[...Array(5)].map((_, i) => (
      <div key={i} className="flex justify-between items-center py-2">
        <div className="space-y-2">
          <div className="h-4 bg-gray-200 rounded w-24"></div>
          <div className="h-3 bg-gray-200 rounded w-32"></div>
        </div>
        <div className="space-y-2 text-right">
          <div className="h-4 bg-gray-200 rounded w-16"></div>
          <div className="h-3 bg-gray-200 rounded w-20"></div>
        </div>
      </div>
    ))}
  </div>
);

const ChartSkeletonLoader = () => (
  <div className="bg-white rounded-lg shadow p-6">
    <div className="h-6 bg-gray-200 rounded mb-4"></div>
    <div className="h-64 bg-gray-200 rounded"></div>
  </div>
);

export default AdminDashboard;
```

This comprehensive guide covers all aspects of data fetching in Next.js with TypeScript, from basic concepts to advanced real-world implementations. The examples demonstrate proper error handling, type safety, caching strategies, and performance optimization techniques that are essential for production applications.