# Advanced Type-Safe Routing in Next.js - Complete Guide

## Table of Contents
1. [Routing Fundamentals](#routing-fundamentals)
2. [Dynamic Routes and Parameters](#dynamic-routes)
3. [TypeScript Route Parameter Typing](#typescript-routing)
4. [Search Parameters and Query Strings](#search-parameters)
5. [Nested Dynamic Routes](#nested-routes)
6. [Route Groups and Layout Routes](#route-groups)
7. [Navigation and Link Components](#navigation)
8. [Route Validation and Error Handling](#route-validation)
9. [Advanced Routing Patterns](#advanced-patterns)
10. [Real-World Examples](#real-world-examples)

---

## Routing Fundamentals {#routing-fundamentals}

### How Next.js App Router Works

Next.js 13+ App Router uses a **file-system based routing** where the folder structure inside the `app` directory defines your routes. Each folder represents a route segment that maps to a URL segment.

### First Principles of File-System Routing

```
app/
├── page.tsx                    # / (root)
├── about/
│   └── page.tsx               # /about
├── blog/
│   ├── page.tsx               # /blog
│   └── [slug]/
│       └── page.tsx           # /blog/[slug] (dynamic)
├── products/
│   ├── page.tsx               # /products
│   ├── [id]/
│   │   ├── page.tsx           # /products/[id]
│   │   └── reviews/
│   │       └── page.tsx       # /products/[id]/reviews
│   └── categories/
│       └── [category]/
│           └── page.tsx       # /products/categories/[category]
└── admin/
    ├── layout.tsx             # Layout for /admin routes
    ├── page.tsx               # /admin
    └── users/
        ├── page.tsx           # /admin/users
        └── [id]/
            ├── page.tsx       # /admin/users/[id]
            └── edit/
                └── page.tsx   # /admin/users/[id]/edit
```

### Route Segment Types

```tsx
// Static Routes
app/about/page.tsx              // matches /about

// Dynamic Routes
app/blog/[slug]/page.tsx        // matches /blog/hello-world
app/products/[id]/page.tsx      // matches /products/123

// Catch-all Routes
app/docs/[...slug]/page.tsx     // matches /docs/a, /docs/a/b, /docs/a/b/c

// Optional Catch-all Routes
app/shop/[[...slug]]/page.tsx   // matches /shop, /shop/a, /shop/a/b
```

---

## Dynamic Routes and Parameters {#dynamic-routes}

### Basic Dynamic Routes

```tsx
// app/blog/[slug]/page.tsx
// This file handles routes like /blog/my-first-post, /blog/react-tutorial, etc.

interface BlogPostPageProps {
  params: {
    slug: string; // The dynamic segment from the URL
  };
  searchParams: {
    [key: string]: string | string[] | undefined;
  };
}

const BlogPostPage = async ({ params, searchParams }: BlogPostPageProps) => {
  // params.slug contains the dynamic part of the URL
  const { slug } = params;
  
  // Validate the slug
  if (!slug || typeof slug !== 'string') {
    throw new Error('Invalid blog post slug');
  }

  // Fetch blog post data using the slug
  const post = await getBlogPost(slug);
  
  if (!post) {
    notFound(); // This will render app/not-found.tsx
  }

  return (
    <article className="max-w-4xl mx-auto px-4 py-8">
      <header className="mb-8">
        <h1 className="text-4xl font-bold text-gray-900 mb-4">
          {post.title}
        </h1>
        <div className="flex items-center text-gray-600 text-sm">
          <time dateTime={post.publishedAt}>
            {new Date(post.publishedAt).toLocaleDateString()}
          </time>
          <span className="mx-2">•</span>
          <span>{post.readTime} min read</span>
          <span className="mx-2">•</span>
          <span>By {post.author.name}</span>
        </div>
      </header>
      
      <div className="prose max-w-none">
        {/* Render markdown or rich text content */}
        <div dangerouslySetInnerHTML={{ __html: post.content }} />
      </div>
      
      <footer className="mt-12 pt-8 border-t">
        <div className="flex flex-wrap gap-2">
          {post.tags.map(tag => (
            <span
              key={tag}
              className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm"
            >
              {tag}
            </span>
          ))}
        </div>
      </footer>
    </article>
  );
};

// Type definitions for blog post
interface BlogPost {
  id: string;
  slug: string;
  title: string;
  content: string;
  excerpt: string;
  publishedAt: string;
  updatedAt: string;
  readTime: number;
  tags: string[];
  author: {
    id: string;
    name: string;
    avatar: string;
  };
  seo: {
    metaTitle: string;
    metaDescription: string;
    ogImage?: string;
  };
}

// API function to fetch blog post
async function getBlogPost(slug: string): Promise<BlogPost | null> {
  try {
    const response = await fetch(`${process.env.API_BASE_URL}/blog/posts/${slug}`, {
      next: { revalidate: 3600 } // Cache for 1 hour
    });
    
    if (response.status === 404) {
      return null;
    }
    
    if (!response.ok) {
      throw new Error('Failed to fetch blog post');
    }
    
    return response.json();
  } catch (error) {
    console.error('Error fetching blog post:', error);
    return null;
  }
}

export default BlogPostPage;
```

### Multiple Dynamic Segments

```tsx
// app/products/[category]/[id]/page.tsx
// Handles routes like /products/electronics/laptop-123

interface ProductPageProps {
  params: {
    category: string;
    id: string;
  };
  searchParams: {
    variant?: string;
    color?: string;
    size?: string;
  };
}

const ProductPage = async ({ params, searchParams }: ProductPageProps) => {
  const { category, id } = params;
  const { variant, color, size } = searchParams;

  // Validate parameters
  if (!category || !id) {
    throw new Error('Missing required parameters');
  }

  // Fetch product data
  const [product, categoryInfo] = await Promise.all([
    getProduct(id),
    getCategory(category)
  ]);

  if (!product || !categoryInfo) {
    notFound();
  }

  // Ensure product belongs to the category
  if (!product.categories.some(cat => cat.slug === category)) {
    notFound();
  }

  // Find selected variant
  const selectedVariant = variant 
    ? product.variants.find(v => v.id === variant)
    : product.variants[0];

  return (
    <div className="max-w-7xl mx-auto px-4 py-8">
      {/* Breadcrumb Navigation */}
      <nav className="mb-8">
        <ol className="flex items-center space-x-2 text-sm">
          <li><Link href="/" className="text-blue-600 hover:underline">Home</Link></li>
          <li><span className="text-gray-500">/</span></li>
          <li><Link href="/products" className="text-blue-600 hover:underline">Products</Link></li>
          <li><span className="text-gray-500">/</span></li>
          <li><Link href={`/products/${category}`} className="text-blue-600 hover:underline">{categoryInfo.name}</Link></li>
          <li><span className="text-gray-500">/</span></li>
          <li><span className="text-gray-900">{product.name}</span></li>
        </ol>
      </nav>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-12">
        {/* Product Images */}
        <div className="space-y-4">
          <ProductImageGallery 
            images={selectedVariant?.images || product.images}
            productName={product.name}
          />
        </div>

        {/* Product Details */}
        <div className="space-y-6">
          <div>
            <h1 className="text-3xl font-bold text-gray-900 mb-2">
              {product.name}
            </h1>
            <p className="text-2xl font-semibold text-blue-600">
              ${selectedVariant?.price || product.basePrice}
            </p>
          </div>

          {/* Variant Selection */}
          <ProductVariantSelector
            product={product}
            selectedVariant={selectedVariant}
            searchParams={searchParams}
          />

          {/* Add to Cart */}
          <AddToCartButton
            product={product}
            variant={selectedVariant}
            className="w-full"
          />

          {/* Product Description */}
          <div>
            <h3 className="text-lg font-semibold mb-2">Description</h3>
            <p className="text-gray-600 leading-relaxed">
              {product.description}
            </p>
          </div>

          {/* Product Specifications */}
          <div>
            <h3 className="text-lg font-semibold mb-2">Specifications</h3>
            <dl className="space-y-1">
              {Object.entries(product.specifications).map(([key, value]) => (
                <div key={key} className="flex justify-between py-1 border-b border-gray-100">
                  <dt className="text-gray-600">{key}</dt>
                  <dd className="font-medium">{value}</dd>
                </div>
              ))}
            </dl>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ProductPage;
```

### Catch-All Routes

```tsx
// app/docs/[...slug]/page.tsx
// Handles routes like /docs/getting-started, /docs/api/users, /docs/guides/deployment/vercel

interface DocsPageProps {
  params: {
    slug: string[]; // Array of path segments
  };
}

const DocsPage = async ({ params }: DocsPageProps) => {
  const { slug } = params;
  
  // slug is an array: ['getting-started'] or ['api', 'users'] or ['guides', 'deployment', 'vercel']
  const docPath = slug.join('/');
  
  // Validate the path
  if (!slug || slug.length === 0) {
    throw new Error('Invalid documentation path');
  }

  try {
    // Fetch documentation content
    const doc = await getDocumentation(docPath);
    
    if (!doc) {
      notFound();
    }

    // Generate navigation structure
    const navigation = await getDocsNavigation();
    const breadcrumbs = generateBreadcrumbs(slug);

    return (
      <div className="max-w-7xl mx-auto px-4 py-8">
        <div className="flex gap-8">
          {/* Sidebar Navigation */}
          <aside className="w-64 flex-shrink-0">
            <DocsNavigation navigation={navigation} currentPath={docPath} />
          </aside>

          {/* Main Content */}
          <main className="flex-1 min-w-0">
            {/* Breadcrumbs */}
            <nav className="mb-6">
              <ol className="flex items-center space-x-2 text-sm">
                <li><Link href="/docs" className="text-blue-600 hover:underline">Docs</Link></li>
                {breadcrumbs.map((crumb, index) => (
                  <React.Fragment key={crumb.path}>
                    <li><span className="text-gray-500">/</span></li>
                    <li>
                      {index === breadcrumbs.length - 1 ? (
                        <span className="text-gray-900">{crumb.title}</span>
                      ) : (
                        <Link href={crumb.path} className="text-blue-600 hover:underline">
                          {crumb.title}
                        </Link>
                      )}
                    </li>
                  </React.Fragment>
                ))}
              </ol>
            </nav>

            {/* Document Content */}
            <article className="prose max-w-none">
              <h1>{doc.title}</h1>
              <div dangerouslySetInnerHTML={{ __html: doc.content }} />
            </article>

            {/* Navigation Footer */}
            <footer className="mt-12 pt-8 border-t">
              <div className="flex justify-between">
                {doc.previousDoc && (
                  <Link
                    href={`/docs/${doc.previousDoc.path}`}
                    className="flex items-center text-blue-600 hover:underline"
                  >
                    ← {doc.previousDoc.title}
                  </Link>
                )}
                {doc.nextDoc && (
                  <Link
                    href={`/docs/${doc.nextDoc.path}`}
                    className="flex items-center text-blue-600 hover:underline ml-auto"
                  >
                    {doc.nextDoc.title} →
                  </Link>
                )}
              </div>
            </footer>
          </main>
        </div>
      </div>
    );
  } catch (error) {
    throw new Error(`Failed to load documentation: ${error}`);
  }
};

// Helper function to generate breadcrumbs
function generateBreadcrumbs(slug: string[]): { title: string; path: string }[] {
  const breadcrumbs: { title: string; path: string }[] = [];
  let currentPath = '/docs';

  slug.forEach((segment, index) => {
    currentPath += `/${segment}`;
    breadcrumbs.push({
      title: segment.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
      path: currentPath
    });
  });

  return breadcrumbs;
}

export default DocsPage;
```

---

## TypeScript Route Parameter Typing {#typescript-routing}

### Strongly Typed Route Parameters

```tsx
// types/routes.ts
// Define route parameter types for better type safety

// Basic route parameter types
export interface BlogPostParams {
  slug: string;
}

export interface ProductParams {
  category: string;
  id: string;
}

export interface UserParams {
  id: string;
}

export interface DocsParams {
  slug: string[];
}

// Search parameter types
export interface ProductSearchParams {
  variant?: string;
  color?: string;
  size?: string;
  sort?: 'price' | 'name' | 'rating';
  order?: 'asc' | 'desc';
}

export interface BlogSearchParams {
  tag?: string | string[];
  author?: string;
  search?: string;
  page?: string;
}

export interface UserSearchParams {
  role?: string;
  status?: 'active' | 'inactive';
  search?: string;
  page?: string;
  limit?: string;
}

// Combined page props types
export interface BlogPostPageProps {
  params: BlogPostParams;
  searchParams: BlogSearchParams;
}

export interface ProductPageProps {
  params: ProductParams;
  searchParams: ProductSearchParams;
}

export interface UserPageProps {
  params: UserParams;
  searchParams: UserSearchParams;
}

export interface DocsPageProps {
  params: DocsParams;
  searchParams: Record<string, never>; // Docs don't use search params
}
```

### Parameter Validation and Parsing

```tsx
// utils/route-validation.ts
// Utilities for validating and parsing route parameters

import { z } from 'zod';

// Validation schemas
export const BlogParamsSchema = z.object({
  slug: z.string().min(1).regex(/^[a-z0-9-]+$/, 'Invalid slug format')
});

export const ProductParamsSchema = z.object({
  category: z.string().min(1).regex(/^[a-z0-9-]+$/, 'Invalid category format'),
  id: z.string().min(1)
});

export const UserParamsSchema = z.object({
  id: z.string().uuid('Invalid user ID format')
});

export const DocsParamsSchema = z.object({
  slug: z.array(z.string().min(1)).min(1, 'Documentation path cannot be empty')
});

// Search parameter schemas
export const ProductSearchParamsSchema = z.object({
  variant: z.string().optional(),
  color: z.string().optional(),
  size: z.string().optional(),
  sort: z.enum(['price', 'name', 'rating']).optional(),
  order: z.enum(['asc', 'desc']).optional()
});

export const BlogSearchParamsSchema = z.object({
  tag: z.union([z.string(), z.array(z.string())]).optional(),
  author: z.string().optional(),
  search: z.string().optional(),
  page: z.string().regex(/^\d+$/, 'Page must be a number').optional()
});

// Validation helper functions
export function validateRouteParams<T>(
  params: unknown,
  schema: z.ZodSchema<T>
): T {
  try {
    return schema.parse(params);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`Invalid route parameters: ${error.errors.map(e => e.message).join(', ')}`);
    }
    throw error;
  }
}

export function validateSearchParams<T>(
  searchParams: unknown,
  schema: z.ZodSchema<T>
): T {
  try {
    return schema.parse(searchParams);
  } catch (error) {
    // For search params, we often want to return defaults instead of throwing
    console.warn('Invalid search parameters:', error);
    return {} as T;
  }
}

// Type-safe parameter parsing
export function parseNumericParam(param: string | undefined, defaultValue: number = 1): number {
  if (!param) return defaultValue;
  const parsed = parseInt(param, 10);
  return isNaN(parsed) ? defaultValue : parsed;
}

export function parseArrayParam(param: string | string[] | undefined): string[] {
  if (!param) return [];
  return Array.isArray(param) ? param : [param];
}

export function parseBooleanParam(param: string | undefined, defaultValue: boolean = false): boolean {
  if (!param) return defaultValue;
  return param.toLowerCase() === 'true';
}
```

### Type-Safe Page Components

```tsx
// app/products/[category]/[id]/page.tsx
// Example of a fully type-safe page component

import { validateRouteParams, validateSearchParams } from '@/utils/route-validation';
import { 
  ProductParams, 
  ProductSearchParams,
  ProductParamsSchema,
  ProductSearchParamsSchema 
} from '@/types/routes';

interface TypeSafeProductPageProps {
  params: ProductParams;
  searchParams: ProductSearchParams;
}

const TypeSafeProductPage = async ({ params, searchParams }: TypeSafeProductPageProps) => {
  // Validate and parse parameters with type safety
  const validatedParams = validateRouteParams(params, ProductParamsSchema);
  const validatedSearchParams = validateSearchParams(searchParams, ProductSearchParamsSchema);

  const { category, id } = validatedParams;
  const { variant, color, size, sort = 'name', order = 'asc' } = validatedSearchParams;

  try {
    // Fetch data with validated parameters
    const [product, categoryInfo, relatedProducts] = await Promise.all([
      getProduct(id),
      getCategory(category),
      getRelatedProducts(category, { sort, order })
    ]);

    if (!product || !categoryInfo) {
      notFound();
    }

    // Type-safe component rendering
    return (
      <ProductPageLayout
        product={product}
        category={categoryInfo}
        selectedVariant={variant}
        selectedColor={color}
        selectedSize={size}
        relatedProducts={relatedProducts}
      />
    );
  } catch (error) {
    console.error('Product page error:', error);
    throw new Error('Failed to load product page');
  }
};

// Separate layout component for better organization
interface ProductPageLayoutProps {
  product: Product;
  category: Category;
  selectedVariant?: string;
  selectedColor?: string;
  selectedSize?: string;
  relatedProducts: Product[];
}

const ProductPageLayout: React.FC<ProductPageLayoutProps> = ({
  product,
  category,
  selectedVariant,
  selectedColor,
  selectedSize,
  relatedProducts
}) => {
  // Find the selected variant
  const variant = selectedVariant 
    ? product.variants.find(v => v.id === selectedVariant)
    : product.variants[0];

  return (
    <div className="max-w-7xl mx-auto px-4 py-8">
      {/* Structured product page content */}
      <ProductBreadcrumbs category={category} product={product} />
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-12">
        <ProductImages 
          product={product} 
          variant={variant}
          selectedColor={selectedColor}
        />
        
        <ProductDetails 
          product={product}
          variant={variant}
          selectedColor={selectedColor}
          selectedSize={selectedSize}
        />
      </div>
      
      <RelatedProducts products={relatedProducts} category={category} />
    </div>
  );
};

export default TypeSafeProductPage;
```

---

## Search Parameters and Query Strings {#search-parameters}

### Handling Search Parameters

```tsx
// app/blog/page.tsx
// Blog listing page with search, filtering, and pagination

import { validateSearchParams, parseNumericParam, parseArrayParam } from '@/utils/route-validation';
import { BlogSearchParams, BlogSearchParamsSchema } from '@/types/routes';

interface BlogPageProps {
  searchParams: BlogSearchParams;
}

const BlogPage = async ({ searchParams }: BlogPageProps) => {
  // Validate and parse search parameters
  const validatedParams = validateSearchParams(searchParams, BlogSearchParamsSchema);
  
  const {
    tag,
    author,
    search,
    page: pageParam
  } = validatedParams;

  // Parse parameters with defaults
  const currentPage = parseNumericParam(pageParam, 1);
  const tags = parseArrayParam(tag);
  const itemsPerPage = 12;

  try {
    // Fetch blog posts with filters
    const { posts, totalCount, totalPages } = await getBlogPosts({
      page: currentPage,
      limit: itemsPerPage,
      tags: tags.length > 0 ? tags : undefined,
      author,
      search
    });

    // Fetch additional data
    const [categories, authors, popularTags] = await Promise.all([
      getBlogCategories(),
      getBlogAuthors(),
      getPopularTags()
    ]);

    return (
      <div className="max-w-7xl mx-auto px-4 py-8">
        <div className="flex gap-8">
          {/* Sidebar Filters */}
          <aside className="w-64 flex-shrink-0">
            <BlogFilters
              categories={categories}
              authors={authors}
              popularTags={popularTags}
              currentFilters={{ tags, author, search }}
            />
          </aside>

          {/* Main Content */}
          <main className="flex-1">
            <BlogHeader 
              totalCount={totalCount}
              currentFilters={{ tags, author, search }}
            />
            
            <BlogPostGrid posts={posts} />
            
            <BlogPagination
              currentPage={currentPage}
              totalPages={totalPages}
              searchParams={validatedParams}
            />
          </main>
        </div>
      </div>
    );
  } catch (error) {
    throw new Error(`Failed to load blog posts: ${error}`);
  }
};

// Blog filters component with type-safe URL updates
interface BlogFiltersProps {
  categories: Category[];
  authors: Author[];
  popularTags: Tag[];
  currentFilters: {
    tags: string[];
    author?: string;
    search?: string;
  };
}

const BlogFilters: React.FC<BlogFiltersProps> = ({
  categories,
  authors,
  popularTags,
  currentFilters
}) => {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const updateFilter = useCallback((key: string, value: string | string[] | null) => {
    const params = new URLSearchParams(searchParams.toString());
    
    if (value === null || (Array.isArray(value) && value.length === 0)) {
      params.delete(key);
    } else if (Array.isArray(value)) {
      params.delete(key);
      value.forEach(v => params.append(key, v));
    } else {
      params.set(key, value);
    }
    
    // Reset to first page when filters change
    params.delete('page');
    
    router.push(`${pathname}?${params.toString()}`);
  }, [searchParams, pathname, router]);

  return (
    <div className="space-y-6">
      {/* Search */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Search
        </label>
        <SearchInput
          placeholder="Search posts..."
          defaultValue={currentFilters.search}
          onSearch={(value) => updateFilter('search', value || null)}
        />
      </div>

      {/* Tags */}
      <div>
        <h3 className="text-sm font-medium text-gray-700 mb-3">Tags</h3>
        <div className="space-y-2">
          {popularTags.map(tag => (
            <label key={tag.id} className="flex items-center">
              <input
                type="checkbox"
                checked={currentFilters.tags.includes(tag.slug)}
                onChange={(e) => {
                  const newTags = e.target.checked
                    ? [...currentFilters.tags, tag.slug]
                    : currentFilters.tags.filter(t => t !== tag.slug);
                  updateFilter('tag', newTags.length > 0 ? newTags : null);
                }}
                className="mr-2 rounded"
              />
              <span className="text-sm">{tag.name} ({tag.count})</span>
            </label>
          ))}
        </div>
      </div>

      {/* Authors */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Author
        </label>
        <select
          value={currentFilters.author || ''}
          onChange={(e) => updateFilter('author', e.target.value || null)}
          className="w-full p-2 border border-gray-300 rounded-md"
        >
          <option value="">All Authors</option>
          {authors.map(author => (
            <option key={author.id} value={author.slug}>
              {author.name}
            </option>
          ))}
        </select>
      </div>
    </div>
  );
};

export default BlogPage;
```

### Type-Safe URL Generation

```tsx
// utils/url-builder.ts
// Type-safe URL building utilities

import { BlogSearchParams, ProductSearchParams } from '@/types/routes';

// Generic URL builder
export class URLBuilder {
  private baseUrl: string;
  private params: URLSearchParams;

  constructor(baseUrl: string, initialParams: Record<string, any> = {}) {
    this.baseUrl = baseUrl;
    this.params = new URLSearchParams();
    
    Object.entries(initialParams).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        if (Array.isArray(value)) {
          value.forEach(v => this.params.append(key, String(v)));
        } else {
          this.params.set(key, String(value));
        }
      }
    });
  }

  setParam(key: string, value: string | number | boolean | null): this {
    if (value === null) {
      this.params.delete(key);
    } else {
      this.params.set(key, String(value));
    }
    return this;
  }

  appendParam(key: string, value: string | number | boolean): this {
    this.params.append(key, String(value));
    return this;
  }

  deleteParam(key: string): this {
    this.params.delete(key);
    return this;
  }

  build(): string {
    const paramString = this.params.toString();
    return paramString ? `${this.baseUrl}?${paramString}` : this.baseUrl;
  }
}

// Type-safe route builders
export function buildBlogUrl(params: Partial<BlogSearchParams> = {}): string {
  return new URLBuilder('/blog', params).build();
}

export function buildProductUrl(
  category: string,
  id: string,
  searchParams: Partial<ProductSearchParams> = {}
): string {
  return new URLBuilder(`/products/${category}/${id}`, searchParams).build();
}

export function buildUserUrl(id: string, tab?: string): string {
  const builder = new URLBuilder(`/users/${id}`);
  if (tab) {
    builder.setParam('tab', tab);
  }
  return builder.build();
}

// Usage examples:
// buildBlogUrl({ tag: ['react', 'nextjs'], author: 'john-doe', page: '2' })
// buildProductUrl('electronics', 'laptop-123', { variant: 'black', size: '15-inch' })
// buildUserUrl('user-123', 'profile')
```

---

## Nested Dynamic Routes {#nested-routes}

### Complex Nested Route Structures

```tsx
// app/admin/users/[userId]/orders/[orderId]/page.tsx
// Handles routes like /admin/users/123/orders/order-456

interface UserOrderPageProps {
  params: {
    userId: string;
    orderId: string;
  };
  searchParams: {
    tab?: 'details' | 'items' | 'history' | 'notes';
  };
}

const UserOrderPage = async ({ params, searchParams }: UserOrderPageProps) => {
  const { userId, orderId } = params;
  const { tab = 'details' } = searchParams;

  // Validate parameters
  if (!userId || !orderId) {
    throw new Error('Missing required parameters');
  }

  try {
    // Fetch user and order data in parallel
    const [user, order] = await Promise.all([
      getUser(userId),
      getOrder(orderId)
    ]);

    if (!user || !order) {
      notFound();
    }

    // Verify the order belongs to the user
    if (order.userId !== user.id) {
      throw new Error('Order does not belong to this user');
    }

    return (
      <div className="max-w-7xl mx-auto px-4 py-8">
        {/* Breadcrumb Navigation */}
        <Breadcrumbs>
          <BreadcrumbItem href="/admin">Admin</BreadcrumbItem>
          <BreadcrumbItem href="/admin/users">Users</BreadcrumbItem>
          <BreadcrumbItem href={`/admin/users/${userId}`}>
            {user.name}
          </BreadcrumbItem>
          <BreadcrumbItem href={`/admin/users/${userId}/orders`}>
            Orders
          </BreadcrumbItem>
          <BreadcrumbItem current>
            Order #{order.orderNumber}
          </BreadcrumbItem>
        </Breadcrumbs>

        {/* Page Header */}
        <div className="flex justify-between items-start mb-8">
          <div>
            <h1 className="text-3xl font-bold text-gray-900">
              Order #{order.orderNumber}
            </h1>
            <p className="text-gray-600 mt-1">
              Placed on {new Date(order.createdAt).toLocaleDateString()}
            </p>
          </div>
          
          <OrderStatusBadge status={order.status} />
        </div>

        {/* Tab Navigation */}
        <TabNavigation
          tabs={[
            { id: 'details', label: 'Order Details', href: `?tab=details` },
            { id: 'items', label: 'Items', href: `?tab=items` },
            { id: 'history', label: 'History', href: `?tab=history` },
            { id: 'notes', label: 'Notes', href: `?tab=notes` }
          ]}
          activeTab={tab}
        />

        {/* Tab Content */}
        <div className="mt-6">
          {tab === 'details' && <OrderDetailsTab order={order} user={user} />}
          {tab === 'items' && <OrderItemsTab order={order} />}
          {tab === 'history' && <OrderHistoryTab orderId={order.id} />}
          {tab === 'notes' && <OrderNotesTab orderId={order.id} />}
        </div>
      </div>
    );
  } catch (error) {
    throw new Error(`Failed to load order: ${error}`);
  }
};

// Order details tab component
const OrderDetailsTab: React.FC<{ order: Order; user: User }> = ({ order, user }) => {
  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
      {/* Customer Information */}
      <div className="bg-white rounded-lg shadow p-6">
        <h3 className="text-lg font-semibold mb-4">Customer Information</h3>
        <div className="space-y-3">
          <div className="flex items-center space-x-3">
            <img
              src={user.avatar}
              alt={user.name}
              className="w-10 h-10 rounded-full"
            />
            <div>
              <p className="font-medium">{user.name}</p>
              <p className="text-sm text-gray-600">{user.email}</p>
            </div>
          </div>
          <div className="pt-3 border-t">
            <p className="text-sm text-gray-600">Member since</p>
            <p className="font-medium">
              {new Date(user.createdAt).toLocaleDateString()}
            </p>
          </div>
        </div>
      </div>

      {/* Shipping Information */}
      <div className="bg-white rounded-lg shadow p-6">
        <h3 className="text-lg font-semibold mb-4">Shipping Address</h3>
        <address className="not-italic text-sm leading-relaxed">
          {order.shippingAddress.firstName} {order.shippingAddress.lastName}<br />
          {order.shippingAddress.streetAddress1}<br />
          {order.shippingAddress.streetAddress2 && (
            <>{order.shippingAddress.streetAddress2}<br /></>
          )}
          {order.shippingAddress.city}, {order.shippingAddress.state} {order.shippingAddress.postalCode}<br />
          {order.shippingAddress.country}
        </address>
      </div>

      {/* Order Summary */}
      <div className="bg-white rounded-lg shadow p-6">
        <h3 className="text-lg font-semibold mb-4">Order Summary</h3>
        <div className="space-y-2 text-sm">
          <div className="flex justify-between">
            <span>Subtotal</span>
            <span>${order.totals.subtotal.toFixed(2)}</span>
          </div>
          <div className="flex justify-between">
            <span>Shipping</span>
            <span>${order.totals.shipping.toFixed(2)}</span>
          </div>
          <div className="flex justify-between">
            <span>Tax</span>
            <span>${order.totals.tax.toFixed(2)}</span>
          </div>
          {order.totals.discount > 0 && (
            <div className="flex justify-between text-green-600">
              <span>Discount</span>
              <span>-${order.totals.discount.toFixed(2)}</span>
            </div>
          )}
          <div className="flex justify-between font-semibold text-lg border-t pt-2">
            <span>Total</span>
            <span>${order.totals.total.toFixed(2)}</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default UserOrderPage;
```

### Layout Components for Nested Routes

```tsx
// app/admin/users/[userId]/layout.tsx
// Shared layout for all user-specific admin pages

import { getUser } from '@/lib/api';
import { notFound } from 'next/navigation';

interface UserLayoutProps {
  children: React.ReactNode;
  params: {
    userId: string;
  };
}

const UserLayout = async ({ children, params }: UserLayoutProps) => {
  const { userId } = params;

  try {
    const user = await getUser(userId);
    
    if (!user) {
      notFound();
    }

    return (
      <div className="min-h-screen bg-gray-50">
        {/* User Header */}
        <div className="bg-white shadow">
          <div className="max-w-7xl mx-auto px-4 py-6">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-4">
                <img
                  src={user.avatar}
                  alt={user.name}
                  className="w-12 h-12 rounded-full"
                />
                <div>
                  <h1 className="text-2xl font-bold text-gray-900">
                    {user.name}
                  </h1>
                  <p className="text-gray-600">{user.email}</p>
                </div>
              </div>
              
              <UserStatusBadge 
                status={user.status}
                lastActive={user.lastActiveAt}
              />
            </div>

            {/* User Navigation */}
            <nav className="mt-6">
              <UserNavigation userId={userId} />
            </nav>
          </div>
        </div>

        {/* Page Content */}
        <main className="max-w-7xl mx-auto px-4 py-8">
          {children}
        </main>
      </div>
    );
  } catch (error) {
    throw new Error(`Failed to load user layout: ${error}`);
  }
};

// User navigation component
const UserNavigation: React.FC<{ userId: string }> = ({ userId }) => {
  const pathname = usePathname();
  
  const navigationItems = [
    { href: `/admin/users/${userId}`, label: 'Overview' },
    { href: `/admin/users/${userId}/profile`, label: 'Profile' },
    { href: `/admin/users/${userId}/orders`, label: 'Orders' },
    { href: `/admin/users/${userId}/activity`, label: 'Activity' },
    { href: `/admin/users/${userId}/settings`, label: 'Settings' }
  ];

  return (
    <div className="flex space-x-8">
      {navigationItems.map(item => {
        const isActive = pathname === item.href || pathname.startsWith(`${item.href}/`);
        
        return (
          <Link
            key={item.href}
            href={item.href}
            className={`pb-2 border-b-2 text-sm font-medium transition-colors ${
              isActive
                ? 'border-blue-500 text-blue-600'
                : 'border-transparent text-gray-500 hover:text-gray-700'
            }`}
          >
            {item.label}
          </Link>
        );
      })}
    </div>
  );
};

export default UserLayout;
```

---

## Route Groups and Layout Routes {#route-groups}

### Route Groups for Organization

```tsx
// Route groups allow you to organize routes without affecting the URL structure
// Folders wrapped in parentheses () are route groups

/*
app/
├── (marketing)/
│   ├── page.tsx                    # /
│   ├── about/
│   │   └── page.tsx               # /about
│   ├── contact/
│   │   └── page.tsx               # /contact
│   └── layout.tsx                 # Marketing layout
├── (shop)/
│   ├── products/
│   │   ├── page.tsx               # /products
│   │   └── [id]/
│   │       └── page.tsx           # /products/[id]
│   ├── cart/
│   │   └── page.tsx               # /cart
│   └── layout.tsx                 # Shop layout
└── (admin)/
    ├── dashboard/
    │   └── page.tsx               # /dashboard
    ├── users/
    │   └── page.tsx               # /users
    └── layout.tsx                 # Admin layout
*/

// app/(marketing)/layout.tsx
// Layout for marketing pages (home, about, contact)

const MarketingLayout = ({ children }: { children: React.ReactNode }) => {
  return (
    <div className="min-h-screen bg-white">
      <MarketingHeader />
      <main>{children}</main>
      <MarketingFooter />
    </div>
  );
};

// app/(shop)/layout.tsx
// Layout for shopping pages (products, cart, checkout)

const ShopLayout = ({ children }: { children: React.ReactNode }) => {
  return (
    <div className="min-h-screen bg-gray-50">
      <ShopHeader />
      <div className="flex">
        <ShopSidebar />
        <main className="flex-1">{children}</main>
      </div>
      <ShopFooter />
    </div>
  );
};

// app/(admin)/layout.tsx
// Layout for admin pages

const AdminLayout = async ({ children }: { children: React.ReactNode }) => {
  // Check authentication
  const user = await getCurrentUser();
  
  if (!user || !user.isAdmin) {
    redirect('/login');
  }

  return (
    <div className="min-h-screen bg-gray-100">
      <AdminHeader user={user} />
      <div className="flex">
        <AdminSidebar />
        <main className="flex-1 p-8">{children}</main>
      </div>
    </div>
  );
};
```

### Parallel Routes and Intercepting Routes

```tsx
// app/photos/[id]/page.tsx
// Main photo page

interface PhotoPageProps {
  params: { id: string };
}

const PhotoPage = async ({ params }: PhotoPageProps) => {
  const photo = await getPhoto(params.id);
  
  return (
    <div className="max-w-4xl mx-auto px-4 py-8">
      <img
        src={photo.url}
        alt={photo.title}
        className="w-full h-auto rounded-lg"
      />
      <div className="mt-6">
        <h1 className="text-2xl font-bold">{photo.title}</h1>
        <p className="text-gray-600 mt-2">{photo.description}</p>
      </div>
    </div>
  );
};

// app/@modal/(.)photos/[id]/page.tsx
// Intercepting route for modal display
// The (.) means intercept routes at the same level

const PhotoModal = async ({ params }: { params: { id: string } }) => {
  const photo = await getPhoto(params.id);
  
  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
      <div className="max-w-3xl max-h-3xl bg-white rounded-lg overflow-hidden">
        <img
          src={photo.url}
          alt={photo.title}
          className="w-full h-auto"
        />
        <div className="p-4">
          <h2 className="text-xl font-semibold">{photo.title}</h2>
          <p className="text-gray-600 mt-1">{photo.description}</p>
        </div>
      </div>
    </div>
  );
};

// app/layout.tsx
// Root layout that accepts the modal slot

interface RootLayoutProps {
  children: React.ReactNode;
  modal: React.ReactNode; // Parallel route slot
}

const RootLayout = ({ children, modal }: RootLayoutProps) => {
  return (
    <html lang="en">
      <body>
        {children}
        {modal}
      </body>
    </html>
  );
};
```

---

## Navigation and Link Components {#navigation}

### Type-Safe Navigation Components

```tsx
// components/Navigation/TypeSafeLink.tsx
// Link component with type-safe route generation

import Link from 'next/link';
import { usePathname } from 'next/navigation';

interface TypeSafeLinkProps {
  href: string;
  children: React.ReactNode;
  className?: string;
  activeClassName?: string;
  exact?: boolean;
}

export const TypeSafeLink: React.FC<TypeSafeLinkProps> = ({
  href,
  children,
  className = '',
  activeClassName = '',
  exact = false
}) => {
  const pathname = usePathname();
  
  const isActive = exact 
    ? pathname === href 
    : pathname.startsWith(href);

  const linkClassName = `${className} ${isActive ? activeClassName : ''}`.trim();

  return (
    <Link href={href} className={linkClassName}>
      {children}
    </Link>
  );
};

// Route helper functions
export const routes = {
  home: () => '/',
  about: () => '/about',
  contact: () => '/contact',
  
  blog: {
    index: () => '/blog',
    post: (slug: string) => `/blog/${slug}`,
    tag: (tag: string) => `/blog?tag=${encodeURIComponent(tag)}`,
    author: (author: string) => `/blog?author=${encodeURIComponent(author)}`
  },
  
  products: {
    index: () => '/products',
    category: (category: string) => `/products/categories/${category}`,
    detail: (category: string, id: string) => `/products/${category}/${id}`,
    compare: (ids: string[]) => `/products/compare?ids=${ids.join(',')}`
  },
  
  user: {
    profile: (id: string) => `/users/${id}`,
    settings: (id: string) => `/users/${id}/settings`,
    orders: (id: string) => `/users/${id}/orders`,
    order: (userId: string, orderId: string) => `/users/${userId}/orders/${orderId}`
  },
  
  admin: {
    dashboard: () => '/admin',
    users: () => '/admin/users',
    user: (id: string) => `/admin/users/${id}`,
    userOrders: (id: string) => `/admin/users/${id}/orders`,
    userOrder: (userId: string, orderId: string) => `/admin/users/${userId}/orders/${orderId}`
  }
} as const;

// Usage examples:
// <TypeSafeLink href={routes.blog.post('my-post-slug')}>Read Post</TypeSafeLink>
// <TypeSafeLink href={routes.products.detail('electronics', 'laptop-123')}>View Product</TypeSafeLink>
```

### Dynamic Navigation Components

```tsx
// components/Navigation/DynamicNavigation.tsx
// Navigation that adapts based on user role and current route

'use client';

import { useUser } from '@/hooks/useUser';
import { usePathname } from 'next/navigation';
import { TypeSafeLink, routes } from './TypeSafeLink';

interface NavigationItem {
  label: string;
  href: string;
  icon?: React.ComponentType<{ className?: string }>;
  roles?: string[];
  children?: NavigationItem[];
}

const navigationConfig: NavigationItem[] = [
  {
    label: 'Home',
    href: routes.home(),
    icon: HomeIcon
  },
  {
    label: 'Products',
    href: routes.products.index(),
    icon: ShoppingBagIcon,
    children: [
      { label: 'All Products', href: routes.products.index() },
      { label: 'Electronics', href: routes.products.category('electronics') },
      { label: 'Clothing', href: routes.products.category('clothing') },
      { label: 'Books', href: routes.products.category('books') }
    ]
  },
  {
    label: 'Blog',
    href: routes.blog.index(),
    icon: DocumentTextIcon
  },
  {
    label: 'Admin',
    href: routes.admin.dashboard(),
    icon: CogIcon,
    roles: ['admin', 'moderator'],
    children: [
      { label: 'Dashboard', href: routes.admin.dashboard(), roles: ['admin', 'moderator'] },
      { label: 'Users', href: routes.admin.users(), roles: ['admin'] },
      { label: 'Orders', href: '/admin/orders', roles: ['admin', 'moderator'] },
      { label: 'Analytics', href: '/admin/analytics', roles: ['admin'] }
    ]
  }
];

export const DynamicNavigation: React.FC = () => {
  const { user, isLoading } = useUser();
  const pathname = usePathname();

  if (isLoading) {
    return <NavigationSkeleton />;
  }

  const filterItemsByRole = (items: NavigationItem[]): NavigationItem[] => {
    return items.filter(item => {
      if (!item.roles) return true;
      if (!user) return false;
      return item.roles.some(role => user.roles.includes(role));
    }).map(item => ({
      ...item,
      children: item.children ? filterItemsByRole(item.children) : undefined
    }));
  };

  const visibleNavigation = filterItemsByRole(navigationConfig);

  return (
    <nav className="bg-white shadow-lg">
      <div className="max-w-7xl mx-auto px-4">
        <div className="flex justify-between h-16">
          {/* Logo */}
          <div className="flex items-center">
            <TypeSafeLink href={routes.home()} className="text-xl font-bold">
              MyApp
            </TypeSafeLink>
          </div>

          {/* Navigation Items */}
          <div className="hidden md:flex items-center space-x-8">
            {visibleNavigation.map(item => (
              <NavigationItem key={item.href} item={item} pathname={pathname} />
            ))}
          </div>

          {/* User Menu */}
          <div className="flex items-center">
            {user ? (
              <UserMenu user={user} />
            ) : (
              <div className="space-x-4">
                <TypeSafeLink 
                  href="/login"
                  className="text-gray-700 hover:text-gray-900"
                >
                  Sign In
                </TypeSafeLink>
                <TypeSafeLink 
                  href="/register"
                  className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
                >
                  Sign Up
                </TypeSafeLink>
              </div>
            )}
          </div>
        </div>
      </div>
    </nav>
  );
};

// Individual navigation item component
const NavigationItem: React.FC<{
  item: NavigationItem;
  pathname: string;
}> = ({ item, pathname }) => {
  const [isOpen, setIsOpen] = useState(false);
  const hasChildren = item.children && item.children.length > 0;
  const isActive = pathname === item.href || pathname.startsWith(`${item.href}/`);

  if (hasChildren) {
    return (
      <div 
        className="relative"
        onMouseEnter={() => setIsOpen(true)}
        onMouseLeave={() => setIsOpen(false)}
      >
        <button 
          className={`flex items-center space-x-1 text-gray-700 hover:text-gray-900 ${
            isActive ? 'text-blue-600' : ''
          }`}
        >
          {item.icon && <item.icon className="w-4 h-4" />}
          <span>{item.label}</span>
          <ChevronDownIcon className="w-4 h-4" />
        </button>

        {isOpen && (
          <div className="absolute top-full left-0 mt-1 w-48 bg-white rounded-md shadow-lg z-50">
            <div className="py-1">
              {item.children!.map(child => (
                <TypeSafeLink
                  key={child.href}
                  href={child.href}
                  className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                >
                  {child.label}
                </TypeSafeLink>
              ))}
            </div>
          </div>
        )}
      </div>
    );
  }

  return (
    <TypeSafeLink
      href={item.href}
      className={`flex items-center space-x-1 text-gray-700 hover:text-gray-900 ${
        isActive ? 'text-blue-600' : ''
      }`}
    >
      {item.icon && <item.icon className="w-4 h-4" />}
      <span>{item.label}</span>
    </TypeSafeLink>
  );
};
```

---

## Real-World Examples {#real-world-examples}

### E-commerce Multi-Level Category System

```tsx
// app/shop/[...categories]/page.tsx
// Handles routes like:
// /shop/electronics
// /shop/electronics/computers
// /shop/electronics/computers/laptops

interface CategoryPageProps {
  params: {
    categories: string[];
  };
  searchParams: {
    sort?: 'price' | 'name' | 'rating' | 'newest';
    order?: 'asc' | 'desc';
    price_min?: string;
    price_max?: string;
    brands?: string | string[];
    page?: string;
  };
}

const CategoryPage = async ({ params, searchParams }: CategoryPageProps) => {
  const { categories } = params;
  const categoryPath = categories.join('/');
  
  // Validate category path
  if (!categories || categories.length === 0) {
    throw new Error('Invalid category path');
  }

  try {
    // Fetch category data and products
    const [categoryTree, products, filters] = await Promise.all([
      getCategoryTree(categoryPath),
      getProductsByCategory(categoryPath, searchParams),
      getCategoryFilters(categoryPath)
    ]);

    if (!categoryTree) {
      notFound();
    }

    return (
      <div className="max-w-7xl mx-auto px-4 py-8">
        {/* Breadcrumb Navigation */}
        <CategoryBreadcrumbs categories={categoryTree} />

        {/* Category Header */}
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            {categoryTree.name}
          </h1>
          {categoryTree.description && (
            <p className="text-gray-600 max-w-3xl">
              {categoryTree.description}
            </p>
          )}
        </div>

        {/* Subcategories */}
        {categoryTree.children && categoryTree.children.length > 0 && (
          <div className="mb-8">
            <h2 className="text-xl font-semibold mb-4">Shop by Category</h2>
            <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
              {categoryTree.children.map(subcategory => (
                <TypeSafeLink
                  key={subcategory.slug}
                  href={`/shop/${categoryPath}/${subcategory.slug}`}
                  className="group"
                >
                  <div className="bg-white rounded-lg shadow hover:shadow-md transition-shadow p-4 text-center">
                    <img
                      src={subcategory.image}
                      alt={subcategory.name}
                      className="w-12 h-12 mx-auto mb-2 group-hover:scale-110 transition-transform"
                    />
                    <h3 className="text-sm font-medium text-gray-900">
                      {subcategory.name}
                    </h3>
                    <p className="text-xs text-gray-500 mt-1">
                      {subcategory.productCount} items
                    </p>
                  </div>
                </TypeSafeLink>
              ))}
            </div>
          </div>
        )}

        <div className="flex gap-8">
          {/* Filters Sidebar */}
          <aside className="w-64 flex-shrink-0">
            <ProductFilters 
              filters={filters}
              currentParams={searchParams}
              categoryPath={categoryPath}
            />
          </aside>

          {/* Products Grid */}
          <main className="flex-1">
            <ProductsHeader 
              totalCount={products.totalCount}
              currentParams={searchParams}
              categoryPath={categoryPath}
            />
            
            <ProductGrid products={products.items} />
            
            <ProductPagination 
              currentPage={products.currentPage}
              totalPages={products.totalPages}
              categoryPath={categoryPath}
              searchParams={searchParams}
            />
          </main>
        </div>
      </div>
    );
  } catch (error) {
    throw new Error(`Failed to load category page: ${error}`);
  }
};

// Category breadcrumbs component
const CategoryBreadcrumbs: React.FC<{ categories: CategoryTree }> = ({ categories }) => {
  const buildBreadcrumbs = (category: CategoryTree): { name: string; path: string }[] => {
    const breadcrumbs: { name: string; path: string }[] = [];
    let currentCategory: CategoryTree | null = category;
    
    while (currentCategory) {
      breadcrumbs.unshift({
        name: currentCategory.name,
        path: `/shop/${currentCategory.fullPath}`
      });
      currentCategory = currentCategory.parent;
    }
    
    return breadcrumbs;
  };

  const breadcrumbs = buildBreadcrumbs(categories);

  return (
    <nav className="mb-6">
      <ol className="flex items-center space-x-2 text-sm">
        <li>
          <TypeSafeLink href="/shop" className="text-blue-600 hover:underline">
            Shop
          </TypeSafeLink>
        </li>
        {breadcrumbs.map((crumb, index) => (
          <React.Fragment key={crumb.path}>
            <li><span className="text-gray-500">/</span></li>
            <li>
              {index === breadcrumbs.length - 1 ? (
                <span className="text-gray-900">{crumb.name}</span>
              ) : (
                <TypeSafeLink href={crumb.path} className="text-blue-600 hover:underline">
                  {crumb.name}
                </TypeSafeLink>
              )}
            </li>
          </React.Fragment>
        ))}
      </ol>
    </nav>
  );
};

export default CategoryPage;
```

This comprehensive guide covers all aspects of advanced type-safe routing in Next.js with TypeScript. The examples demonstrate how to build complex, nested routing structures with full type safety, proper error handling, and excellent user experience patterns that are essential for production applications.