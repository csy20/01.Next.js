# End-to-End Type Safety with tRPC and Prisma

## Table of Contents
1. [Understanding End-to-End Type Safety](#understanding-end-to-end-type-safety)
2. [Prisma: Type-Safe Database Layer](#prisma-type-safe-database-layer)
3. [tRPC: Type-Safe API Layer](#trpc-type-safe-api-layer)
4. [Complete Integration Architecture](#complete-integration-architecture)
5. [Advanced Patterns and Optimizations](#advanced-patterns-and-optimizations)
6. [Real-World Implementation](#real-world-implementation)
7. [Testing End-to-End Type Safety](#testing-end-to-end-type-safety)

---

## Understanding End-to-End Type Safety

### The Type Safety Journey: Database → API → Frontend

End-to-end type safety means that your types flow seamlessly from your database schema through your API layer to your frontend components, ensuring compile-time guarantees across your entire application stack.

#### Traditional API Development vs Type-Safe Approach

```typescript
// types/comparison.ts
// ❌ Traditional approach - Manual type definitions and potential mismatches
interface User {
  id: string
  name: string
  email: string
  // What if the database has more fields? What if types change?
}

// API response might not match the interface
const fetchUser = async (id: string): Promise<User> => {
  const response = await fetch(`/api/users/${id}`)
  return response.json() // No guarantee this matches User interface
}

// ✅ End-to-end type-safe approach
// Types are automatically generated from database schema
// API calls are fully typed and validated
// Frontend gets exact types from the backend without manual definitions

/**
 * Type Safety Flow:
 * 
 * 1. Database Schema (Prisma) → Generated Types
 * 2. Generated Types → tRPC Router Definitions  
 * 3. tRPC Router → Auto-generated Client Types
 * 4. Client Types → Frontend Components
 * 
 * Benefits:
 * - Single source of truth (database schema)
 * - Compile-time error detection
 * - Automatic type updates when schema changes
 * - IntelliSense throughout the entire stack
 * - Runtime validation with compile-time types
 */
```

#### Architecture Overview

```typescript
// architecture/type-safety-flow.ts
/**
 * End-to-End Type Safety Architecture
 * 
 * Database (PostgreSQL/MySQL)
 *     ↓ (schema.prisma)
 * Prisma Client (Generated Types)
 *     ↓ (database operations)
 * tRPC Router (API Layer)
 *     ↓ (procedure definitions)
 * tRPC Client (Frontend)
 *     ↓ (typed queries/mutations)
 * React Components (UI Layer)
 */

interface TypeSafetyLayers {
  database: {
    tool: 'Prisma'
    purpose: 'Schema definition and type generation'
    output: 'Generated TypeScript types from database schema'
  }
  
  api: {
    tool: 'tRPC'
    purpose: 'Type-safe API procedures'
    output: 'Fully typed API client with IntelliSense'
  }
  
  frontend: {
    tool: 'React + TypeScript'
    purpose: 'Type-safe UI components'
    output: 'Compile-time guaranteed data contracts'
  }
}

// Benefits of this architecture
interface TypeSafetyBenefits {
  developerExperience: [
    'Auto-completion for all API calls',
    'Instant error detection on schema changes',
    'No need to manually write API types',
    'Refactoring safety across the entire stack'
  ]
  
  runtime: [
    'Input validation on API calls',
    'Serialization/deserialization safety',
    'Consistent data shapes across layers',
    'Reduced runtime errors'
  ]
  
  maintenance: [
    'Single source of truth for data models',
    'Automatic type updates on schema changes',
    'Easier collaboration between frontend/backend teams',
    'Self-documenting API contracts'
  ]
}
```

---

## Prisma: Type-Safe Database Layer

### Understanding Prisma's Type Generation

Prisma generates TypeScript types directly from your database schema, creating a single source of truth for your application's data models.

#### Complete Prisma Setup and Schema Definition

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model with relationships
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  avatar    String?
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  posts     Post[]
  comments  Comment[]
  profile   Profile?
  sessions  Session[]

  @@map("users")
}

// Profile model (one-to-one)
model Profile {
  id       String  @id @default(cuid())
  bio      String?
  website  String?
  location String?
  
  userId   String  @unique
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

// Post model with categories (many-to-many)
model Post {
  id          String    @id @default(cuid())
  title       String
  content     String?
  published   Boolean   @default(false)
  publishedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Foreign keys
  authorId    String
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Relationships
  comments    Comment[]
  categories  PostCategory[]
  tags        Tag[]

  @@map("posts")
}

// Comment model (hierarchical)
model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Foreign keys
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Self-referencing for replies
  parentId  String?
  parent    Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies   Comment[] @relation("CommentReplies")

  @@map("comments")
}

// Category model
model Category {
  id          String  @id @default(cuid())
  name        String  @unique
  slug        String  @unique
  description String?
  color       String?

  posts       PostCategory[]

  @@map("categories")
}

// Many-to-many junction table
model PostCategory {
  postId     String
  categoryId String
  
  post       Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([postId, categoryId])
  @@map("post_categories")
}

// Tag model (many-to-many with implicit relation)
model Tag {
  id    String @id @default(cuid())
  name  String @unique
  
  posts Post[]

  @@map("tags")
}

// Session model for authentication
model Session {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("sessions")
}

// Enums
enum Role {
  USER
  MODERATOR
  ADMIN
}
```

#### Generated Types and Database Operations

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'
import type { 
  User, 
  Post, 
  Comment, 
  Category, 
  Profile,
  Tag,
  Role,
  Prisma 
} from '@prisma/client'

// Global Prisma instance with proper typing
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
})

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

// Re-export generated types
export type { User, Post, Comment, Category, Profile, Tag, Role, Prisma }

// Advanced type utilities using Prisma's generated types
export type UserWithProfile = Prisma.UserGetPayload<{
  include: { profile: true }
}>

export type UserWithPosts = Prisma.UserGetPayload<{
  include: { 
    posts: {
      include: {
        categories: {
          include: {
            category: true
          }
        },
        tags: true,
        _count: {
          select: {
            comments: true
          }
        }
      }
    }
  }
}>

export type PostWithAuthorAndComments = Prisma.PostGetPayload<{
  include: {
    author: {
      include: {
        profile: true
      }
    },
    comments: {
      include: {
        author: true,
        replies: {
          include: {
            author: true
          }
        }
      }
    },
    categories: {
      include: {
        category: true
      }
    },
    tags: true
  }
}>

export type CommentWithAuthorAndReplies = Prisma.CommentGetPayload<{
  include: {
    author: true,
    replies: {
      include: {
        author: true
      }
    }
  }
}>

// Type-safe database operations
export class DatabaseService {
  // User operations
  static async createUser(data: Prisma.UserCreateInput): Promise<User> {
    return prisma.user.create({ data })
  }

  static async getUserById(id: string): Promise<UserWithProfile | null> {
    return prisma.user.findUnique({
      where: { id },
      include: { profile: true }
    })
  }

  static async getUserWithPosts(id: string): Promise<UserWithPosts | null> {
    return prisma.user.findUnique({
      where: { id },
      include: {
        posts: {
          include: {
            categories: {
              include: {
                category: true
              }
            },
            tags: true,
            _count: {
              select: {
                comments: true
              }
            }
          }
        }
      }
    })
  }

  // Post operations with complex includes
  static async getPostWithDetails(id: string): Promise<PostWithAuthorAndComments | null> {
    return prisma.post.findUnique({
      where: { id },
      include: {
        author: {
          include: {
            profile: true
          }
        },
        comments: {
          where: {
            parentId: null // Only top-level comments
          },
          include: {
            author: true,
            replies: {
              include: {
                author: true
              }
            }
          },
          orderBy: {
            createdAt: 'desc'
          }
        },
        categories: {
          include: {
            category: true
          }
        },
        tags: true
      }
    })
  }

  // Advanced querying with type safety
  static async getPublishedPostsByCategory(
    categorySlug: string,
    options: {
      skip?: number
      take?: number
      orderBy?: Prisma.PostOrderByWithRelationInput
    } = {}
  ): Promise<PostWithAuthorAndComments[]> {
    const { skip = 0, take = 10, orderBy = { createdAt: 'desc' } } = options

    return prisma.post.findMany({
      where: {
        published: true,
        categories: {
          some: {
            category: {
              slug: categorySlug
            }
          }
        }
      },
      include: {
        author: {
          include: {
            profile: true
          }
        },
        comments: {
          where: {
            parentId: null
          },
          include: {
            author: true,
            _count: {
              select: {
                replies: true
              }
            }
          }
        },
        categories: {
          include: {
            category: true
          }
        },
        tags: true
      },
      skip,
      take,
      orderBy
    })
  }

  // Transaction example with type safety
  static async createPostWithCategories(
    postData: Omit<Prisma.PostCreateInput, 'categories'>,
    categoryIds: string[]
  ): Promise<PostWithAuthorAndComments> {
    return prisma.$transaction(async (tx) => {
      // Create the post
      const post = await tx.post.create({
        data: postData
      })

      // Create category relationships
      await tx.postCategory.createMany({
        data: categoryIds.map(categoryId => ({
          postId: post.id,
          categoryId
        }))
      })

      // Return the complete post with relationships
      return tx.post.findUniqueOrThrow({
        where: { id: post.id },
        include: {
          author: {
            include: {
              profile: true
            }
          },
          comments: {
            include: {
              author: true,
              replies: {
                include: {
                  author: true
                }
              }
            }
          },
          categories: {
            include: {
              category: true
            }
          },
          tags: true
        }
      })
    })
  }

  // Aggregation with type safety
  static async getPostStatsByUser(userId: string) {
    return prisma.post.aggregate({
      where: {
        authorId: userId
      },
      _count: {
        id: true
      },
      _avg: {
        // If you had numeric fields like rating, views, etc.
      }
    })
  }

  // Raw queries with type safety
  static async getTopAuthors(limit: number = 10) {
    return prisma.$queryRaw<Array<{
      id: string
      name: string
      email: string
      postCount: number
    }>>`
      SELECT 
        u.id,
        u.name,
        u.email,
        COUNT(p.id)::int as "postCount"
      FROM users u
      LEFT JOIN posts p ON u.id = p."authorId"
      GROUP BY u.id, u.name, u.email
      ORDER BY COUNT(p.id) DESC
      LIMIT ${limit}
    `
  }
}
```

#### Prisma Middleware and Extensions

```typescript
// lib/prisma-middleware.ts
import { Prisma, PrismaClient } from '@prisma/client'

// Audit logging middleware
export function createAuditMiddleware() {
  return Prisma.middleware(async (params, next) => {
    const before = Date.now()
    const result = await next(params)
    const after = Date.now()

    console.log(`Query ${params.model}.${params.action} took ${after - before}ms`)
    
    // Log mutations for audit trail
    if (['create', 'update', 'delete'].includes(params.action)) {
      console.log('Audit log:', {
        model: params.model,
        action: params.action,
        args: params.args,
        timestamp: new Date().toISOString(),
      })
    }

    return result
  })
}

// Soft delete middleware
export function createSoftDeleteMiddleware() {
  return Prisma.middleware(async (params, next) => {
    // Modify delete operations to set deletedAt instead
    if (params.action === 'delete') {
      params.action = 'update'
      params.args.data = { deletedAt: new Date() }
    }

    // Filter out soft-deleted records in find operations
    if (params.action === 'findMany' || params.action === 'findFirst') {
      if (!params.args.where) {
        params.args.where = {}
      }
      params.args.where.deletedAt = null
    }

    return next(params)
  })
}

// Performance monitoring extension
export const prismaWithExtensions = new PrismaClient().$extends({
  query: {
    $allModels: {
      async $allOperations({ model, operation, args, query }) {
        const start = performance.now()
        const result = await query(args)
        const end = performance.now()
        
        console.log(`${model}.${operation} took ${end - start}ms`)
        
        return result
      }
    }
  },
  result: {
    user: {
      fullName: {
        needs: { name: true },
        compute(user) {
          return user.name || 'Anonymous User'
        }
      }
    },
    post: {
      excerpt: {
        needs: { content: true },
        compute(post) {
          return post.content?.substring(0, 150) + '...' || ''
        }
      }
    }
  }
})

export type ExtendedPrismaClient = typeof prismaWithExtensions
```

---

## tRPC: Type-Safe API Layer

### Understanding tRPC's Type Inference

tRPC automatically generates TypeScript types for your API based on your router definitions, providing end-to-end type safety from server to client.

#### Complete tRPC Router Setup

```typescript
// server/trpc/router.ts
import { initTRPC, TRPCError } from '@trpc/server'
import { type Context } from './context'
import superjson from 'superjson'
import { ZodError } from 'zod'

// Initialize tRPC with context
const t = initTRPC.context<Context>().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.cause instanceof ZodError ? error.cause.flatten() : null,
      },
    }
  },
})

// Reusable middleware
const isAuthed = t.middleware(({ ctx, next }) => {
  if (!ctx.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED' })
  }
  return next({
    ctx: {
      ...ctx,
      user: ctx.user, // Now guaranteed to be non-null
    },
  })
})

const isAdmin = t.middleware(({ ctx, next }) => {
  if (!ctx.user || ctx.user.role !== 'ADMIN') {
    throw new TRPCError({ code: 'FORBIDDEN' })
  }
  return next({
    ctx: {
      ...ctx,
      user: ctx.user,
    },
  })
})

// Export router helpers
export const router = t.router
export const publicProcedure = t.procedure
export const protectedProcedure = t.procedure.use(isAuthed)
export const adminProcedure = t.procedure.use(isAdmin)
```

#### Context Setup with Type Safety

```typescript
// server/trpc/context.ts
import type { NextRequest } from 'next/server'
import { prisma } from '@/lib/prisma'
import { verifyJWT } from '@/lib/auth'
import type { User } from '@prisma/client'

export async function createContext(req: NextRequest) {
  // Extract token from headers
  const token = req.headers.get('authorization')?.replace('Bearer ', '')
  
  let user: User | null = null
  
  if (token) {
    try {
      const decoded = await verifyJWT(token)
      user = await prisma.user.findUnique({
        where: { id: decoded.userId }
      })
    } catch (error) {
      // Invalid token, user remains null
    }
  }

  return {
    prisma,
    user,
    req,
  }
}

export type Context = Awaited<ReturnType<typeof createContext>>
```

#### Comprehensive tRPC Procedures with Validation

```typescript
// server/trpc/routers/posts.ts
import { z } from 'zod'
import { router, publicProcedure, protectedProcedure } from '../router'
import { TRPCError } from '@trpc/server'
import { DatabaseService } from '@/lib/prisma'

// Input validation schemas
const createPostSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
  content: z.string().min(1, 'Content is required'),
  published: z.boolean().default(false),
  categoryIds: z.array(z.string().cuid()).optional(),
  tags: z.array(z.string().trim().min(1)).optional(),
})

const updatePostSchema = z.object({
  id: z.string().cuid(),
  title: z.string().min(1).max(200).optional(),
  content: z.string().min(1).optional(),
  published: z.boolean().optional(),
  categoryIds: z.array(z.string().cuid()).optional(),
  tags: z.array(z.string().trim().min(1)).optional(),
})

const getPostsSchema = z.object({
  cursor: z.string().cuid().optional(),
  limit: z.number().min(1).max(100).default(10),
  categorySlug: z.string().optional(),
  published: z.boolean().optional(),
  search: z.string().optional(),
})

export const postsRouter = router({
  // Get paginated posts with infinite scroll
  getInfinite: publicProcedure
    .input(getPostsSchema)
    .query(async ({ ctx, input }) => {
      const { cursor, limit, categorySlug, published, search } = input

      const posts = await ctx.prisma.post.findMany({
        where: {
          ...(published !== undefined && { published }),
          ...(categorySlug && {
            categories: {
              some: {
                category: {
                  slug: categorySlug
                }
              }
            }
          }),
          ...(search && {
            OR: [
              { title: { contains: search, mode: 'insensitive' } },
              { content: { contains: search, mode: 'insensitive' } }
            ]
          })
        },
        include: {
          author: {
            include: {
              profile: true
            }
          },
          categories: {
            include: {
              category: true
            }
          },
          tags: true,
          _count: {
            select: {
              comments: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: limit + 1,
        ...(cursor && {
          cursor: {
            id: cursor
          },
          skip: 1
        })
      })

      let nextCursor: string | undefined = undefined
      if (posts.length > limit) {
        const nextItem = posts.pop()
        nextCursor = nextItem!.id
      }

      return {
        posts,
        nextCursor
      }
    }),

  // Get single post by ID
  getById: publicProcedure
    .input(z.object({ id: z.string().cuid() }))
    .query(async ({ ctx, input }) => {
      const post = await DatabaseService.getPostWithDetails(input.id)
      
      if (!post) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Post not found'
        })
      }

      return post
    }),

  // Create new post (protected)
  create: protectedProcedure
    .input(createPostSchema)
    .mutation(async ({ ctx, input }) => {
      const { categoryIds, tags, ...postData } = input

      // Create post with categories in transaction
      const post = await ctx.prisma.$transaction(async (tx) => {
        // Create the post
        const newPost = await tx.post.create({
          data: {
            ...postData,
            authorId: ctx.user.id,
            publishedAt: input.published ? new Date() : null,
          }
        })

        // Add categories if provided
        if (categoryIds && categoryIds.length > 0) {
          await tx.postCategory.createMany({
            data: categoryIds.map(categoryId => ({
              postId: newPost.id,
              categoryId
            }))
          })
        }

        // Add tags if provided
        if (tags && tags.length > 0) {
          // Create or connect tags
          for (const tagName of tags) {
            await tx.tag.upsert({
              where: { name: tagName },
              update: {},
              create: { name: tagName }
            })
          }

          // Connect tags to post
          await tx.post.update({
            where: { id: newPost.id },
            data: {
              tags: {
                connect: tags.map(name => ({ name }))
              }
            }
          })
        }

        // Return complete post
        return tx.post.findUniqueOrThrow({
          where: { id: newPost.id },
          include: {
            author: {
              include: {
                profile: true
              }
            },
            categories: {
              include: {
                category: true
              }
            },
            tags: true
          }
        })
      })

      return post
    }),

  // Update post (protected)
  update: protectedProcedure
    .input(updatePostSchema)
    .mutation(async ({ ctx, input }) => {
      const { id, categoryIds, tags, ...updateData } = input

      // Check if user owns the post or is admin
      const existingPost = await ctx.prisma.post.findUnique({
        where: { id },
        select: { authorId: true }
      })

      if (!existingPost) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Post not found'
        })
      }

      if (existingPost.authorId !== ctx.user.id && ctx.user.role !== 'ADMIN') {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Not authorized to update this post'
        })
      }

      // Update post with transaction
      const updatedPost = await ctx.prisma.$transaction(async (tx) => {
        // Update post data
        const post = await tx.post.update({
          where: { id },
          data: {
            ...updateData,
            ...(updateData.published !== undefined && {
              publishedAt: updateData.published ? new Date() : null
            })
          }
        })

        // Update categories if provided
        if (categoryIds !== undefined) {
          // Remove existing categories
          await tx.postCategory.deleteMany({
            where: { postId: id }
          })

          // Add new categories
          if (categoryIds.length > 0) {
            await tx.postCategory.createMany({
              data: categoryIds.map(categoryId => ({
                postId: id,
                categoryId
              }))
            })
          }
        }

        // Update tags if provided
        if (tags !== undefined) {
          // Disconnect all existing tags
          await tx.post.update({
            where: { id },
            data: {
              tags: {
                set: []
              }
            }
          })

          // Connect new tags
          if (tags.length > 0) {
            // Create or find tags
            for (const tagName of tags) {
              await tx.tag.upsert({
                where: { name: tagName },
                update: {},
                create: { name: tagName }
              })
            }

            // Connect tags to post
            await tx.post.update({
              where: { id },
              data: {
                tags: {
                  connect: tags.map(name => ({ name }))
                }
              }
            })
          }
        }

        // Return complete post
        return tx.post.findUniqueOrThrow({
          where: { id },
          include: {
            author: {
              include: {
                profile: true
              }
            },
            categories: {
              include: {
                category: true
              }
            },
            tags: true
          }
        })
      })

      return updatedPost
    }),

  // Delete post (protected)
  delete: protectedProcedure
    .input(z.object({ id: z.string().cuid() }))
    .mutation(async ({ ctx, input }) => {
      // Check ownership
      const post = await ctx.prisma.post.findUnique({
        where: { id: input.id },
        select: { authorId: true }
      })

      if (!post) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Post not found'
        })
      }

      if (post.authorId !== ctx.user.id && ctx.user.role !== 'ADMIN') {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'Not authorized to delete this post'
        })
      }

      await ctx.prisma.post.delete({
        where: { id: input.id }
      })

      return { success: true }
    }),

  // Get user's posts
  getByUser: publicProcedure
    .input(z.object({
      userId: z.string().cuid(),
      published: z.boolean().optional(),
      cursor: z.string().cuid().optional(),
      limit: z.number().min(1).max(50).default(10)
    }))
    .query(async ({ ctx, input }) => {
      const { userId, published, cursor, limit } = input

      const posts = await ctx.prisma.post.findMany({
        where: {
          authorId: userId,
          ...(published !== undefined && { published })
        },
        include: {
          categories: {
            include: {
              category: true
            }
          },
          tags: true,
          _count: {
            select: {
              comments: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: limit + 1,
        ...(cursor && {
          cursor: { id: cursor },
          skip: 1
        })
      })

      let nextCursor: string | undefined = undefined
      if (posts.length > limit) {
        const nextItem = posts.pop()
        nextCursor = nextItem!.id
      }

      return {
        posts,
        nextCursor
      }
    })
})
```

#### Main Router Assembly

```typescript
// server/trpc/routers/_app.ts
import { router } from '../router'
import { postsRouter } from './posts'
import { usersRouter } from './users'
import { commentsRouter } from './comments'
import { categoriesRouter } from './categories'
import { authRouter } from './auth'

export const appRouter = router({
  posts: postsRouter,
  users: usersRouter,
  comments: commentsRouter,
  categories: categoriesRouter,
  auth: authRouter,
})

export type AppRouter = typeof appRouter
```

---

## Complete Integration Architecture

### Client-Side tRPC Setup

```typescript
// lib/trpc/client.ts
import { createTRPCReact } from '@trpc/react-query'
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client'
import { type AppRouter } from '@/server/trpc/routers/_app'
import superjson from 'superjson'

// React Query integration
export const trpc = createTRPCReact<AppRouter>()

// Vanilla client for server-side usage
export const trpcClient = createTRPCProxyClient<AppRouter>({
  transformer: superjson,
  links: [
    httpBatchLink({
      url: '/api/trpc',
      headers() {
        return {
          authorization: typeof window !== 'undefined' 
            ? `Bearer ${localStorage.getItem('token')}` 
            : '',
        }
      },
    }),
  ],
})

// Client configuration
export function getTRPCClient() {
  return trpc.createClient({
    transformer: superjson,
    links: [
      httpBatchLink({
        url: '/api/trpc',
        headers() {
          return {
            authorization: typeof window !== 'undefined' 
              ? `Bearer ${localStorage.getItem('token')}` 
              : '',
          }
        },
      }),
    ],
  })
}
```

#### Provider Setup for Next.js App Router

```typescript
// providers/trpc-provider.tsx
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { trpc } from '@/lib/trpc/client'
import { useState } from 'react'
import superjson from 'superjson'
import { httpBatchLink } from '@trpc/client'

export function TRPCProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 30 * 1000, // 30 seconds
            gcTime: 5 * 60 * 1000, // 5 minutes
          },
        },
      })
  )

  const [trpcClient] = useState(() =>
    trpc.createClient({
      transformer: superjson,
      links: [
        httpBatchLink({
          url: '/api/trpc',
          headers() {
            return {
              authorization: typeof window !== 'undefined' 
                ? `Bearer ${localStorage.getItem('token')}` 
                : '',
            }
          },
        }),
      ],
    })
  )

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        {children}
        <ReactQueryDevtools initialIsOpen={false} />
      </QueryClientProvider>
    </trpc.Provider>
  )
}
```

### API Route Handler for Next.js

```typescript
// app/api/trpc/[trpc]/route.ts
import { fetchRequestHandler } from '@trpc/server/adapters/fetch'
import { type NextRequest } from 'next/server'
import { appRouter } from '@/server/trpc/routers/_app'
import { createContext } from '@/server/trpc/context'

const handler = (req: NextRequest) =>
  fetchRequestHandler({
    endpoint: '/api/trpc',
    req,
    router: appRouter,
    createContext: () => createContext(req),
    onError:
      process.env.NODE_ENV === 'development'
        ? ({ path, error }) => {
            console.error(
              `❌ tRPC failed on ${path ?? '<no-path>'}: ${error.message}`
            )
          }
        : undefined,
  })

export { handler as GET, handler as POST }
```

---

## Advanced Patterns and Optimizations

### Optimistic Updates with Type Safety

```typescript
// hooks/useOptimisticPosts.ts
import { trpc } from '@/lib/trpc/client'
import { type RouterOutputs } from '@/lib/trpc/types'
import { useCallback } from 'react'

type Post = RouterOutputs['posts']['getInfinite']['posts'][0]
type CreatePostInput = Parameters<typeof trpc.posts.create.mutate>[0]

export function useOptimisticPosts() {
  const utils = trpc.useUtils()

  const createPost = trpc.posts.create.useMutation({
    onMutate: async (newPost: CreatePostInput) => {
      // Cancel outgoing refetches
      await utils.posts.getInfinite.cancel()

      // Snapshot previous value
      const previousPosts = utils.posts.getInfinite.getInfiniteData()

      // Optimistically update
      utils.posts.getInfinite.setInfiniteData(
        { limit: 10 },
        (old) => {
          if (!old) return { pages: [], pageParams: [] }

          const optimisticPost: Post = {
            id: `temp-${Date.now()}`,
            title: newPost.title,
            content: newPost.content || '',
            published: newPost.published || false,
            publishedAt: newPost.published ? new Date() : null,
            createdAt: new Date(),
            updatedAt: new Date(),
            authorId: 'current-user-id', // Get from auth context
            author: {
              id: 'current-user-id',
              name: 'Current User',
              email: 'user@example.com',
              avatar: null,
              role: 'USER',
              createdAt: new Date(),
              updatedAt: new Date(),
              profile: null,
            },
            categories: [],
            tags: [],
            comments: [],
            _count: { comments: 0 },
          }

          return {
            ...old,
            pages: [
              {
                posts: [optimisticPost, ...old.pages[0]?.posts || []],
                nextCursor: old.pages[0]?.nextCursor,
              },
              ...old.pages.slice(1),
            ],
          }
        }
      )

      return { previousPosts }
    },
    onError: (err, newPost, context) => {
      // Rollback on error
      if (context?.previousPosts) {
        utils.posts.getInfinite.setInfiniteData(
          { limit: 10 },
          context.previousPosts
        )
      }
    },
    onSettled: () => {
      // Refetch to ensure we have accurate data
      utils.posts.getInfinite.invalidate()
    },
  })

  const updatePost = trpc.posts.update.useMutation({
    onMutate: async (updatedPost) => {
      await utils.posts.getById.cancel({ id: updatedPost.id })
      
      const previousPost = utils.posts.getById.getData({ id: updatedPost.id })
      
      // Update single post cache
      utils.posts.getById.setData(
        { id: updatedPost.id },
        (old) => old ? { ...old, ...updatedPost } : undefined
      )

      // Update infinite query cache
      utils.posts.getInfinite.setInfiniteData(
        { limit: 10 },
        (old) => {
          if (!old) return old

          return {
            ...old,
            pages: old.pages.map(page => ({
              ...page,
              posts: page.posts.map(post =>
                post.id === updatedPost.id
                  ? { ...post, ...updatedPost }
                  : post
              ),
            })),
          }
        }
      )

      return { previousPost }
    },
    onError: (err, variables, context) => {
      if (context?.previousPost) {
        utils.posts.getById.setData(
          { id: variables.id },
          context.previousPost
        )
      }
    },
    onSettled: (data, error, variables) => {
      utils.posts.getById.invalidate({ id: variables.id })
      utils.posts.getInfinite.invalidate()
    },
  })

  return {
    createPost: createPost.mutateAsync,
    updatePost: updatePost.mutateAsync,
    isCreating: createPost.isPending,
    isUpdating: updatePost.isPending,
  }
}
```

### Server-Side Rendering with tRPC

```typescript
// app/posts/[id]/page.tsx
import { trpcClient } from '@/lib/trpc/client'
import { PostDetail } from '@/components/PostDetail'
import { notFound } from 'next/navigation'
import { Metadata } from 'next'

interface PageProps {
  params: { id: string }
}

// Generate metadata with type safety
export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
  try {
    const post = await trpcClient.posts.getById.query({ id: params.id })
    
    return {
      title: post.title,
      description: post.content?.substring(0, 160) || '',
      openGraph: {
        title: post.title,
        description: post.content?.substring(0, 160) || '',
        type: 'article',
        publishedTime: post.publishedAt?.toISOString(),
        authors: [post.author.name || ''],
        tags: post.tags.map(tag => tag.name),
      },
    }
  } catch {
    return {
      title: 'Post Not Found',
    }
  }
}

export default async function PostPage({ params }: PageProps) {
  try {
    // Server-side data fetching with full type safety
    const post = await trpcClient.posts.getById.query({ id: params.id })
    
    return <PostDetail initialData={post} />
  } catch {
    notFound()
  }
}

// Pre-render popular posts
export async function generateStaticParams() {
  // Get popular posts for static generation
  const posts = await trpcClient.posts.getInfinite.query({ 
    limit: 50,
    published: true 
  })
  
  return posts.posts.map((post) => ({
    id: post.id,
  }))
}
```

### Real-Time Updates with Subscriptions

```typescript
// server/trpc/routers/realtime.ts
import { observable } from '@trpc/server/observable'
import { EventEmitter } from 'events'
import { z } from 'zod'
import { publicProcedure, router } from '../router'

// Global event emitter for real-time updates
const ee = new EventEmitter()

export const realtimeRouter = router({
  // Subscribe to post updates
  onPostUpdate: publicProcedure
    .input(z.object({ postId: z.string().cuid() }))
    .subscription(({ input }) => {
      return observable<{ postId: string; type: 'update' | 'delete' }>((emit) => {
        const onUpdate = (data: { postId: string; type: 'update' | 'delete' }) => {
          if (data.postId === input.postId) {
            emit.next(data)
          }
        }

        ee.on('postUpdate', onUpdate)

        return () => {
          ee.off('postUpdate', onUpdate)
        }
      })
    }),

  // Subscribe to new comments
  onNewComment: publicProcedure
    .input(z.object({ postId: z.string().cuid() }))
    .subscription(({ input }) => {
      return observable<{ comment: any }>((emit) => {
        const onComment = (data: { postId: string; comment: any }) => {
          if (data.postId === input.postId) {
            emit.next({ comment: data.comment })
          }
        }

        ee.on('newComment', onComment)

        return () => {
          ee.off('newComment', onComment)
        }
      })
    }),
})

// Helper to emit events
export const emitPostUpdate = (postId: string, type: 'update' | 'delete') => {
  ee.emit('postUpdate', { postId, type })
}

export const emitNewComment = (postId: string, comment: any) => {
  ee.emit('newComment', { postId, comment })
}
```

---

## Real-World Implementation

### Complete Blog Application with Type Safety

```typescript
// components/PostsList.tsx
'use client'

import { trpc } from '@/lib/trpc/client'
import { useState } from 'react'
import { PostCard } from './PostCard'
import { LoadingSpinner } from './LoadingSpinner'
import { Button } from './ui/Button'

interface PostsListProps {
  categorySlug?: string
  userId?: string
}

export function PostsList({ categorySlug, userId }: PostsListProps) {
  const [search, setSearch] = useState('')

  // Infinite query with full type safety
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    error,
  } = trpc.posts.getInfinite.useInfiniteQuery(
    {
      limit: 10,
      categorySlug,
      search: search.trim() || undefined,
      published: true,
    },
    {
      getNextPageParam: (lastPage) => lastPage.nextCursor,
      staleTime: 1000 * 60 * 5, // 5 minutes
    }
  )

  // Get user's posts if userId provided
  const userPostsQuery = trpc.posts.getByUser.useInfiniteQuery(
    {
      userId: userId!,
      limit: 10,
      published: true,
    },
    {
      enabled: !!userId,
      getNextPageParam: (lastPage) => lastPage.nextCursor,
    }
  )

  const postsData = userId ? userPostsQuery : { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, error }

  if (isLoading) {
    return <LoadingSpinner />
  }

  if (error) {
    return (
      <div className="text-center py-8">
        <p className="text-red-600">Error loading posts: {error.message}</p>
      </div>
    )
  }

  const posts = postsData.data?.pages.flatMap(page => page.posts) ?? []

  return (
    <div className="space-y-6">
      {/* Search */}
      <div className="relative">
        <input
          type="text"
          placeholder="Search posts..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
        />
      </div>

      {/* Posts Grid */}
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {posts.map((post) => (
          <PostCard key={post.id} post={post} />
        ))}
      </div>

      {/* Load More */}
      {hasNextPage && (
        <div className="text-center">
          <Button
            onClick={() => fetchNextPage()}
            disabled={isFetchingNextPage}
            variant="outline"
          >
            {isFetchingNextPage ? 'Loading...' : 'Load More Posts'}
          </Button>
        </div>
      )}

      {posts.length === 0 && !isLoading && (
        <div className="text-center py-12">
          <p className="text-gray-500">No posts found.</p>
        </div>
      )}
    </div>
  )
}
```

#### PostCard Component with Type Safety

```typescript
// components/PostCard.tsx
import { type RouterOutputs } from '@/lib/trpc/types'
import Link from 'next/link'
import { formatDistanceToNow } from 'date-fns'
import { Badge } from './ui/Badge'
import { Avatar } from './ui/Avatar'

// Exact type from tRPC router output
type Post = RouterOutputs['posts']['getInfinite']['posts'][0]

interface PostCardProps {
  post: Post
}

export function PostCard({ post }: PostCardProps) {
  return (
    <article className="bg-white rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow">
      <div className="p-6">
        {/* Title */}
        <h3 className="text-xl font-semibold mb-2">
          <Link 
            href={`/posts/${post.id}`}
            className="hover:text-blue-600 transition-colors"
          >
            {post.title}
          </Link>
        </h3>

        {/* Excerpt */}
        {post.content && (
          <p className="text-gray-600 mb-4 line-clamp-3">
            {post.content.substring(0, 150)}...
          </p>
        )}

        {/* Categories */}
        {post.categories.length > 0 && (
          <div className="mb-4 flex flex-wrap gap-2">
            {post.categories.map(({ category }) => (
              <Badge key={category.id} variant="secondary">
                <Link href={`/categories/${category.slug}`}>
                  {category.name}
                </Link>
              </Badge>
            ))}
          </div>
        )}

        {/* Tags */}
        {post.tags.length > 0 && (
          <div className="mb-4 flex flex-wrap gap-1">
            {post.tags.map((tag) => (
              <Badge key={tag.id} variant="outline" size="sm">
                #{tag.name}
              </Badge>
            ))}
          </div>
        )}

        {/* Author and Meta */}
        <div className="flex items-center justify-between text-sm text-gray-500">
          <div className="flex items-center gap-2">
            <Avatar
              src={post.author.avatar}
              alt={post.author.name || 'Author'}
              size="sm"
            />
            <span>{post.author.name || 'Anonymous'}</span>
          </div>
          
          <div className="flex items-center gap-4">
            <span>
              {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })}
            </span>
            {post._count.comments > 0 && (
              <span>
                {post._count.comments} comment{post._count.comments !== 1 ? 's' : ''}
              </span>
            )}
          </div>
        </div>
      </div>
    </article>
  )
}
```

#### Post Creation Form with Validation

```typescript
// components/CreatePostForm.tsx
'use client'

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { trpc } from '@/lib/trpc/client'
import { Button } from './ui/Button'
import { Input } from './ui/Input'
import { Textarea } from './ui/Textarea'
import { Select } from './ui/Select'
import { Checkbox } from './ui/Checkbox'
import { TagInput } from './ui/TagInput'
import { useRouter } from 'next/navigation'
import { toast } from 'sonner'

// Validation schema matching tRPC input
const createPostSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
  content: z.string().min(1, 'Content is required'),
  published: z.boolean().default(false),
  categoryIds: z.array(z.string()).optional(),
  tags: z.array(z.string()).optional(),
})

type CreatePostForm = z.infer<typeof createPostSchema>

export function CreatePostForm() {
  const router = useRouter()
  const [tags, setTags] = useState<string[]>([])

  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
    setValue,
  } = useForm<CreatePostForm>({
    resolver: zodResolver(createPostSchema),
    defaultValues: {
      published: false,
      categoryIds: [],
      tags: [],
    },
  })

  // Get categories for selection
  const { data: categories } = trpc.categories.getAll.useQuery()

  // Create post mutation
  const createPost = trpc.posts.create.useMutation({
    onSuccess: (post) => {
      toast.success('Post created successfully!')
      router.push(`/posts/${post.id}`)
    },
    onError: (error) => {
      toast.error(error.message || 'Failed to create post')
    },
  })

  const onSubmit = (data: CreatePostForm) => {
    createPost.mutate({
      ...data,
      tags: tags.length > 0 ? tags : undefined,
    })
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Title */}
      <div>
        <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-1">
          Title *
        </label>
        <Input
          id="title"
          {...register('title')}
          placeholder="Enter post title..."
          error={errors.title?.message}
        />
      </div>

      {/* Content */}
      <div>
        <label htmlFor="content" className="block text-sm font-medium text-gray-700 mb-1">
          Content *
        </label>
        <Textarea
          id="content"
          {...register('content')}
          placeholder="Write your post content..."
          rows={10}
          error={errors.content?.message}
        />
      </div>

      {/* Categories */}
      <div>
        <label htmlFor="categories" className="block text-sm font-medium text-gray-700 mb-1">
          Categories
        </label>
        <Select
          multiple
          options={categories?.map(cat => ({
            value: cat.id,
            label: cat.name,
          })) || []}
          onChange={(values) => setValue('categoryIds', values)}
          placeholder="Select categories..."
        />
      </div>

      {/* Tags */}
      <div>
        <label htmlFor="tags" className="block text-sm font-medium text-gray-700 mb-1">
          Tags
        </label>
        <TagInput
          value={tags}
          onChange={setTags}
          placeholder="Add tags..."
        />
      </div>

      {/* Published */}
      <div className="flex items-center gap-2">
        <Checkbox
          id="published"
          {...register('published')}
        />
        <label htmlFor="published" className="text-sm font-medium text-gray-700">
          Publish immediately
        </label>
      </div>

      {/* Submit */}
      <div className="flex gap-4">
        <Button
          type="submit"
          disabled={createPost.isPending}
          className="flex-1"
        >
          {createPost.isPending ? 'Creating...' : 'Create Post'}
        </Button>
        
        <Button
          type="button"
          variant="outline"
          onClick={() => router.back()}
        >
          Cancel
        </Button>
      </div>
    </form>
  )
}
```

---

## Testing End-to-End Type Safety

### Testing tRPC Procedures

```typescript
// __tests__/trpc/posts.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { createContext } from '@/server/trpc/context'
import { appRouter } from '@/server/trpc/routers/_app'
import { prisma } from '@/lib/prisma'
import { createMockUser, createMockPost } from '../utils/test-utils'

// Create test context
const createTestContext = (user?: any) => ({
  prisma,
  user,
  req: {} as any,
})

describe('Posts tRPC Router', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('posts.getById', () => {
    it('should return post with full type safety', async () => {
      const mockPost = createMockPost()
      vi.mocked(prisma.post.findUnique).mockResolvedValue(mockPost)

      const caller = appRouter.createCaller(createTestContext())
      const result = await caller.posts.getById({ id: 'test-id' })

      // TypeScript ensures the result matches the expected type
      expect(result).toMatchObject({
        id: expect.any(String),
        title: expect.any(String),
        author: expect.objectContaining({
          id: expect.any(String),
          name: expect.any(String),
        }),
      })
    })

    it('should throw NOT_FOUND for non-existent post', async () => {
      vi.mocked(prisma.post.findUnique).mockResolvedValue(null)

      const caller = appRouter.createCaller(createTestContext())
      
      await expect(caller.posts.getById({ id: 'non-existent' }))
        .rejects.toMatchObject({
          code: 'NOT_FOUND',
          message: 'Post not found',
        })
    })
  })

  describe('posts.create', () => {
    it('should create post with authenticated user', async () => {
      const mockUser = createMockUser()
      const mockPost = createMockPost()
      
      vi.mocked(prisma.$transaction).mockResolvedValue(mockPost)

      const caller = appRouter.createCaller(createTestContext(mockUser))
      
      const input = {
        title: 'Test Post',
        content: 'Test content',
        published: true,
      }

      const result = await caller.posts.create(input)

      // Type safety ensures proper structure
      expect(result).toMatchObject({
        title: input.title,
        content: input.content,
        published: input.published,
        author: expect.objectContaining({
          id: mockUser.id,
        }),
      })
    })

    it('should throw UNAUTHORIZED for unauthenticated requests', async () => {
      const caller = appRouter.createCaller(createTestContext())

      await expect(caller.posts.create({
        title: 'Test',
        content: 'Content',
        published: true,
      })).rejects.toMatchObject({
        code: 'UNAUTHORIZED',
      })
    })
  })
})
```

This comprehensive guide demonstrates how tRPC and Prisma work together to provide complete end-to-end type safety in Next.js applications, eliminating the traditional disconnect between frontend and backend while ensuring compile-time guarantees across your entire application stack.