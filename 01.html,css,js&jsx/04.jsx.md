# React.js - The UI Library

## What is React?

React is like having **LEGO blocks for websites**. Instead of building everything from scratch each time, you create reusable pieces (components) that you can combine to build complex user interfaces.

Think of it this way:
- **Traditional HTML/CSS/JS** = Building a house from scratch every time
- **React** = Having pre-made rooms (components) that you can arrange and customize

**Why React is awesome:**
- **Reusable Components** - Write once, use everywhere
- **Dynamic Updates** - Changes happen instantly without page reloads
- **Organized Code** - Everything is structured and easy to maintain
- **Popular** - Used by Facebook, Netflix, Airbnb, and millions of websites

# JSX and React - From First Principles to Real-World Applications

## What is JSX? - Understanding the Foundation

JSX (JavaScript XML) is a **syntax extension** that allows you to write HTML-like syntax directly in JavaScript. Think of it as a bridge between the declarative nature of HTML and the dynamic power of JavaScript.

### The First Principle: Why JSX Exists

Traditional web development separates concerns by technology:
- HTML for structure
- CSS for styling  
- JavaScript for behavior

React revolutionized this by separating concerns by **feature/component** instead:
- Everything related to a user interface component lives together
- JSX enables this by letting you describe UI structure using familiar HTML-like syntax
- But it's actually JavaScript under the hood - giving you the full power of programming

### How JSX Works - The Transformation

```jsx
// What you write (JSX)
const greeting = <h1>Hello, World!</h1>;

// What it becomes (JavaScript)
const greeting = React.createElement('h1', null, 'Hello, World!');

// What gets created (Virtual DOM Object)
const greeting = {
  type: 'h1',
  props: {
    children: 'Hello, World!'
  }
};
```

### Basic JSX Syntax - Building Blocks

```jsx
// Simple element
const title = <h1>Welcome to React</h1>;

// Element with attributes (note: className instead of class)
const styled = <div className="container" id="main-content">Content here</div>;

// Self-closing elements
const image = <img src="photo.jpg" alt="Description" />;
const lineBreak = <br />;

// Multiple elements must be wrapped in a parent
const content = (
  <div>
    <h1>Title</h1>
    <p>Description</p>
  </div>
);

// React Fragment - wrapper that doesn't create extra DOM nodes
const fragmentContent = (
  <>
    <h1>Title</h1>
    <p>Description</p>
  </>
);

// Explicit Fragment syntax
const explicitFragment = (
  <React.Fragment>
    <h1>Title</h1>
    <p>Description</p>
  </React.Fragment>
);
```

## JavaScript Expressions in JSX - Dynamic Content

JSX becomes powerful when you embed JavaScript expressions using curly braces `{}`:

```jsx
// Variables
const name = "John";
const age = 30;
const element = <h1>Hello, {name}! You are {age} years old.</h1>;

// Function calls
function formatName(user) {
  return `${user.firstName} ${user.lastName}`;
}

const user = { firstName: 'John', lastName: 'Doe' };
const greeting = <h1>Hello, {formatName(user)}!</h1>;

// Mathematical expressions
const price = 19.99;
const tax = 0.08;
const total = <p>Total: ${(price * (1 + tax)).toFixed(2)}</p>;

// Conditional rendering
const isLoggedIn = true;
const welcomeMessage = (
  <div>
    {isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign up.</h1>}
  </div>
);

// Array mapping (creating lists)
const items = ['Apple', 'Banana', 'Orange'];
const itemList = (
  <ul>
    {items.map((item, index) => (
      <li key={index}>{item}</li>
    ))}
  </ul>
);

// Complex expressions
const users = [
  { id: 1, name: 'John', active: true },
  { id: 2, name: 'Jane', active: false },
  { id: 3, name: 'Bob', active: true }
];

const userList = (
  <div>
    <h2>Active Users: {users.filter(user => user.active).length}</h2>
    {users
      .filter(user => user.active)
      .map(user => (
        <div key={user.id} className="user-card">
          <h3>{user.name}</h3>
          <span className="status">Online</span>
        </div>
      ))
    }
  </div>
);
```

## React Components - Building with JSX

### Function Components - The Modern Approach

```jsx
// Simple function component
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

// Arrow function component
const Welcome = (props) => {
  return <h1>Hello, {props.name}!</h1>;
};

// Implicit return for simple components
const Welcome = ({ name }) => <h1>Hello, {name}!</h1>;

// Using components
const App = () => {
  return (
    <div>
      <Welcome name="John" />
      <Welcome name="Jane" />
      <Welcome name="Bob" />
    </div>
  );
};
```

### Props - Passing Data to Components

```jsx
// Component that receives props
function UserCard({ name, email, avatar, isOnline }) {
  return (
    <div className={`user-card ${isOnline ? 'online' : 'offline'}`}>
      <img src={avatar} alt={`${name}'s avatar`} />
      <div className="user-info">
        <h3>{name}</h3>
        <p>{email}</p>
        <span className="status">
          {isOnline ? '🟢 Online' : '🔴 Offline'}
        </span>
      </div>
    </div>
  );
}

// Using the component with props
const App = () => {
  const users = [
    {
      id: 1,
      name: 'John Doe',
      email: 'john@example.com',
      avatar: 'https://example.com/john.jpg',
      isOnline: true
    },
    {
      id: 2,
      name: 'Jane Smith',
      email: 'jane@example.com',
      avatar: 'https://example.com/jane.jpg',
      isOnline: false
    }
  ];

  return (
    <div className="user-list">
      <h1>Team Members</h1>
      {users.map(user => (
        <UserCard
          key={user.id}
          name={user.name}
          email={user.email}
          avatar={user.avatar}
          isOnline={user.isOnline}
        />
      ))}
    </div>
  );
};
```

### Props Children - Composition Pattern

```jsx
// Container component that uses children
function Card({ title, children }) {
  return (
    <div className="card">
      <div className="card-header">
        <h2>{title}</h2>
      </div>
      <div className="card-body">
        {children}
      </div>
    </div>
  );
}

// Layout component
function Layout({ children }) {
  return (
    <div className="app-layout">
      <header>
        <nav>Navigation</nav>
      </header>
      <main>{children}</main>
      <footer>Footer content</footer>
    </div>
  );
}

// Using composition
const App = () => {
  return (
    <Layout>
      <Card title="User Profile">
        <UserCard name="John" email="john@example.com" />
      </Card>
      
      <Card title="Statistics">
        <p>Total users: 1,234</p>
        <p>Active sessions: 567</p>
      </Card>
    </Layout>
  );
};
```

## React Hooks - Managing State and Effects

### useState Hook - Component State

```jsx
import React, { useState } from 'react';

// Simple counter component
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
      <button onClick={() => setCount(0)}>
        Reset
      </button>
    </div>
  );
}

// Form with multiple state variables
function UserForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState('');
  const [errors, setErrors] = useState({});

  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Validation
    const newErrors = {};
    if (!name.trim()) newErrors.name = 'Name is required';
    if (!email.includes('@')) newErrors.email = 'Valid email is required';
    if (age < 18) newErrors.age = 'Must be 18 or older';

    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return;
    }

    // Submit the form
    console.log('Submitting:', { name, email, age });
    
    // Reset form
    setName('');
    setEmail('');
    setAge('');
    setErrors({});
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Name:</label>
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          className={errors.name ? 'error' : ''}
        />
        {errors.name && <span className="error-text">{errors.name}</span>}
      </div>

      <div>
        <label>Email:</label>
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className={errors.email ? 'error' : ''}
        />
        {errors.email && <span className="error-text">{errors.email}</span>}
      </div>

      <div>
        <label>Age:</label>
        <input
          type="number"
          value={age}
          onChange={(e) => setAge(parseInt(e.target.value))}
          className={errors.age ? 'error' : ''}
        />
        {errors.age && <span className="error-text">{errors.age}</span>}
      </div>

      <button type="submit">Submit</button>
    </form>
  );
}

// Object state management
function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [inputValue, setInputValue] = useState('');

  const addTodo = () => {
    if (inputValue.trim()) {
      setTodos([
        ...todos,
        {
          id: Date.now(),
          text: inputValue,
          completed: false
        }
      ]);
      setInputValue('');
    }
  };

  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div className="todo-app">
      <div className="todo-input">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && addTodo()}
          placeholder="Add a new todo..."
        />
        <button onClick={addTodo}>Add</button>
      </div>

      <div className="todo-list">
        {todos.map(todo => (
          <div key={todo.id} className={`todo-item ${todo.completed ? 'completed' : ''}`}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span>{todo.text}</span>
            <button onClick={() => deleteTodo(todo.id)}>Delete</button>
          </div>
        ))}
      </div>

      <div className="todo-stats">
        <p>Total: {todos.length}</p>
        <p>Completed: {todos.filter(t => t.completed).length}</p>
        <p>Remaining: {todos.filter(t => !t.completed).length}</p>
      </div>
    </div>
  );
}
```

### useEffect Hook - Side Effects

```jsx
import React, { useState, useEffect } from 'react';

// Basic effect - runs after every render
function DocumentTitle() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

// Effect with dependency array - runs only when dependencies change
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
          throw new Error('Failed to fetch user');
        }
        
        const userData = await response.json();
        setUser(userData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    if (userId) {
      fetchUser();
    }
  }, [userId]); // Only re-run when userId changes

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>No user found</div>;

  return (
    <div className="user-profile">
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <img src={user.avatar} alt={user.name} />
    </div>
  );
}

// Effect with cleanup - for subscriptions, timers, etc.
function Timer() {
  const [seconds, setSeconds] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    let intervalId;

    if (isRunning) {
      intervalId = setInterval(() => {
        setSeconds(seconds => seconds + 1);
      }, 1000);
    }

    // Cleanup function - runs when component unmounts or dependencies change
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isRunning]); // Re-run when isRunning changes

  const handleStart = () => setIsRunning(true);
  const handleStop = () => setIsRunning(false);
  const handleReset = () => {
    setIsRunning(false);
    setSeconds(0);
  };

  return (
    <div className="timer">
      <h2>Timer: {seconds}s</h2>
      <button onClick={handleStart} disabled={isRunning}>
        Start
      </button>
      <button onClick={handleStop} disabled={!isRunning}>
        Stop
      </button>
      <button onClick={handleReset}>Reset</button>
    </div>
  );
}

// Real-world example: Chat application
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    // Simulate WebSocket connection
    const socket = {
      connect: () => {
        console.log(`Connecting to room ${roomId}`);
        setIsConnected(true);
        
        // Simulate receiving messages
        const messageInterval = setInterval(() => {
          setMessages(prev => [
            ...prev,
            {
              id: Date.now(),
              text: `Random message ${Math.floor(Math.random() * 1000)}`,
              sender: 'Other User',
              timestamp: new Date()
            }
          ]);
        }, 5000);

        return { messageInterval };
      },
      
      disconnect: (cleanup) => {
        console.log(`Disconnecting from room ${roomId}`);
        setIsConnected(false);
        if (cleanup.messageInterval) {
          clearInterval(cleanup.messageInterval);
        }
      },
      
      sendMessage: (message) => {
        setMessages(prev => [
          ...prev,
          {
            id: Date.now(),
            text: message,
            sender: 'You',
            timestamp: new Date()
          }
        ]);
      }
    };

    const cleanup = socket.connect();

    // Cleanup when component unmounts or roomId changes
    return () => {
      socket.disconnect(cleanup);
    };
  }, [roomId]);

  const sendMessage = () => {
    if (newMessage.trim() && isConnected) {
      // In real app, this would send via WebSocket
      setMessages(prev => [
        ...prev,
        {
          id: Date.now(),
          text: newMessage,
          sender: 'You',
          timestamp: new Date()
        }
      ]);
      setNewMessage('');
    }
  };

  return (
    <div className="chat-room">
      <div className="chat-header">
        <h2>Room {roomId}</h2>
        <span className={`status ${isConnected ? 'connected' : 'disconnected'}`}>
          {isConnected ? '🟢 Connected' : '🔴 Disconnected'}
        </span>
      </div>

      <div className="messages">
        {messages.map(message => (
          <div key={message.id} className={`message ${message.sender === 'You' ? 'own' : 'other'}`}>
            <div className="message-header">
              <span className="sender">{message.sender}</span>
              <span className="timestamp">
                {message.timestamp.toLocaleTimeString()}
              </span>
            </div>
            <div className="message-text">{message.text}</div>
          </div>
        ))}
      </div>

      <div className="message-input">
        <input
          type="text"
          value={newMessage}
          onChange={(e) => setNewMessage(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
          placeholder="Type a message..."
          disabled={!isConnected}
        />
        <button onClick={sendMessage} disabled={!isConnected || !newMessage.trim()}>
          Send
        </button>
      </div>
    </div>
  );
}
```

## Event Handling in React

```jsx
import React, { useState } from 'react';

// Basic event handling
function ButtonExample() {
  const handleClick = (e) => {
    e.preventDefault(); // Prevent default behavior
    console.log('Button clicked!');
    console.log('Event:', e);
    console.log('Target:', e.target);
  };

  const handleMouseEnter = () => {
    console.log('Mouse entered!');
  };

  return (
    <div>
      <button 
        onClick={handleClick}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={() => console.log('Mouse left!')}
      >
        Click me!
      </button>
    </div>
  );
}

// Form handling
function ContactForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: '',
    category: 'general'
  });

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      const response = await fetch('/api/contact', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (response.ok) {
        alert('Message sent successfully!');
        setFormData({
          name: '',
          email: '',
          message: '',
          category: 'general'
        });
      } else {
        throw new Error('Failed to send message');
      }
    } catch (error) {
      alert('Error: ' + error.message);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="contact-form">
      <div className="form-group">
        <label htmlFor="name">Name:</label>
        <input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleInputChange}
          required
        />
      </div>

      <div className="form-group">
        <label htmlFor="category">Category:</label>
        <select
          id="category"
          name="category"
          value={formData.category}
          onChange={handleInputChange}
        >
          <option value="general">General</option>
          <option value="support">Support</option>
          <option value="sales">Sales</option>
          <option value="feedback">Feedback</option>
        </select>
      </div>

      <div className="form-group">
        <label htmlFor="message">Message:</label>
        <textarea
          id="message"
          name="message"
          value={formData.message}
          onChange={handleInputChange}
          rows="5"
          required
        />
      </div>

      <button type="submit">Send Message</button>
    </form>
  );
}

// Advanced event handling - delegated events
function TaskList() {
  const [tasks, setTasks] = useState([
    { id: 1, text: 'Learn React', completed: false },
    { id: 2, text: 'Build a project', completed: false },
    { id: 3, text: 'Deploy to production', completed: false }
  ]);

  // Single event handler for all task actions
  const handleTaskAction = (e) => {
    const taskId = parseInt(e.target.dataset.taskId);
    const action = e.target.dataset.action;

    switch (action) {
      case 'toggle':
        setTasks(tasks.map(task =>
          task.id === taskId ? { ...task, completed: !task.completed } : task
        ));
        break;
      
      case 'delete':
        setTasks(tasks.filter(task => task.id !== taskId));
        break;
      
      case 'edit':
        const newText = prompt('Edit task:', tasks.find(t => t.id === taskId)?.text);
        if (newText !== null) {
          setTasks(tasks.map(task =>
            task.id === taskId ? { ...task, text: newText } : task
          ));
        }
        break;
      
      default:
        console.log('Unknown action:', action);
    }
  };

  return (
    <div className="task-list" onClick={handleTaskAction}>
      <h2>Tasks</h2>
      {tasks.map(task => (
        <div key={task.id} className={`task ${task.completed ? 'completed' : ''}`}>
          <input
            type="checkbox"
            checked={task.completed}
            data-task-id={task.id}
            data-action="toggle"
            onChange={() => {}} // Handled by parent onClick
          />
          <span className="task-text">{task.text}</span>
          <button data-task-id={task.id} data-action="edit">
            Edit
          </button>
          <button data-task-id={task.id} data-action="delete">
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}
```

## Real-World React Application Example

```jsx
import React, { useState, useEffect } from 'react';

// E-commerce Product Catalog
function ProductCatalog() {
  const [products, setProducts] = useState([]);
  const [cart, setCart] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Fetch products on component mount
  useEffect(() => {
    const fetchProducts = async () => {
      try {
        setLoading(true);
        // In real app, this would be an API call
        const response = await new Promise(resolve => {
          setTimeout(() => {
            resolve({
              ok: true,
              json: () => Promise.resolve([
                { id: 1, name: 'Laptop', price: 999, category: 'electronics', image: 'laptop.jpg' },
                { id: 2, name: 'T-Shirt', price: 29, category: 'clothing', image: 'tshirt.jpg' },
                { id: 3, name: 'Coffee Mug', price: 15, category: 'home', image: 'mug.jpg' },
                { id: 4, name: 'Phone', price: 599, category: 'electronics', image: 'phone.jpg' },
                { id: 5, name: 'Jeans', price: 79, category: 'clothing', image: 'jeans.jpg' },
              ])
            });
          }, 1000);
        });
        
        if (response.ok) {
          const data = await response.json();
          setProducts(data);
        } else {
          throw new Error('Failed to fetch products');
        }
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchProducts();
  }, []);

  // Filter products based on search and category
  const filteredProducts = products.filter(product => {
    const matchesSearch = product.name.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesCategory = selectedCategory === 'all' || product.category === selectedCategory;
    return matchesSearch && matchesCategory;
  });

  // Add product to cart
  const addToCart = (product) => {
    setCart(prevCart => {
      const existingItem = prevCart.find(item => item.id === product.id);
      if (existingItem) {
        return prevCart.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      } else {
        return [...prevCart, { ...product, quantity: 1 }];
      }
    });
  };

  // Remove from cart
  const removeFromCart = (productId) => {
    setCart(prevCart => prevCart.filter(item => item.id !== productId));
  };

  // Update quantity
  const updateQuantity = (productId, newQuantity) => {
    if (newQuantity <= 0) {
      removeFromCart(productId);
    } else {
      setCart(prevCart =>
        prevCart.map(item =>
          item.id === productId
            ? { ...item, quantity: newQuantity }
            : item
        )
      );
    }
  };

  // Calculate total
  const cartTotal = cart.reduce((total, item) => total + (item.price * item.quantity), 0);

  if (loading) return <div className="loading">Loading products...</div>;
  if (error) return <div className="error">Error: {error}</div>;

  return (
    <div className="product-catalog">
      <header className="catalog-header">
        <h1>Product Catalog</h1>
        <CartSummary cart={cart} total={cartTotal} />
      </header>

      <div className="filters">
        <input
          type="text"
          placeholder="Search products..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="search-input"
        />
        
        <select
          value={selectedCategory}
          onChange={(e) => setSelectedCategory(e.target.value)}
          className="category-filter"
        >
          <option value="all">All Categories</option>
          <option value="electronics">Electronics</option>
          <option value="clothing">Clothing</option>
          <option value="home">Home</option>
        </select>
      </div>

      <div className="product-grid">
        {filteredProducts.map(product => (
          <ProductCard
            key={product.id}
            product={product}
            onAddToCart={addToCart}
            inCart={cart.some(item => item.id === product.id)}
          />
        ))}
      </div>

      {filteredProducts.length === 0 && (
        <div className="no-products">
          No products found matching your criteria.
        </div>
      )}

      <Cart
        cart={cart}
        onRemove={removeFromCart}
        onUpdateQuantity={updateQuantity}
        total={cartTotal}
      />
    </div>
  );
}

// Product Card Component
function ProductCard({ product, onAddToCart, inCart }) {
  return (
    <div className="product-card">
      <img src={product.image} alt={product.name} />
      <h3>{product.name}</h3>
      <p className="price">${product.price}</p>
      <p className="category">{product.category}</p>
      <button
        onClick={() => onAddToCart(product)}
        className={`add-to-cart ${inCart ? 'in-cart' : ''}`}
        disabled={inCart}
      >
        {inCart ? 'In Cart' : 'Add to Cart'}
      </button>
    </div>
  );
}

// Cart Summary Component
function CartSummary({ cart, total }) {
  const itemCount = cart.reduce((sum, item) => sum + item.quantity, 0);

  return (
    <div className="cart-summary">
      <span className="cart-icon">🛒</span>
      <span className="item-count">{itemCount} items</span>
      <span className="cart-total">${total.toFixed(2)}</span>
    </div>
  );
}

// Cart Component
function Cart({ cart, onRemove, onUpdateQuantity, total }) {
  const [isOpen, setIsOpen] = useState(false);

  if (!isOpen) {
    return (
      <button
        className="cart-toggle"
        onClick={() => setIsOpen(true)}
      >
        View Cart ({cart.length})
      </button>
    );
  }

  return (
    <div className="cart-overlay">
      <div className="cart-modal">
        <div className="cart-header">
          <h2>Shopping Cart</h2>
          <button onClick={() => setIsOpen(false)}>×</button>
        </div>

        <div className="cart-items">
          {cart.length === 0 ? (
            <p>Your cart is empty</p>
          ) : (
            cart.map(item => (
              <div key={item.id} className="cart-item">
                <img src={item.image} alt={item.name} />
                <div className="item-details">
                  <h4>{item.name}</h4>
                  <p>${item.price}</p>
                </div>
                <div className="quantity-controls">
                  <button onClick={() => onUpdateQuantity(item.id, item.quantity - 1)}>
                    -
                  </button>
                  <span>{item.quantity}</span>
                  <button onClick={() => onUpdateQuantity(item.id, item.quantity + 1)}>
                    +
                  </button>
                </div>
                <div className="item-total">
                  ${(item.price * item.quantity).toFixed(2)}
                </div>
                <button
                  onClick={() => onRemove(item.id)}
                  className="remove-button"
                >
                  Remove
                </button>
              </div>
            ))
          )}
        </div>

        {cart.length > 0 && (
          <div className="cart-footer">
            <div className="cart-total">
              <strong>Total: ${total.toFixed(2)}</strong>
            </div>
            <button className="checkout-button">
              Proceed to Checkout
            </button>
          </div>
        )}
      </div>
    </div>
  );
}
```

## React Patterns and Best Practices

### Custom Hooks - Reusable Logic

```jsx
import { useState, useEffect } from 'react';

// Custom hook for API fetching
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    if (url) {
      fetchData();
    }
  }, [url]);

  return { data, loading, error };
}

// Custom hook for local storage
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.log(error);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.log(error);
    }
  };

  return [storedValue, setValue];
}

// Custom hook for form handling
function useForm(initialValues, validate) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const handleSubmit = async (onSubmit) => {
    setIsSubmitting(true);
    
    if (validate) {
      const validationErrors = validate(values);
      if (Object.keys(validationErrors).length > 0) {
        setErrors(validationErrors);
        setIsSubmitting(false);
        return;
      }
    }

    try {
      await onSubmit(values);
      setValues(initialValues); // Reset form
      setErrors({});
    } catch (error) {
      setErrors({ submit: error.message });
    }
    
    setIsSubmitting(false);
  };

  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit,
    setValues,
    setErrors
  };
}

// Using custom hooks
function UserProfile({ userId }) {
  const { data: user, loading, error } = useApi(`/api/users/${userId}`);
  const [preferences, setPreferences] = useLocalStorage('userPreferences', {
    theme: 'light',
    notifications: true
  });

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div className="user-profile">
      <h1>{user.name}</h1>
      <div className="preferences">
        <label>
          <input
            type="checkbox"
            checked={preferences.notifications}
            onChange={(e) => setPreferences(prev => ({
              ...prev,
              notifications: e.target.checked
            }))}
          />
          Enable notifications
        </label>
      </div>
    </div>
  );
}
```

### Conditional Rendering Patterns

```jsx
// If-else rendering
function UserGreeting({ user, isLoggedIn }) {
  if (!isLoggedIn) {
    return (
      <div className="auth-prompt">
        <h2>Please log in</h2>
        <button>Login</button>
      </div>
    );
  }

  if (!user) {
    return <div>Loading user...</div>;
  }

  return (
    <div className="user-greeting">
      <h2>Welcome back, {user.name}!</h2>
    </div>
  );
}

// Ternary operator
function StatusBadge({ isOnline }) {
  return (
    <span className={`status-badge ${isOnline ? 'online' : 'offline'}`}>
      {isOnline ? '🟢 Online' : '🔴 Offline'}
    </span>
  );
}

// Logical AND operator
function NotificationBell({ notifications }) {
  return (
    <div className="notification-bell">
      🔔
      {notifications.length > 0 && (
        <span className="notification-count">
          {notifications.length}
        </span>
      )}
    </div>
  );
}

// Switch statement pattern
function UserRole({ role }) {
  const getRoleDisplay = () => {
    switch (role) {
      case 'admin':
        return { icon: '👑', label: 'Administrator', color: 'gold' };
      case 'moderator':
        return { icon: '🛡️', label: 'Moderator', color: 'blue' };
      case 'user':
        return { icon: '👤', label: 'User', color: 'gray' };
      default:
        return { icon: '❓', label: 'Unknown', color: 'red' };
    }
  };

  const { icon, label, color } = getRoleDisplay();

  return (
    <span className="user-role" style={{ color }}>
      {icon} {label}
    </span>
  );
}

// Complex conditional rendering
function Dashboard({ user, permissions, data }) {
  const canViewAnalytics = permissions.includes('analytics');
  const canManageUsers = permissions.includes('user_management');
  const hasData = data && data.length > 0;

  return (
    <div className="dashboard">
      <header>
        <h1>Dashboard</h1>
        <UserRole role={user.role} />
      </header>

      {!hasData ? (
        <div className="empty-state">
          <h2>No data available</h2>
          <p>Start by adding some content.</p>
          <button>Add Content</button>
        </div>
      ) : (
        <div className="dashboard-content">
          {canViewAnalytics && (
            <section className="analytics-section">
              <h2>Analytics</h2>
              <AnalyticsCharts data={data} />
            </section>
          )}

          <section className="main-content">
            <h2>Recent Activity</h2>
            <ActivityFeed activities={data.activities} />
          </section>

          {canManageUsers && (
            <aside className="user-management">
              <h3>User Management</h3>
              <UserManagementPanel />
            </aside>
          )}
        </div>
      )}
    </div>
  );
}
```

## JSX Security and Best Practices

```jsx
// Safe JSX practices
function SafeComponent({ userInput, htmlContent }) {
  // ✅ Safe - JSX automatically escapes values
  const safeContent = <div>{userInput}</div>;

  // ❌ Dangerous - using dangerouslySetInnerHTML
  const dangerousContent = (
    <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
  );

  // ✅ Safe alternative - sanitize HTML first
  const sanitizeHtml = (html) => {
    // In real app, use a library like DOMPurify
    return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
  };

  const sanitizedContent = (
    <div dangerouslySetInnerHTML={{ __html: sanitizeHtml(htmlContent) }} />
  );

  return (
    <div>
      {safeContent}
      {sanitizedContent}
    </div>
  );
}

// Performance optimization
import React, { memo, useMemo, useCallback } from 'react';

// Memoized component - only re-renders when props change
const ExpensiveComponent = memo(function ExpensiveComponent({ data, onUpdate }) {
  const processedData = useMemo(() => {
    // Expensive computation
    return data.map(item => ({
      ...item,
      processed: true,
      timestamp: Date.now()
    }));
  }, [data]);

  const handleUpdate = useCallback((id, newValue) => {
    onUpdate(id, newValue);
  }, [onUpdate]);

  return (
    <div>
      {processedData.map(item => (
        <div key={item.id} onClick={() => handleUpdate(item.id, 'updated')}>
          {item.name}
        </div>
      ))}
    </div>
  );
});

// Proper key usage
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        // ✅ Good - stable, unique key
        <li key={todo.id}>
          <TodoItem todo={todo} />
        </li>
      ))}
    </ul>
  );
}

function BadTodoList({ todos }) {
  return (
    <ul>
      {todos.map((todo, index) => (
        // ❌ Bad - index as key can cause issues
        <li key={index}>
          <TodoItem todo={todo} />
        </li>
      ))}
    </ul>
  );
}
```

## Conclusion: Mastering JSX and React

JSX bridges the gap between declarative UI design and powerful JavaScript programming. Here are the key takeaways:

### Core Concepts
1. **JSX Syntax** - HTML-like syntax that compiles to JavaScript
2. **Components** - Reusable UI building blocks
3. **Props** - Data passed between components
4. **State** - Component's internal data that can change
5. **Effects** - Side effects and lifecycle management

### Modern React Patterns
1. **Function Components** - Preferred over class components
2. **Hooks** - useState, useEffect, and custom hooks
3. **Composition** - Building complex UIs from simple components
4. **Conditional Rendering** - Dynamic UI based on state/props
5. **Event Handling** - Interactive user experiences

### Real-World Applications
1. **State Management** - Managing application data flow
2. **API Integration** - Fetching and displaying data
3. **Form Handling** - User input and validation
4. **Performance Optimization** - Memoization and lazy loading
5. **Code Organization** - Custom hooks and component patterns

### Your React Learning Path

1. **Master JSX Syntax** - Understand the transformation from JSX to JavaScript
2. **Learn Component Basics** - Props, composition, and reusability
3. **Understand State Management** - useState for component state
4. **Master Effects** - useEffect for side effects and data fetching
5. **Build Real Projects** - Todo apps, dashboards, e-commerce sites
6. **Learn Advanced Patterns** - Custom hooks, context, and optimization
7. **Explore the Ecosystem** - React Router, state management libraries, UI frameworks

### Best Practices to Remember

1. **Keep components small and focused** - Single responsibility principle
2. **Use descriptive prop names** - Make component APIs clear
3. **Handle loading and error states** - Robust user experience
4. **Optimize for performance** - Memoization when needed
5. **Test your components** - Ensure reliability
6. **Follow naming conventions** - PascalCase for components
7. **Use TypeScript** - Better development experience and fewer bugs

### The React Philosophy

React represents a paradigm shift in web development:
- **Declarative over Imperative** - Describe what UI should look like, not how to achieve it
- **Component-Based Architecture** - Encapsulated, reusable UI pieces
- **Unidirectional Data Flow** - Predictable state management
- **Learn Once, Write Anywhere** - React Native for mobile, Next.js for SSR

### Building Your First React Application

Start with these projects to practice:

1. **Counter App** - useState basics
2. **Todo List** - State management and events
3. **Weather App** - API fetching with useEffect
4. **Shopping Cart** - Complex state and conditional rendering
5. **Chat Application** - Real-time updates and effects
6. **Dashboard** - Multiple components and data flow

**Remember**: React is not just a library - it's a way of thinking about user interfaces. Once you master the concept of components, state, and props, you'll be able to build any user interface you can imagine.

The journey from HTML/CSS/JavaScript to React represents a leap from static pages to dynamic, interactive applications. JSX is your bridge to this new world of possibilities. Keep practicing, building, and exploring - React will unlock a whole new level of web development capabilities!

**Final Tip**: Start small, build incrementally, and don't be afraid to refactor. Great React applications are built component by component, feature by feature. Master the fundamentals, and the rest will follow naturally.

### JSX Rules

```jsx
// 1. Must return a single parent element
function MyComponent() {
    return (
        <div>  {/* Single parent wrapper */}
            <h1>Title</h1>
            <p>Content</p>
        </div>
    );
}

// 2. Use className instead of class
const element = <div className="my-class">Content</div>;

// 3. Self-closing tags need /
const image = <img src="photo.jpg" alt="Photo" />;
const input = <input type="text" />;

// 4. Use camelCase for attributes
const button = <button onClick={handleClick}>Click me</button>;
```

### JavaScript in JSX

```jsx
function UserProfile() {
    const user = {
        name: "Alice",
        age: 28,
        isOnline: true
    };
    
    return (
        <div>
            <h1>Welcome, {user.name}!</h1>
            <p>Age: {user.age}</p>
            <p>Status: {user.isOnline ? "Online" : "Offline"}</p>
            <p>Next year you'll be {user.age + 1}</p>
        </div>
    );
}
```

## Components - Reusable UI Pieces

Components are like **custom HTML tags** that you create. They're the building blocks of React applications.

### Function Components (Modern Way)

```jsx
// Simple component
function Button() {
    return <button>Click me</button>;
}

// Component with logic
function WelcomeMessage() {
    const currentTime = new Date().toLocaleTimeString();
    
    return (
        <div>
            <h1>Welcome!</h1>
            <p>Current time: {currentTime}</p>
        </div>
    );
}

// Using components
function App() {
    return (
        <div>
            <WelcomeMessage />
            <Button />
            <Button />  {/* Reused! */}
        </div>
    );
}
```

### Component Organization

```jsx
// Header.jsx - A reusable header
function Header() {
    return (
        <header style={{ backgroundColor: '#333', color: 'white', padding: '20px' }}>
            <h1>My Website</h1>
            <nav>
                <a href="/">Home</a>
                <a href="/about">About</a>
                <a href="/contact">Contact</a>
            </nav>
        </header>
    );
}

// Footer.jsx - A reusable footer
function Footer() {
    const year = new Date().getFullYear();
    return (
        <footer style={{ textAlign: 'center', padding: '20px', backgroundColor: '#f0f0f0' }}>
            <p>&copy; {year} My Website. All rights reserved.</p>
        </footer>
    );
}

// App.jsx - Main application
function App() {
    return (
        <div>
            <Header />
            <main>
                <h2>Welcome to my website!</h2>
                <p>This is the main content.</p>
            </main>
            <Footer />
        </div>
    );
}
```

## Props - Passing Data to Components

Props are like **function arguments** for components. They let you pass data from a parent component to a child component.

### Basic Props

```jsx
// Component that receives props
function Greeting(props) {
    return <h1>Hello, {props.name}!</h1>;
}

// Using the component with props
function App() {
    return (
        <div>
            <Greeting name="Alice" />
            <Greeting name="Bob" />
            <Greeting name="Charlie" />
        </div>
    );
}
```

### Destructuring Props (Cleaner Syntax)

```jsx
// Instead of props.name, props.age, etc.
function UserCard(props) {
    return (
        <div>
            <h2>{props.name}</h2>
            <p>Age: {props.age}</p>
            <p>Job: {props.job}</p>
        </div>
    );
}

// Destructure props for cleaner code
function UserCard({ name, age, job }) {
    return (
        <div>
            <h2>{name}</h2>
            <p>Age: {age}</p>
            <p>Job: {job}</p>
        </div>
    );
}

// Usage
function App() {
    return (
        <div>
            <UserCard name="Alice" age={28} job="Designer" />
            <UserCard name="Bob" age={32} job="Developer" />
        </div>
    );
}
```

### Props with Different Data Types

```jsx
function ProductCard({ name, price, inStock, tags, onBuy }) {
    return (
        <div className="product-card">
            <h3>{name}</h3>
            <p>Price: ${price}</p>
            <p>Status: {inStock ? "In Stock" : "Out of Stock"}</p>
            
            <div>
                Tags: {tags.map(tag => (
                    <span key={tag} className="tag">{tag}</span>
                ))}
            </div>
            
            <button 
                onClick={onBuy}
                disabled={!inStock}
            >
                {inStock ? "Buy Now" : "Sold Out"}
            </button>
        </div>
    );
}

// Usage
function App() {
    const handlePurchase = () => {
        alert("Thanks for your purchase!");
    };
    
    return (
        <ProductCard
            name="Laptop"
            price={999}
            inStock={true}
            tags={["electronics", "computers", "portable"]}
            onBuy={handlePurchase}
        />
    );
}
```

## State (useState) - Dynamic Data

State is like a **component's memory**. It stores data that can change over time and automatically updates the UI when it changes.

### Basic useState

```jsx
import { useState } from 'react';

function Counter() {
    // useState returns [currentValue, functionToUpdateValue]
    const [count, setCount] = useState(0); // Start with 0
    
    const increment = () => {
        setCount(count + 1);
    };
    
    const decrement = () => {
        setCount(count - 1);
    };
    
    return (
        <div>
            <h2>Count: {count}</h2>
            <button onClick={increment}>+</button>
            <button onClick={decrement}>-</button>
        </div>
    );
}
```

**Think of useState as:** A magic box that remembers values and tells React to update the screen when they change.

### Different Types of State

```jsx
function UserProfile() {
    // String state
    const [name, setName] = useState("Guest");
    
    // Boolean state
    const [isLoggedIn, setIsLoggedIn] = useState(false);
    
    // Array state
    const [hobbies, setHobbies] = useState(["reading", "coding"]);
    
    // Object state
    const [user, setUser] = useState({
        email: "",
        age: 0,
        preferences: []
    });
    
    return (
        <div>
            <h1>Welcome, {name}!</h1>
            <p>Status: {isLoggedIn ? "Logged In" : "Guest"}</p>
            
            <input 
                type="text" 
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Enter your name"
            />
            
            <button onClick={() => setIsLoggedIn(!isLoggedIn)}>
                {isLoggedIn ? "Log Out" : "Log In"}
            </button>
        </div>
    );
}
```

### Practical State Examples

```jsx
// Todo List with State
function TodoApp() {
    const [todos, setTodos] = useState([]);
    const [inputValue, setInputValue] = useState("");
    
    const addTodo = () => {
        if (inputValue.trim()) {
            const newTodo = {
                id: Date.now(),
                text: inputValue,
                completed: false
            };
            setTodos([...todos, newTodo]);
            setInputValue("");
        }
    };
    
    const toggleTodo = (id) => {
        setTodos(todos.map(todo => 
            todo.id === id 
                ? { ...todo, completed: !todo.completed }
                : todo
        ));
    };
    
    const deleteTodo = (id) => {
        setTodos(todos.filter(todo => todo.id !== id));
    };
    
    return (
        <div>
            <h1>My Todos</h1>
            
            <div>
                <input 
                    type="text"
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    placeholder="Add a todo..."
                />
                <button onClick={addTodo}>Add</button>
            </div>
            
            <ul>
                {todos.map(todo => (
                    <li key={todo.id}>
                        <span 
                            style={{ 
                                textDecoration: todo.completed ? 'line-through' : 'none' 
                            }}
                            onClick={() => toggleTodo(todo.id)}
                        >
                            {todo.text}
                        </span>
                        <button onClick={() => deleteTodo(todo.id)}>Delete</button>
                    </li>
                ))}
            </ul>
        </div>
    );
}
```

## useEffect - Side Effects and Lifecycle

useEffect is like a **component's assistant** that handles things like:
- Fetching data from servers
- Setting up timers
- Updating the page title
- Cleaning up when component disappears

### Basic useEffect

```jsx
import { useState, useEffect } from 'react';

function UserProfile() {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    
    // useEffect runs after component renders
    useEffect(() => {
        // Simulate fetching user data
        setTimeout(() => {
            setUser({
                name: "John Doe",
                email: "john@example.com"
            });
            setLoading(false);
        }, 2000);
    }, []); // Empty array means "run once when component mounts"
    
    if (loading) {
        return <div>Loading user data...</div>;
    }
    
    return (
        <div>
            <h1>{user.name}</h1>
            <p>{user.email}</p>
        </div>
    );
}
```

### useEffect with Dependencies

```jsx
function WeatherWidget({ city }) {
    const [weather, setWeather] = useState(null);
    const [loading, setLoading] = useState(false);
    
    useEffect(() => {
        if (!city) return;
        
        setLoading(true);
        
        // Fetch weather data when city changes
        fetch(`/api/weather/${city}`)
            .then(response => response.json())
            .then(data => {
                setWeather(data);
                setLoading(false);
            })
            .catch(error => {
                console.error('Error:', error);
                setLoading(false);
            });
    }, [city]); // Run effect when 'city' changes
    
    return (
        <div>
            <h2>Weather in {city}</h2>
            {loading ? (
                <p>Loading weather...</p>
            ) : weather ? (
                <div>
                    <p>Temperature: {weather.temp}°F</p>
                    <p>Condition: {weather.condition}</p>
                </div>
            ) : (
                <p>No weather data available</p>
            )}
        </div>
    );
}
```

### useEffect for Timers and Cleanup

```jsx
function Timer() {
    const [seconds, setSeconds] = useState(0);
    const [isRunning, setIsRunning] = useState(false);
    
    useEffect(() => {
        let interval = null;
        
        if (isRunning) {
            interval = setInterval(() => {
                setSeconds(prev => prev + 1);
            }, 1000);
        }
        
        // Cleanup function - runs when effect is cleaned up
        return () => {
            if (interval) {
                clearInterval(interval);
            }
        };
    }, [isRunning]); // Re-run when isRunning changes
    
    const reset = () => {
        setSeconds(0);
        setIsRunning(false);
    };
    
    return (
        <div>
            <h1>Timer: {seconds}s</h1>
            <button onClick={() => setIsRunning(!isRunning)}>
                {isRunning ? "Pause" : "Start"}
            </button>
            <button onClick={reset}>Reset</button>
        </div>
    );
}
```

## Putting It All Together - Complete React Application

```jsx
// App.jsx - Main application
import { useState, useEffect } from 'react';

// Reusable Header Component
function Header({ title, subtitle }) {
    return (
        <header style={{ 
            backgroundColor: '#2c3e50', 
            color: 'white', 
            padding: '20px',
            textAlign: 'center'
        }}>
            <h1>{title}</h1>
            {subtitle && <p>{subtitle}</p>}
        </header>
    );
}

// User Card Component
function UserCard({ user, onSelect, isSelected }) {
    return (
        <div 
            style={{
                border: isSelected ? '3px solid #3498db' : '1px solid #ddd',
                padding: '15px',
                margin: '10px',
                borderRadius: '8px',
                cursor: 'pointer',
                backgroundColor: isSelected ? '#ecf0f1' : 'white'
            }}
            onClick={() => onSelect(user)}
        >
            <h3>{user.name}</h3>
            <p>Email: {user.email}</p>
            <p>Posts: {user.posts}</p>
        </div>
    );
}

// User Details Component
function UserDetails({ user }) {
    const [posts, setPosts] = useState([]);
    const [loading, setLoading] = useState(false);
    
    useEffect(() => {
        if (!user) return;
        
        setLoading(true);
        
        // Simulate fetching user posts
        setTimeout(() => {
            const mockPosts = [
                { id: 1, title: "My first post", content: "Hello world!" },
                { id: 2, title: "React is awesome", content: "Learning React has been great!" },
                { id: 3, title: "Building components", content: "Components make code reusable." }
            ];
            setPosts(mockPosts.slice(0, user.posts));
            setLoading(false);
        }, 1000);
    }, [user]);
    
    if (!user) {
        return (
            <div style={{ textAlign: 'center', padding: '50px' }}>
                <h2>Select a user to view details</h2>
            </div>
        );
    }
    
    return (
        <div style={{ padding: '20px' }}>
            <h2>{user.name}'s Profile</h2>
            <p><strong>Email:</strong> {user.email}</p>
            <p><strong>Joined:</strong> {user.joinDate}</p>
            
            <h3>Recent Posts</h3>
            {loading ? (
                <p>Loading posts...</p>
            ) : (
                <div>
                    {posts.map(post => (
                        <div key={post.id} style={{
                            border: '1px solid #eee',
                            padding: '10px',
                            margin: '10px 0',
                            borderRadius: '4px'
                        }}>
                            <h4>{post.title}</h4>
                            <p>{post.content}</p>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
}

// Main App Component
function App() {
    const [users, setUsers] = useState([]);
    const [selectedUser, setSelectedUser] = useState(null);
    const [loading, setLoading] = useState(true);
    const [searchTerm, setSearchTerm] = useState("");
    
    // Fetch users on component mount
    useEffect(() => {
        // Simulate API call
        setTimeout(() => {
            const mockUsers = [
                { id: 1, name: "Alice Johnson", email: "alice@example.com", posts: 5, joinDate: "2023-01-15" },
                { id: 2, name: "Bob Smith", email: "bob@example.com", posts: 3, joinDate: "2023-02-20" },
                { id: 3, name: "Charlie Brown", email: "charlie@example.com", posts: 8, joinDate: "2023-01-10" },
                { id: 4, name: "Diana Prince", email: "diana@example.com", posts: 12, joinDate: "2022-12-05" }
            ];
            setUsers(mockUsers);
            setLoading(false);
        }, 1500);
    }, []);
    
    // Filter users based on search term
    const filteredUsers = users.filter(user => 
        user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        user.email.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    if (loading) {
        return (
            <div style={{ textAlign: 'center', padding: '50px' }}>
                <h2>Loading users...</h2>
            </div>
        );
    }
    
    return (
        <div>
            <Header 
                title="User Management App" 
                subtitle="Built with React Hooks"
            />
            
            <div style={{ display: 'flex', minHeight: '500px' }}>
                {/* Users List */}
                <div style={{ width: '40%', borderRight: '1px solid #ddd', padding: '20px' }}>
                    <h2>Users ({filteredUsers.length})</h2>
                    
                    <input
                        type="text"
                        placeholder="Search users..."
                        value={searchTerm}
                        onChange={(e) => setSearchTerm(e.target.value)}
                        style={{
                            width: '100%',
                            padding: '10px',
                            marginBottom: '20px',
                            border: '1px solid #ddd',
                            borderRadius: '4px'
                        }}
                    />
                    
                    {filteredUsers.map(user => (
                        <UserCard
                            key={user.id}
                            user={user}
                            onSelect={setSelectedUser}
                            isSelected={selectedUser?.id === user.id}
                        />
                    ))}
                </div>
                
                {/* User Details */}
                <div style={{ width: '60%' }}>
                    <UserDetails user={selectedUser} />
                </div>
            </div>
        </div>
    );
}

export default App;
```

## Key Concepts Summary

### 1. **Components** 
- Reusable pieces of UI
- Like custom HTML tags
- Keep them small and focused

### 2. **JSX**
- HTML-like syntax in JavaScript
- Use `{}` to embed JavaScript expressions
- Follow JSX rules (className, self-closing tags, etc.)

### 3. **Props**
- Data passed from parent to child components
- Read-only (immutable)
- Like function arguments

### 4. **State (useState)**
- Component's memory
- Triggers re-renders when changed
- Use for data that changes over time

### 5. **Effects (useEffect)**
- Handle side effects (API calls, timers, etc.)
- Dependency array controls when it runs
- Return cleanup function when needed

## Best Practices

1. **Keep components small** - Each component should do one thing well
2. **Use descriptive names** - `UserCard` is better than `Card`
3. **Destructure props** - `function Button({ text, onClick })` is cleaner
4. **Don't mutate state directly** - Always use the setter function
5. **Use keys for lists** - React needs them for efficient updates
6. **Handle loading and error states** - Always consider what happens while waiting for data

React might seem complex at first, but it's just JavaScript with some helpful patterns. Start with simple components and gradually build up to more complex applications. The key is practice - build lots of small projects to get comfortable with these concepts!
